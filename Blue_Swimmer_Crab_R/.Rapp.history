pars.inc <- c(pars, theta.2, BscVar(var.par.1, var.par.2, linf))
print(c(log.like.full, log.like.full - log.like.old))#
  print(pars.inc)
pis <- t(sapply(num.months.seq, PiCalc))
pis
log.like.old <- log.like.full
log.like.old
pis <- t(sapply(num.months.seq, PiCalc))
pis
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1#
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
# MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             # mu.init.par, var.init.par, theta.const.par, #
                             # thetas.par, yrs.old.par, str.mnth.par)#
# {	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.init <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh  <- matrix(0, nrow = num.months, ncol = no.grps)#
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf
log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))
pis
if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
  }#
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))	#
  pars            <- optim.means.var$par#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  if (theta.const == 1)#
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	var.par.1  <- pars[4]#
  	var.par.2  <- pars[5]#
  	mu.yr      <- pars[6:length(pars)]#
  } else #
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	theta.2    <- pars[4]#
  	var.par.1  <- pars[5]#
  	var.par.2  <- pars[6]#
  	mu.yr      <- pars[7:length(pars)]#
  }#
  # If male or female we keep thetas fixed so turn off thetas#
  # above and turn those on below. Look in bsc_mean_var_func.R#
  # for more details#
  if (theta.const == 1)#
  {#
  	theta.2   <- (theta.1 * (sqrt(1 - cos(2 * pi * max.contr)^2))) /#
                 cos(2 * pi * max.contr) #
  }#
  # Calculate the means again for the final likelihood update#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh[, i] <- sapply(mean.mnth.coh[, i], BscVar, var.par.1 = var.par.1,#
                                var.par.2 = var.par.2)#
  }#
  # Evaluate the likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  # Give a plot of the current state of the model versus the data#
  #BscPlotNew(c(theta.const, pars))#
#
  # Pars including sigma^2 linf and theta 2#
  pars.inc <- c(pars, theta.2, BscVar(var.par.1, var.par.2, linf))#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars.inc)
pis <- t(sapply(num.months.seq, PiCalc))
pis
# Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
  }#
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))	#
  pars            <- optim.means.var$par#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  if (theta.const == 1)#
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	var.par.1  <- pars[4]#
  	var.par.2  <- pars[5]#
  	mu.yr      <- pars[6:length(pars)]#
  } else #
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	theta.2    <- pars[4]#
  	var.par.1  <- pars[5]#
  	var.par.2  <- pars[6]#
  	mu.yr      <- pars[7:length(pars)]#
  }#
  # If male or female we keep thetas fixed so turn off thetas#
  # above and turn those on below. Look in bsc_mean_var_func.R#
  # for more details#
  if (theta.const == 1)#
  {#
  	theta.2   <- (theta.1 * (sqrt(1 - cos(2 * pi * max.contr)^2))) /#
                 cos(2 * pi * max.contr) #
  }#
  # Calculate the means again for the final likelihood update#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh[, i] <- sapply(mean.mnth.coh[, i], BscVar, var.par.1 = var.par.1,#
                                var.par.2 = var.par.2)#
  }#
  # Evaluate the likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  # Give a plot of the current state of the model versus the data#
  #BscPlotNew(c(theta.const, pars))#
#
  # Pars including sigma^2 linf and theta 2#
  pars.inc <- c(pars, theta.2, BscVar(var.par.1, var.par.2, linf))#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars.inc)
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1#
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
# MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             # mu.init.par, var.init.par, theta.const.par, #
                             # thetas.par, yrs.old.par, str.mnth.par)#
# {	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.init <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh  <- matrix(0, nrow = num.months, ncol = no.grps)#
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf
# Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
  }#
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))	#
  pars            <- optim.means.var$par#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  if (theta.const == 1)#
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	var.par.1  <- pars[4]#
  	var.par.2  <- pars[5]#
  	mu.yr      <- pars[6:length(pars)]#
  } else #
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	theta.2    <- pars[4]#
  	var.par.1  <- pars[5]#
  	var.par.2  <- pars[6]#
  	mu.yr      <- pars[7:length(pars)]#
  }#
  # If male or female we keep thetas fixed so turn off thetas#
  # above and turn those on below. Look in bsc_mean_var_func.R#
  # for more details#
  if (theta.const == 1)#
  {#
  	theta.2   <- (theta.1 * (sqrt(1 - cos(2 * pi * max.contr)^2))) /#
                 cos(2 * pi * max.contr) #
  }#
  # Calculate the means again for the final likelihood update#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh[, i] <- sapply(mean.mnth.coh[, i], BscVar, var.par.1 = var.par.1,#
                                var.par.2 = var.par.2)#
  }#
  # Evaluate the likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  # Give a plot of the current state of the model versus the data#
  #BscPlotNew(c(theta.const, pars))#
#
  # Pars including sigma^2 linf and theta 2#
  pars.inc <- c(pars, theta.2, BscVar(var.par.1, var.par.2, linf))#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars.inc)
# Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
  }#
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))	#
  pars            <- optim.means.var$par#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  if (theta.const == 1)#
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	var.par.1  <- pars[4]#
  	var.par.2  <- pars[5]#
  	mu.yr      <- pars[6:length(pars)]#
  } else #
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	theta.2    <- pars[4]#
  	var.par.1  <- pars[5]#
  	var.par.2  <- pars[6]#
  	mu.yr      <- pars[7:length(pars)]#
  }#
  # If male or female we keep thetas fixed so turn off thetas#
  # above and turn those on below. Look in bsc_mean_var_func.R#
  # for more details#
  if (theta.const == 1)#
  {#
  	theta.2   <- (theta.1 * (sqrt(1 - cos(2 * pi * max.contr)^2))) /#
                 cos(2 * pi * max.contr) #
  }#
  # Calculate the means again for the final likelihood update#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh[, i] <- sapply(mean.mnth.coh[, i], BscVar, var.par.1 = var.par.1,#
                                var.par.2 = var.par.2)#
  }#
  # Evaluate the likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  # Give a plot of the current state of the model versus the data#
  #BscPlotNew(c(theta.const, pars))#
#
  # Pars including sigma^2 linf and theta 2#
  pars.inc <- c(pars, theta.2, BscVar(var.par.1, var.par.2, linf))#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars.inc)
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1#
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
# MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             # mu.init.par, var.init.par, theta.const.par, #
                             # thetas.par, yrs.old.par, str.mnth.par)#
# {	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.init <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh  <- matrix(0, nrow = num.months, ncol = no.grps)#
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf	#
# ---------------------------------------
# Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
  }#
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))	#
  pars            <- optim.means.var$par#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  if (theta.const == 1)#
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	var.par.1  <- pars[4]#
  	var.par.2  <- pars[5]#
  	mu.yr      <- pars[6:length(pars)]#
  } else #
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	theta.2    <- pars[4]#
  	var.par.1  <- pars[5]#
  	var.par.2  <- pars[6]#
  	mu.yr      <- pars[7:length(pars)]#
  }#
  # If male or female we keep thetas fixed so turn off thetas#
  # above and turn those on below. Look in bsc_mean_var_func.R#
  # for more details#
  if (theta.const == 1)#
  {#
  	theta.2   <- (theta.1 * (sqrt(1 - cos(2 * pi * max.contr)^2))) /#
                 cos(2 * pi * max.contr) #
  }#
  # Calculate the means again for the final likelihood update#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh[, i] <- sapply(mean.mnth.coh[, i], BscVar, var.par.1 = var.par.1,#
                                var.par.2 = var.par.2)#
  }#
  # Evaluate the likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  # Give a plot of the current state of the model versus the data#
  #BscPlotNew(c(theta.const, pars))#
#
  # Pars including sigma^2 linf and theta 2#
  pars.inc <- c(pars, theta.2, BscVar(var.par.1, var.par.2, linf))#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars.inc)
log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))
pis
if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
  }#
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))	#
  pars            <- optim.means.var$par
print("Did optim converge?")#
  print(optim.means.var$convergence)
# Re-define the global parameters#
  if (theta.const == 1)#
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	var.par.1  <- pars[4]#
  	var.par.2  <- pars[5]#
  	mu.yr      <- pars[6:length(pars)]#
  } else #
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	theta.2    <- pars[4]#
  	var.par.1  <- pars[5]#
  	var.par.2  <- pars[6]#
  	mu.yr      <- pars[7:length(pars)]#
  }
pars
mean.mnth.coh
pis
yrs.old.par
str.mnth.par
mu.yr.fun
pars
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1#
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
# MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             # mu.init.par, var.init.par, theta.const.par, #
                             # thetas.par, yrs.old.par, str.mnth.par)#
# {	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.init <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh  <- matrix(0, nrow = num.months, ncol = no.grps)#
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf
# Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
  }#
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))	#
  pars            <- optim.means.var$par#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  if (theta.const == 1)#
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	var.par.1  <- pars[4]#
  	var.par.2  <- pars[5]#
  	mu.yr      <- pars[6:length(pars)]#
  } else #
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	theta.2    <- pars[4]#
  	var.par.1  <- pars[5]#
  	var.par.2  <- pars[6]#
  	mu.yr      <- pars[7:length(pars)]#
  }#
  # If male or female we keep thetas fixed so turn off thetas#
  # above and turn those on below. Look in bsc_mean_var_func.R#
  # for more details#
  if (theta.const == 1)#
  {#
  	theta.2   <- (theta.1 * (sqrt(1 - cos(2 * pi * max.contr)^2))) /#
                 cos(2 * pi * max.contr) #
  }#
  # Calculate the means again for the final likelihood update#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh[, i] <- sapply(mean.mnth.coh[, i], BscVar, var.par.1 = var.par.1,#
                                var.par.2 = var.par.2)#
  }#
  # Evaluate the likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  # Give a plot of the current state of the model versus the data#
  #BscPlotNew(c(theta.const, pars))#
#
  # Pars including sigma^2 linf and theta 2#
  pars.inc <- c(pars, theta.2, BscVar(var.par.1, var.par.2, linf))#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars.inc)
# Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))
pis
pars
length(pars)
theta.const
if (theta.const == 1)#
  {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	var.par.1.fun <- pars[4]#
  	var.par.2.fun <- pars[5]#
  	mu.yr.fun     <- pars[6:length(pars)]#
  } else {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	theta.2.fun   <- pars[4]#
  	var.par.1.fun <- pars[5]#
  	var.par.2.fun <- pars[6]#
  	mu.yr.fun     <- pars[7:length(pars)]	#
  }
pars
if (theta.const.par == 1)#
  {#
  	theta.2.fun   <- (theta.1.fun * (sqrt(1 - cos(2 * pi * max.contr) ^ 2))) /#
                     cos(2 * pi * max.contr) #
  }
if (theta.const == 1)#
  {#
  	theta.2.fun   <- (theta.1.fun * (sqrt(1 - cos(2 * pi * max.contr) ^ 2))) /#
                     cos(2 * pi * max.contr) #
  }
theta.2.fun
theta.1.fun
max.contr
theta.const
for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh[, i] <<- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                      	         theta.2 = theta.2.fun, linf = linf.fun , mu.yr = mu.yr.fun,#
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }
mean.mnth.coh <- matrix(0, nrow = num.months, ncol = no.grps)
for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh[, i] <<- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                      	         theta.2 = theta.2.fun, linf = linf.fun , mu.yr = mu.yr.fun,#
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }
sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                      	         theta.2 = theta.2.fun, linf = linf.fun , mu.yr = mu.yr.fun,#
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)
i
i=2
sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                      	         theta.2 = theta.2.fun, linf = linf.fun , mu.yr = mu.yr.fun,#
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)
i = 3
sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                      	         theta.2 = theta.2.fun, linf = linf.fun , mu.yr = mu.yr.fun,#
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)
sapply(mean.mnth.coh[, i], BscVar, var.par.1 = var.par.1.fun,#
                                var.par.2 = var.par.2.fun)
mean.mnth.coh
mean.mnth.coh.fun  <- matrix(0, nrow = num.months, ncol = no.grps)#
   var.mnth.coh.fun  <- matrix(0, nrow = num.months, ncol = no.grps)#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.fun[, i] <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                      	         theta.2 = theta.2.fun, linf = linf.fun , mu.yr = mu.yr.fun,#
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  #print(mean.mnth.coh)#
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.fun[, i] <- sapply(mean.mnth.coh.fun[, i], BscVar, var.par.1 = var.par.1.fun,#
                                var.par.2 = var.par.2.fun)#
  }
var.mnth.coh.fun
# Function to calculate log likelihood#
# ------------------------------------#
LogLikelihood <- function(mm, mean.mnth.coh, var.mnth.coh) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  mm: Index for which month we are up to. Not the month itself#
  ##
  # Returns:#
  #  The log likelihood for each month#
  #  mm = 1#
  lengths.sub    <- lengths[which(months == months.lst[mm])]#
  like <- 0.0#
  #print(mean.mnth.coh)#
  for (i in seq(1, no.grps))#
  {#
  	#i = 1#
    like.grp <- pis[mm, i] * dnorm(lengths.sub, mean.mnth.coh[mm, i], sqrt(var.mnth.coh[mm, i]))#
    like     <- like + like.grp#
  }#
  log.like <- sum(log(like))#
  return(log.like)#
#
}
log.like.full <- sum(sapply(num.months.seq, LogLikelihood, mean.mnth.coh = mean.mnth.coh.fun,#
                       var.mnth.coh = var.mnth.coh.fun))
log.like.full
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1#
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
# MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             # mu.init.par, var.init.par, theta.const.par, #
                             # thetas.par, yrs.old.par, str.mnth.par)#
# {	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.init <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh  <- matrix(0, nrow = num.months, ncol = no.grps)#
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf
# Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
  }#
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))	#
  pars            <- optim.means.var$par#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  if (theta.const == 1)#
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	var.par.1  <- pars[4]#
  	var.par.2  <- pars[5]#
  	mu.yr      <- pars[6:length(pars)]#
  } else #
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	theta.2    <- pars[4]#
  	var.par.1  <- pars[5]#
  	var.par.2  <- pars[6]#
  	mu.yr      <- pars[7:length(pars)]#
  }#
  # If male or female we keep thetas fixed so turn off thetas#
  # above and turn those on below. Look in bsc_mean_var_func.R#
  # for more details#
  if (theta.const == 1)#
  {#
  	theta.2   <- (theta.1 * (sqrt(1 - cos(2 * pi * max.contr)^2))) /#
                 cos(2 * pi * max.contr) #
  }#
  # Calculate the means again for the final likelihood update#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh[, i], BscVar, var.par.1 = var.par.1,#
                                var.par.2 = var.par.2)#
  }#
  # Evaluate the likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood, mean.mnth.coh = mean.mnth.coh.mn,#
                       var.mnth.coh = var.mnth.coh.mn))#
  # Give a plot of the current state of the model versus the data#
  #BscPlotNew(c(theta.const, pars))#
#
  # Pars including sigma^2 linf and theta 2#
  pars.inc <- c(pars, theta.2, BscVar(var.par.1, var.par.2, linf))#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars.inc)
# Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
  }#
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))	#
  pars            <- optim.means.var$par#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  if (theta.const == 1)#
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	var.par.1  <- pars[4]#
  	var.par.2  <- pars[5]#
  	mu.yr      <- pars[6:length(pars)]#
  } else #
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	theta.2    <- pars[4]#
  	var.par.1  <- pars[5]#
  	var.par.2  <- pars[6]#
  	mu.yr      <- pars[7:length(pars)]#
  }#
  # If male or female we keep thetas fixed so turn off thetas#
  # above and turn those on below. Look in bsc_mean_var_func.R#
  # for more details#
  if (theta.const == 1)#
  {#
  	theta.2   <- (theta.1 * (sqrt(1 - cos(2 * pi * max.contr)^2))) /#
                 cos(2 * pi * max.contr) #
  }#
  # Calculate the means again for the final likelihood update#
  mean.mnth.coh.mn <- matrix(0, nrow = num.months, ncol = no.grps)#
   var.mnth.coh.mn <- matrix(0, nrow = num.months, ncol = no.grps)#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh[, i], BscVar, var.par.1 = var.par.1,#
                                var.par.2 = var.par.2)#
  }#
  # Evaluate the likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood, mean.mnth.coh = mean.mnth.coh.mn,#
                       var.mnth.coh = var.mnth.coh.mn))#
  # Give a plot of the current state of the model versus the data#
  #BscPlotNew(c(theta.const, pars))#
#
  # Pars including sigma^2 linf and theta 2#
  pars.inc <- c(pars, theta.2, BscVar(var.par.1, var.par.2, linf))#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars.inc)
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1#
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
# MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             # mu.init.par, var.init.par, theta.const.par, #
                             # thetas.par, yrs.old.par, str.mnth.par)#
# {	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.init <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh  <- matrix(0, nrow = num.months, ncol = no.grps)#
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf
# Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
  }#
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))	#
  pars            <- optim.means.var$par#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)
pars
theta.const
if (theta.const == 1)#
  {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	var.par.1.fun <- pars[4]#
  	var.par.2.fun <- pars[5]#
  	mu.yr.fun     <- pars[6:length(pars)]#
  } else {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	theta.2.fun   <- pars[4]#
  	var.par.1.fun <- pars[5]#
  	var.par.2.fun <- pars[6]#
  	mu.yr.fun     <- pars[7:length(pars)]	#
  }#
#
  # If male or female we keep the maximum fixed so turn off thetas#
  # above and turn those on below#
  if (theta.const == 1)#
  {#
  	theta.2.fun   <- (theta.1.fun * (sqrt(1 - cos(2 * pi * max.contr) ^ 2))) /#
                     cos(2 * pi * max.contr) #
  }
theta.2.fun
mean.mnth.coh.fun  <- matrix(0, nrow = num.months, ncol = no.grps)#
   var.mnth.coh.fun  <- matrix(0, nrow = num.months, ncol = no.grps)#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.fun[, i] <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                      	         theta.2 = theta.2.fun, linf = linf.fun , mu.yr = mu.yr.fun,#
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  #print(mean.mnth.coh)#
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.fun[, i] <- sapply(mean.mnth.coh.fun[, i], BscVar, var.par.1 = var.par.1.fun,#
                                var.par.2 = var.par.2.fun)#
  }
log.like.full <- sum(sapply(num.months.seq, LogLikelihood, mean.mnth.coh = mean.mnth.coh.fun,#
                       var.mnth.coh = var.mnth.coh.fun))
-log.like.full
log.like.full
lengths.sub    <- lengths[which(months == months.lst[mm])]
lengths.sub
lengths
mm = 1
lengths.sub    <- lengths[which(months == months.lst[mm])]
lengths.sub
like <- 0.0
mean.mnth.coh
var.mnth.coh
mean.mnth.coh.fun  <- matrix(0, nrow = num.months, ncol = no.grps)#
   var.mnth.coh.fun  <- matrix(0, nrow = num.months, ncol = no.grps)#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.fun[, i] <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                      	         theta.2 = theta.2.fun, linf = linf.fun , mu.yr = mu.yr.fun,#
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  #print(mean.mnth.coh)#
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.fun[, i] <- sapply(mean.mnth.coh.fun[, i], BscVar, var.par.1 = var.par.1.fun,#
                                var.par.2 = var.par.2.fun)#
  }
sum(sapply(num.months.seq, LogLikelihood, mean.mnth.coh = mean.mnth.coh.fun,#
                       var.mnth.coh = var.mnth.coh.fun))
LogLikelihood(1, mean.mnth.coh.fun, var.mnth.coh.fun)
mean.mnth.coh.fun
var.mnth.coh.fun
# Function to calculate log likelihood#
# ------------------------------------#
LogLikelihood.1 <- function(mm, mean.mnth.coh, var.mnth.coh) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  mm: Index for which month we are up to. Not the month itself#
  ##
  # Returns:#
  #  The log likelihood for each month#
    mm = 1#
  lengths.sub    <- lengths[which(months == months.lst[mm])]#
  like <- 0.0#
  #print(mean.mnth.coh)#
  for (i in seq(1, no.grps))#
  {#
  	#i = 1#
    like.grp <- pis[mm, i] * dnorm(lengths.sub, mean.mnth.coh.fun[mm, i], #
                sqrt(var.mnth.coh.fun[mm, i]))#
    like     <- like + like.grp#
  }#
  log.like <- sum(log(like))#
  return(log.like)#
#
}
mean.mnth.coh.fun  <- matrix(0, nrow = num.months, ncol = no.grps)#
   var.mnth.coh.fun  <- matrix(0, nrow = num.months, ncol = no.grps)#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.fun[, i] <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                      	         theta.2 = theta.2.fun, linf = linf.fun , mu.yr = mu.yr.fun,#
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  #print(mean.mnth.coh)#
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.fun[, i] <- sapply(mean.mnth.coh.fun[, i], BscVar, var.par.1 = var.par.1.fun,#
                                var.par.2 = var.par.2.fun)#
  }#
 # print(var.mnth.coh)                #
  # Calculate the log likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood.1))
log.like.full
var.mnth.coh.fun
mean.mnth.coh.fun
# Function to calculate log likelihood#
# ------------------------------------#
LogLikelihood1 <- function(mm) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  mm: Index for which month we are up to. Not the month itself#
  ##
  # Returns:#
  #  The log likelihood for each month#
  #mm = 1#
  lengths.sub    <- lengths[which(months == months.lst[mm])]#
  like <- 0.0#
  #print(mean.mnth.coh)#
  for (i in seq(1, no.grps))#
  {#
  	#i = 1#
    like.grp <- pis[mm, i] * dnorm(lengths.sub, mean.mnth.coh.fun[mm, i], #
                sqrt(var.mnth.coh.fun[mm, i]))#
    like     <- like + like.grp#
  }#
  log.like <- sum(log(like))#
  return(log.like)#
#
}
log.like.full <- sum(sapply(num.months.seq, LogLikelihood1))
log.like.full
mm = 1
lengths.sub    <- lengths[which(months == months.lst[mm])]
like <- 0.0
i = 1
like.grp <- pis[mm, i] * dnorm(lengths.sub, mean.mnth.coh.fun[mm, i], #
                sqrt(var.mnth.coh.fun[mm, i]))#
    like     <- like + like.grp
like.grp
mean.mnth.coh.fun
var.mnth.coh.fun
pis[mm, i] * dnorm(lengths.sub, mean.mnth.coh.fun[mm, i], #
                sqrt(var.mnth.coh.fun[mm, i]))
pis[mm, i]
pis
# Function to calculate log likelihood#
# ------------------------------------#
LogLikelihood1 <- function(mm) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  mm: Index for which month we are up to. Not the month itself#
  ##
  # Returns:#
  #  The log likelihood for each month#
  #mm = 1#
  lengths.sub    <- lengths[which(months == months.lst[mm])]#
  like <- 0.0#
  #print(mean.mnth.coh)#
  for (i in seq(1, no.grps))#
  {#
  	#i = 1#
    like.grp <- pis[mm, i] * dnorm(lengths.sub, mean.mnth.coh.fun[mm, i], #
                sqrt(var.mnth.coh.fun[mm, i]))#
    like     <- like + like.grp#
  }#
  log.like <- sum(log(like))#
  return(log.like)#
#
}#
#
LogLikelihood1 <- function(mm) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  mm: Index for which month we are up to. Not the month itself#
  ##
  # Returns:#
  #  The log likelihood for each month#
  #mm = 1#
  lengths.sub    <- lengths[which(months == months.lst[mm])]#
  like <- 0.0#
  #print(mean.mnth.coh)#
  for (i in seq(1, no.grps))#
  {#
  	#i = 1#
    like.grp <- pis[mm, i] * dnorm(lengths.sub, mean.mnth.coh.mn[mm, i], #
                sqrt(var.mnth.coh.mn[mm, i]))#
    like     <- like + like.grp#
  }#
  log.like <- sum(log(like))#
  return(log.like)#
#
}
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1#
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
# MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             # mu.init.par, var.init.par, theta.const.par, #
                             # thetas.par, yrs.old.par, str.mnth.par)#
# {	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.init <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh  <- matrix(0, nrow = num.months, ncol = no.grps)#
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1#
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
# MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             # mu.init.par, var.init.par, theta.const.par, #
                             # thetas.par, yrs.old.par, str.mnth.par)#
# {	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.init <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh.mn <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.mn  <- matrix(0, nrow = num.months, ncol = no.grps)#
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf
pars
# Declare each of the parameters to names unique to inside the fucntion#
  # print(theta.const)#
  if (theta.const == 1)#
  {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	var.par.1.fun <- pars[4]#
  	var.par.2.fun <- pars[5]#
  	mu.yr.fun     <- pars[6:length(pars)]#
  } else {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	theta.2.fun   <- pars[4]#
  	var.par.1.fun <- pars[5]#
  	var.par.2.fun <- pars[6]#
  	mu.yr.fun     <- pars[7:length(pars)]	#
  }#
#
  # If male or female we keep the maximum fixed so turn off thetas#
  # above and turn those on below#
  if (theta.const == 1)#
  {#
  	theta.2.fun   <- (theta.1.fun * (sqrt(1 - cos(2 * pi * max.contr) ^ 2))) /#
                     cos(2 * pi * max.contr) #
  }
mean.mnth.coh.fun  <- matrix(0, nrow = num.months, ncol = no.grps)#
   var.mnth.coh.fun  <- matrix(0, nrow = num.months, ncol = no.grps)#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.fun[, i] <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                      	         theta.2 = theta.2.fun, linf = linf.fun , mu.yr = mu.yr.fun,#
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  #print(mean.mnth.coh)#
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.fun[, i] <- sapply(mean.mnth.coh.fun[, i], BscVar, var.par.1 = var.par.1.fun,#
                                var.par.2 = var.par.2.fun)#
  }
# Function to calculate log likelihood#
# ------------------------------------#
LogLikelihood1 <- function(mm) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  mm: Index for which month we are up to. Not the month itself#
  ##
  # Returns:#
  #  The log likelihood for each month#
  #mm = 1#
  lengths.sub    <- lengths[which(months == months.lst[mm])]#
  like <- 0.0#
  #print(mean.mnth.coh)#
  for (i in seq(1, no.grps))#
  {#
  	#i = 1#
    like.grp <- pis[mm, i] * dnorm(lengths.sub, mean.mnth.coh.fun[mm, i], #
                sqrt(var.mnth.coh.fun[mm, i]))#
    like     <- like + like.grp#
  }#
  log.like <- sum(log(like))#
  return(log.like)#
#
}#
#
LogLikelihood2 <- function(mm) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  mm: Index for which month we are up to. Not the month itself#
  ##
  # Returns:#
  #  The log likelihood for each month#
  #mm = 1#
  lengths.sub    <- lengths[which(months == months.lst[mm])]#
  like <- 0.0#
  #print(mean.mnth.coh)#
  for (i in seq(1, no.grps))#
  {#
  	#i = 1#
    like.grp <- pis[mm, i] * dnorm(lengths.sub, mean.mnth.coh.mn[mm, i], #
                sqrt(var.mnth.coh.mn[mm, i]))#
    like     <- like + like.grp#
  }#
  log.like <- sum(log(like))#
  return(log.like)#
#
}
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1#
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
# MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             # mu.init.par, var.init.par, theta.const.par, #
                             # thetas.par, yrs.old.par, str.mnth.par)#
# {	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.init <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh.mn <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.mn  <- matrix(0, nrow = num.months, ncol = no.grps)#
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf
mean.mnth.coh.fun  <- matrix(0, nrow = num.months, ncol = no.grps)#
   var.mnth.coh.fun  <- matrix(0, nrow = num.months, ncol = no.grps)#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.fun[, i] <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                      	         theta.2 = theta.2.fun, linf = linf.fun , mu.yr = mu.yr.fun,#
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  #print(mean.mnth.coh)#
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.fun[, i] <- sapply(mean.mnth.coh.fun[, i], BscVar, var.par.1 = var.par.1.fun,#
                                var.par.2 = var.par.2.fun)#
  }
mean.mnth.coh.fun
if (theta.const == 1)#
  {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	var.par.1.fun <- pars[4]#
  	var.par.2.fun <- pars[5]#
  	mu.yr.fun     <- pars[6:length(pars)]#
  } else {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	theta.2.fun   <- pars[4]#
  	var.par.1.fun <- pars[5]#
  	var.par.2.fun <- pars[6]#
  	mu.yr.fun     <- pars[7:length(pars)]	#
  }
if (theta.const == 1)#
  {#
  	theta.2.fun   <- (theta.1.fun * (sqrt(1 - cos(2 * pi * max.contr) ^ 2))) /#
                     cos(2 * pi * max.contr) #
  }
mean.mnth.coh.fun  <- matrix(0, nrow = num.months, ncol = no.grps)#
   var.mnth.coh.fun  <- matrix(0, nrow = num.months, ncol = no.grps)#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.fun[, i] <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                      	         theta.2 = theta.2.fun, linf = linf.fun , mu.yr = mu.yr.fun,#
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }
mean.mnth.coh.fun
for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.fun[, i] <- sapply(mean.mnth.coh.fun[, i], BscVar, var.par.1 = var.par.1.fun,#
                                var.par.2 = var.par.2.fun)#
  }
var.mnth.coh.fun
# Function to optimise means using optim#
# --------------------------------------#
MeanVarOptim <- function(pars) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  pars: Vector containing the parameters to optimise#
  #    k0:        Mean  k paramter for VB model#
  #    thetas#
  #    	theta.1:   Seasonality parameter 1#
  #    	theta.2:   Seasonality parameter 1#
  #    linf:      Asymptotic length#
  #    mu.yr  :   vector containing all the strating months means#
  #    var.pars.x: The variance parameters#
  #    theta.const: boolean parametr that specifies if 1 that we should constrain#
  #                 the variance function#
  # Returns:#
  #  The negative of the log likelihood for use in the OPTIM function#
  # Declare each of the parameters to names unique to inside the fucntion#
  # print(theta.const)#
  if (theta.const == 1)#
  {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	var.par.1.fun <- pars[4]#
  	var.par.2.fun <- pars[5]#
  	mu.yr.fun     <- pars[6:length(pars)]#
  } else {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	theta.2.fun   <- pars[4]#
  	var.par.1.fun <- pars[5]#
  	var.par.2.fun <- pars[6]#
  	mu.yr.fun     <- pars[7:length(pars)]	#
  }#
#
  # If male or female we keep the maximum fixed so turn off thetas#
  # above and turn those on below#
  if (theta.const == 1)#
  {#
  	theta.2.fun   <- (theta.1.fun * (sqrt(1 - cos(2 * pi * max.contr) ^ 2))) /#
                     cos(2 * pi * max.contr) #
  }#
  # It seems bad but we need to define the bottom bits as global variables#
  # so that LogLikelihood can see them#
  # Calculate the means given the current update of the parameters#
  #print(mean.mnth.coh)#
  mean.mnth.coh.fun  <- matrix(0, nrow = num.months, ncol = no.grps)#
   var.mnth.coh.fun  <- matrix(0, nrow = num.months, ncol = no.grps)#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.fun[, i] <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                      	         theta.2 = theta.2.fun, linf = linf.fun , mu.yr = mu.yr.fun,#
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  #print(mean.mnth.coh)#
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.fun[, i] <- sapply(mean.mnth.coh.fun[, i], BscVar, var.par.1 = var.par.1.fun,#
                                var.par.2 = var.par.2.fun)#
  }#
 # print(var.mnth.coh)                #
  # Calculate the log likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood11))#
#
  # print(log.like.full)#
  # Return the negative of the log likelihood#
  return(-log.like.full)#
}
MeanVarOptim(pars)
# Function to optimise means using optim#
# --------------------------------------#
MeanVarOptim <- function(pars) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  pars: Vector containing the parameters to optimise#
  #    k0:        Mean  k paramter for VB model#
  #    thetas#
  #    	theta.1:   Seasonality parameter 1#
  #    	theta.2:   Seasonality parameter 1#
  #    linf:      Asymptotic length#
  #    mu.yr  :   vector containing all the strating months means#
  #    var.pars.x: The variance parameters#
  #    theta.const: boolean parametr that specifies if 1 that we should constrain#
  #                 the variance function#
  # Returns:#
  #  The negative of the log likelihood for use in the OPTIM function#
  # Declare each of the parameters to names unique to inside the fucntion#
  # print(theta.const)#
  if (theta.const == 1)#
  {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	var.par.1.fun <- pars[4]#
  	var.par.2.fun <- pars[5]#
  	mu.yr.fun     <- pars[6:length(pars)]#
  } else {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	theta.2.fun   <- pars[4]#
  	var.par.1.fun <- pars[5]#
  	var.par.2.fun <- pars[6]#
  	mu.yr.fun     <- pars[7:length(pars)]	#
  }#
#
  # If male or female we keep the maximum fixed so turn off thetas#
  # above and turn those on below#
  if (theta.const == 1)#
  {#
  	theta.2.fun   <- (theta.1.fun * (sqrt(1 - cos(2 * pi * max.contr) ^ 2))) /#
                     cos(2 * pi * max.contr) #
  }#
  # It seems bad but we need to define the bottom bits as global variables#
  # so that LogLikelihood can see them#
  # Calculate the means given the current update of the parameters#
  #print(mean.mnth.coh)#
  mean.mnth.coh.fun  <- matrix(0, nrow = num.months, ncol = no.grps)#
   var.mnth.coh.fun  <- matrix(0, nrow = num.months, ncol = no.grps)#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.fun[, i] <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                      	         theta.2 = theta.2.fun, linf = linf.fun , mu.yr = mu.yr.fun,#
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  #print(mean.mnth.coh)#
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.fun[, i] <- sapply(mean.mnth.coh.fun[, i], BscVar, var.par.1 = var.par.1.fun,#
                                var.par.2 = var.par.2.fun)#
  }#
 # print(var.mnth.coh)                #
  # Calculate the log likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood1))#
#
  # print(log.like.full)#
  # Return the negative of the log likelihood#
  return(-log.like.full)#
}
MeanVarOptim(pars)
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1#
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
# MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             # mu.init.par, var.init.par, theta.const.par, #
                             # thetas.par, yrs.old.par, str.mnth.par)#
# {	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.init <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh.mn <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.mn  <- matrix(0, nrow = num.months, ncol = no.grps)#
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf
LogLikelihood1(1)
# Function to optimise means using optim#
# --------------------------------------#
MeanVarOptim <- function(pars) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  pars: Vector containing the parameters to optimise#
  #    k0:        Mean  k paramter for VB model#
  #    thetas#
  #    	theta.1:   Seasonality parameter 1#
  #    	theta.2:   Seasonality parameter 1#
  #    linf:      Asymptotic length#
  #    mu.yr  :   vector containing all the strating months means#
  #    var.pars.x: The variance parameters#
  #    theta.const: boolean parametr that specifies if 1 that we should constrain#
  #                 the variance function#
  # Returns:#
  #  The negative of the log likelihood for use in the OPTIM function#
  # Declare each of the parameters to names unique to inside the fucntion#
  # print(theta.const)#
  if (theta.const == 1)#
  {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	var.par.1.fun <- pars[4]#
  	var.par.2.fun <- pars[5]#
  	mu.yr.fun     <- pars[6:length(pars)]#
  } else {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	theta.2.fun   <- pars[4]#
  	var.par.1.fun <- pars[5]#
  	var.par.2.fun <- pars[6]#
  	mu.yr.fun     <- pars[7:length(pars)]	#
  }#
#
  # If male or female we keep the maximum fixed so turn off thetas#
  # above and turn those on below#
  if (theta.const == 1)#
  {#
  	theta.2.fun   <- (theta.1.fun * (sqrt(1 - cos(2 * pi * max.contr) ^ 2))) /#
                     cos(2 * pi * max.contr) #
  }#
  # It seems bad but we need to define the bottom bits as global variables#
  # so that LogLikelihood can see them#
  # Calculate the means given the current update of the parameters#
  #print(mean.mnth.coh)#
  mean.mnth.coh.fun  <- matrix(0, nrow = num.months, ncol = no.grps)#
   var.mnth.coh.fun  <- matrix(0, nrow = num.months, ncol = no.grps)#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.fun[, i] <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                      	         theta.2 = theta.2.fun, linf = linf.fun , mu.yr = mu.yr.fun,#
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  #print(mean.mnth.coh)#
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.fun[, i] <- sapply(mean.mnth.coh.fun[, i], BscVar, var.par.1 = var.par.1.fun,#
                                var.par.2 = var.par.2.fun)#
  }#
  print(var.mnth.coh)                #
  # Calculate the log likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood1))#
#
  # print(log.like.full)#
  # Return the negative of the log likelihood#
  return(-log.like.full)#
}
# Function to calculate log likelihood#
# ------------------------------------#
LogLikelihood1 <- function(mm) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  mm: Index for which month we are up to. Not the month itself#
  ##
  # Returns:#
  #  The log likelihood for each month#
  #mm = 1#
  lengths.sub    <- lengths[which(months == months.lst[mm])]#
  like <- 0.0#
  #print(mean.mnth.coh)#
  for (i in seq(1, no.grps))#
  {#
  	#i = 1#
    like.grp <- pis[mm, i] * dnorm(lengths.sub, mean.mnth.coh.fun[mm, i], #
                sqrt(var.mnth.coh.fun[mm, i]))#
    like     <- like + like.grp#
  }#
  log.like <- sum(log(like))#
  return(log.like)#
#
}#
#
LogLikelihood2 <- function(mm) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  mm: Index for which month we are up to. Not the month itself#
  ##
  # Returns:#
  #  The log likelihood for each month#
  #mm = 1#
  lengths.sub    <- lengths[which(months == months.lst[mm])]#
  like <- 0.0#
  #print(mean.mnth.coh)#
  for (i in seq(1, no.grps))#
  {#
  	#i = 1#
    like.grp <- pis[mm, i] * dnorm(lengths.sub, mean.mnth.coh.mn[mm, i], #
                sqrt(var.mnth.coh.mn[mm, i]))#
    like     <- like + like.grp#
  }#
  log.like <- sum(log(like))#
  return(log.like)#
#
}
MeanVarOptim(pars)
# Function to optimise means using optim#
# --------------------------------------#
MeanVarOptim <- function(pars) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  pars: Vector containing the parameters to optimise#
  #    k0:        Mean  k paramter for VB model#
  #    thetas#
  #    	theta.1:   Seasonality parameter 1#
  #    	theta.2:   Seasonality parameter 1#
  #    linf:      Asymptotic length#
  #    mu.yr  :   vector containing all the strating months means#
  #    var.pars.x: The variance parameters#
  #    theta.const: boolean parametr that specifies if 1 that we should constrain#
  #                 the variance function#
  # Returns:#
  #  The negative of the log likelihood for use in the OPTIM function#
  # Declare each of the parameters to names unique to inside the fucntion#
  # print(theta.const)#
  if (theta.const == 1)#
  {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	var.par.1.fun <- pars[4]#
  	var.par.2.fun <- pars[5]#
  	mu.yr.fun     <- pars[6:length(pars)]#
  } else {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	theta.2.fun   <- pars[4]#
  	var.par.1.fun <- pars[5]#
  	var.par.2.fun <- pars[6]#
  	mu.yr.fun     <- pars[7:length(pars)]	#
  }#
#
  # If male or female we keep the maximum fixed so turn off thetas#
  # above and turn those on below#
  if (theta.const == 1)#
  {#
  	theta.2.fun   <- (theta.1.fun * (sqrt(1 - cos(2 * pi * max.contr) ^ 2))) /#
                     cos(2 * pi * max.contr) #
  }#
  # It seems bad but we need to define the bottom bits as global variables#
  # so that LogLikelihood can see them#
  # Calculate the means given the current update of the parameters#
  #print(mean.mnth.coh)#
  mean.mnth.coh.fun  <- matrix(0, nrow = num.months, ncol = no.grps)#
   var.mnth.coh.fun  <- matrix(0, nrow = num.months, ncol = no.grps)#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.fun[, i] <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                      	         theta.2 = theta.2.fun, linf = linf.fun , mu.yr = mu.yr.fun,#
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  #print(mean.mnth.coh)#
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.fun[, i] <- sapply(mean.mnth.coh.fun[, i], BscVar, var.par.1 = var.par.1.fun,#
                                var.par.2 = var.par.2.fun)#
  }#
  print(var.mnth.coh.fun)                #
  # Calculate the log likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood1))#
#
  # print(log.like.full)#
  # Return the negative of the log likelihood#
  return(-log.like.full)#
}
# Function to optimise means using optim#
# --------------------------------------#
MeanVarOptim <- function(pars) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  pars: Vector containing the parameters to optimise#
  #    k0:        Mean  k paramter for VB model#
  #    thetas#
  #    	theta.1:   Seasonality parameter 1#
  #    	theta.2:   Seasonality parameter 1#
  #    linf:      Asymptotic length#
  #    mu.yr  :   vector containing all the strating months means#
  #    var.pars.x: The variance parameters#
  #    theta.const: boolean parametr that specifies if 1 that we should constrain#
  #                 the variance function#
  # Returns:#
  #  The negative of the log likelihood for use in the OPTIM function#
  # Declare each of the parameters to names unique to inside the fucntion#
  # print(theta.const)#
  if (theta.const == 1)#
  {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	var.par.1.fun <- pars[4]#
  	var.par.2.fun <- pars[5]#
  	mu.yr.fun     <- pars[6:length(pars)]#
  } else {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	theta.2.fun   <- pars[4]#
  	var.par.1.fun <- pars[5]#
  	var.par.2.fun <- pars[6]#
  	mu.yr.fun     <- pars[7:length(pars)]	#
  }#
#
  # If male or female we keep the maximum fixed so turn off thetas#
  # above and turn those on below#
  if (theta.const == 1)#
  {#
  	theta.2.fun   <- (theta.1.fun * (sqrt(1 - cos(2 * pi * max.contr) ^ 2))) /#
                     cos(2 * pi * max.contr) #
  }#
  # It seems bad but we need to define the bottom bits as global variables#
  # so that LogLikelihood can see them#
  # Calculate the means given the current update of the parameters#
  #print(mean.mnth.coh)#
  mean.mnth.coh.fun  <- matrix(0, nrow = num.months, ncol = no.grps)#
   var.mnth.coh.fun  <- matrix(0, nrow = num.months, ncol = no.grps)#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.fun[, i] <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                      	         theta.2 = theta.2.fun, linf = linf.fun , mu.yr = mu.yr.fun,#
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  #print(mean.mnth.coh)#
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.fun[, i] <- sapply(mean.mnth.coh.fun[, i], BscVar, var.par.1 = var.par.1.fun,#
                                var.par.2 = var.par.2.fun)#
  }#
  print(var.mnth.coh.fun)                #
  # Calculate the log likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood1))#
#
  # print(log.like.full)#
  # Return the negative of the log likelihood#
  return(-log.like.full)#
}
MeanVarOptim(pars)
print(mean.mnth.coh.fun)
# Function to calculate log likelihood#
# ------------------------------------#
LogLikelihood1 <- function(mm) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  mm: Index for which month we are up to. Not the month itself#
  ##
  # Returns:#
  #  The log likelihood for each month#
  #mm = 1#
  print(mean.mnth.coh.fun)#
  lengths.sub    <- lengths[which(months == months.lst[mm])]#
  like <- 0.0#
  #print(mean.mnth.coh)#
  for (i in seq(1, no.grps))#
  {#
  	#i = 1#
    like.grp <- pis[mm, i] * dnorm(lengths.sub, mean.mnth.coh.fun[mm, i], #
                sqrt(var.mnth.coh.fun[mm, i]))#
    like     <- like + like.grp#
  }#
  log.like <- sum(log(like))#
  return(log.like)#
#
}#
#
LogLikelihood2 <- function(mm) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  mm: Index for which month we are up to. Not the month itself#
  ##
  # Returns:#
  #  The log likelihood for each month#
  #mm = 1#
  lengths.sub    <- lengths[which(months == months.lst[mm])]#
  like <- 0.0#
  #print(mean.mnth.coh)#
  for (i in seq(1, no.grps))#
  {#
  	#i = 1#
    like.grp <- pis[mm, i] * dnorm(lengths.sub, mean.mnth.coh.mn[mm, i], #
                sqrt(var.mnth.coh.mn[mm, i]))#
    like     <- like + like.grp#
  }#
  log.like <- sum(log(like))#
  return(log.like)#
#
}
MeanVarOptim(pars)
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1#
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
# MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             # mu.init.par, var.init.par, theta.const.par, #
                             # thetas.par, yrs.old.par, str.mnth.par)#
# {	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.init <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh.mn <<- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.mn  <<- matrix(0, nrow = num.months, ncol = no.grps)#
mean.mnth.coh.fun <<- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.fun  <<- matrix(0, nrow = num.months, ncol = no.grps)#
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
}#
pars#
MeanVarOptim(pars)
# Function to calculate log likelihood#
# ------------------------------------#
LogLikelihood1 <- function(mm) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  mm: Index for which month we are up to. Not the month itself#
  ##
  # Returns:#
  #  The log likelihood for each month#
  #mm = 1#
  print(mean.mnth.coh.fun)#
  lengths.sub    <- lengths[which(months == months.lst[mm])]#
  like <- 0.0#
  #print(mean.mnth.coh)#
  for (i in seq(1, no.grps))#
  {#
  	#i = 1#
    like.grp <- pis[mm, i] * dnorm(lengths.sub, mean.mnth.coh.fun[mm, i], #
                sqrt(var.mnth.coh.fun[mm, i]))#
    like     <- like + like.grp#
  }#
  log.like <- sum(log(like))#
  return(log.like)#
#
}#
#
LogLikelihood2 <- function(mm) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  mm: Index for which month we are up to. Not the month itself#
  ##
  # Returns:#
  #  The log likelihood for each month#
  #mm = 1#
  lengths.sub    <- lengths[which(months == months.lst[mm])]#
  like <- 0.0#
  #print(mean.mnth.coh)#
  for (i in seq(1, no.grps))#
  {#
  	#i = 1#
    like.grp <- pis[mm, i] * dnorm(lengths.sub, mean.mnth.coh.mn[mm, i], #
                sqrt(var.mnth.coh.mn[mm, i]))#
    like     <- like + like.grp#
  }#
  log.like <- sum(log(like))#
  return(log.like)#
#
}
# Function to optimise means using optim#
# --------------------------------------#
MeanVarOptim <- function(pars) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  pars: Vector containing the parameters to optimise#
  #    k0:        Mean  k paramter for VB model#
  #    thetas#
  #    	theta.1:   Seasonality parameter 1#
  #    	theta.2:   Seasonality parameter 1#
  #    linf:      Asymptotic length#
  #    mu.yr  :   vector containing all the strating months means#
  #    var.pars.x: The variance parameters#
  #    theta.const: boolean parametr that specifies if 1 that we should constrain#
  #                 the variance function#
  # Returns:#
  #  The negative of the log likelihood for use in the OPTIM function#
  # Declare each of the parameters to names unique to inside the fucntion#
  # print(theta.const)#
  if (theta.const == 1)#
  {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	var.par.1.fun <- pars[4]#
  	var.par.2.fun <- pars[5]#
  	mu.yr.fun     <- pars[6:length(pars)]#
  } else {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	theta.2.fun   <- pars[4]#
  	var.par.1.fun <- pars[5]#
  	var.par.2.fun <- pars[6]#
  	mu.yr.fun     <- pars[7:length(pars)]	#
  }#
#
  # If male or female we keep the maximum fixed so turn off thetas#
  # above and turn those on below#
  if (theta.const == 1)#
  {#
  	theta.2.fun   <- (theta.1.fun * (sqrt(1 - cos(2 * pi * max.contr) ^ 2))) /#
                     cos(2 * pi * max.contr) #
  }#
  # It seems bad but we need to define the bottom bits as global variables#
  # so that LogLikelihood can see them#
  # Calculate the means given the current update of the parameters#
  #print(mean.mnth.coh)#
  mean.mnth.coh.fun  <<- matrix(0, nrow = num.months, ncol = no.grps)#
   var.mnth.coh.fun  <<- matrix(0, nrow = num.months, ncol = no.grps)#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.fun[, i] <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                      	         theta.2 = theta.2.fun, linf = linf.fun , mu.yr = mu.yr.fun,#
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  #print(mean.mnth.coh)#
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.fun[, i] <- sapply(mean.mnth.coh.fun[, i], BscVar, var.par.1 = var.par.1.fun,#
                                var.par.2 = var.par.2.fun)#
  }#
  print(var.mnth.coh.fun)                #
  # Calculate the log likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood1))#
#
  # print(log.like.full)#
  # Return the negative of the log likelihood#
  return(-log.like.full)#
}
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1#
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
# MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             # mu.init.par, var.init.par, theta.const.par, #
                             # thetas.par, yrs.old.par, str.mnth.par)#
# {	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.init <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh.mn <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.mn  <- matrix(0, nrow = num.months, ncol = no.grps)#
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf
# Function to optimise means using optim#
# --------------------------------------#
MeanVarOptim <- function(pars) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  pars: Vector containing the parameters to optimise#
  #    k0:        Mean  k paramter for VB model#
  #    thetas#
  #    	theta.1:   Seasonality parameter 1#
  #    	theta.2:   Seasonality parameter 1#
  #    linf:      Asymptotic length#
  #    mu.yr  :   vector containing all the strating months means#
  #    var.pars.x: The variance parameters#
  #    theta.const: boolean parametr that specifies if 1 that we should constrain#
  #                 the variance function#
  # Returns:#
  #  The negative of the log likelihood for use in the OPTIM function#
  # Declare each of the parameters to names unique to inside the fucntion#
  # print(theta.const)#
  if (theta.const == 1)#
  {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	var.par.1.fun <- pars[4]#
  	var.par.2.fun <- pars[5]#
  	mu.yr.fun     <- pars[6:length(pars)]#
  } else {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	theta.2.fun   <- pars[4]#
  	var.par.1.fun <- pars[5]#
  	var.par.2.fun <- pars[6]#
  	mu.yr.fun     <- pars[7:length(pars)]	#
  }#
#
  # If male or female we keep the maximum fixed so turn off thetas#
  # above and turn those on below#
  if (theta.const == 1)#
  {#
  	theta.2.fun   <- (theta.1.fun * (sqrt(1 - cos(2 * pi * max.contr) ^ 2))) /#
                     cos(2 * pi * max.contr) #
  }#
  # It seems bad but we need to define the bottom bits as global variables#
  # so that LogLikelihood can see them#
  # Calculate the means given the current update of the parameters#
  #print(mean.mnth.coh)#
  mean.mnth.coh.fun  <<- matrix(0, nrow = num.months, ncol = no.grps)#
   var.mnth.coh.fun  <<- matrix(0, nrow = num.months, ncol = no.grps)#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.fun[, i] <<- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                      	         theta.2 = theta.2.fun, linf = linf.fun , mu.yr = mu.yr.fun,#
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  #print(mean.mnth.coh)#
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.fun[, i] <<- sapply(mean.mnth.coh.fun[, i], BscVar, var.par.1 = var.par.1.fun,#
                                var.par.2 = var.par.2.fun)#
  }#
  print(var.mnth.coh.fun)                #
  # Calculate the log likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood1))#
#
  # print(log.like.full)#
  # Return the negative of the log likelihood#
  return(-log.like.full)#
}
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1#
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
# MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             # mu.init.par, var.init.par, theta.const.par, #
                             # thetas.par, yrs.old.par, str.mnth.par)#
# {	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.init <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh.mn <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.mn  <- matrix(0, nrow = num.months, ncol = no.grps)#
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1#
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
# MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             # mu.init.par, var.init.par, theta.const.par, #
                             # thetas.par, yrs.old.par, str.mnth.par)#
# {	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.init <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh.mn <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.mn  <- matrix(0, nrow = num.months, ncol = no.grps)#
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf
# Initialise and optimise#
  if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
  }#
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))	#
  pars            <- optim.means.var$par#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  if (theta.const == 1)#
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	var.par.1  <- pars[4]#
  	var.par.2  <- pars[5]#
  	mu.yr      <- pars[6:length(pars)]#
  } else #
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	theta.2    <- pars[4]#
  	var.par.1  <- pars[5]#
  	var.par.2  <- pars[6]#
  	mu.yr      <- pars[7:length(pars)]#
  }#
  # If male or female we keep thetas fixed so turn off thetas#
  # above and turn those on below. Look in bsc_mean_var_func.R#
  # for more details#
  if (theta.const == 1)#
  {#
  	theta.2   <- (theta.1 * (sqrt(1 - cos(2 * pi * max.contr)^2))) /#
                 cos(2 * pi * max.contr) #
  }#
  # Calculate the means again for the final likelihood update#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh[, i], BscVar, var.par.1 = var.par.1,#
                                var.par.2 = var.par.2)#
  }#
  # Evaluate the likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood2))#
  # Give a plot of the current state of the model versus the data#
  #BscPlotNew(c(theta.const, pars))#
#
  # Pars including sigma^2 linf and theta 2#
  pars.inc <- c(pars, theta.2, BscVar(var.par.1, var.par.2, linf))#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars.inc)
# Function to calculate log likelihood#
# ------------------------------------#
LogLikelihood1 <- function(mm) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  mm: Index for which month we are up to. Not the month itself#
  ##
  # Returns:#
  #  The log likelihood for each month#
  #mm = 1#
  #print(mean.mnth.coh.fun)#
  lengths.sub    <- lengths[which(months == months.lst[mm])]#
  like <- 0.0#
  #print(mean.mnth.coh)#
  for (i in seq(1, no.grps))#
  {#
  	#i = 1#
    like.grp <- pis[mm, i] * dnorm(lengths.sub, mean.mnth.coh.fun[mm, i], #
                sqrt(var.mnth.coh.fun[mm, i]))#
    like     <- like + like.grp#
  }#
  log.like <- sum(log(like))#
  return(log.like)#
#
}#
#
LogLikelihood2 <- function(mm) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  mm: Index for which month we are up to. Not the month itself#
  ##
  # Returns:#
  #  The log likelihood for each month#
  #mm = 1#
  lengths.sub    <- lengths[which(months == months.lst[mm])]#
  like <- 0.0#
  #print(mean.mnth.coh)#
  for (i in seq(1, no.grps))#
  {#
  	#i = 1#
    like.grp <- pis[mm, i] * dnorm(lengths.sub, mean.mnth.coh.mn[mm, i], #
                sqrt(var.mnth.coh.mn[mm, i]))#
    like     <- like + like.grp#
  }#
  log.like <- sum(log(like))#
  return(log.like)#
#
}
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1#
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
# MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             # mu.init.par, var.init.par, theta.const.par, #
                             # thetas.par, yrs.old.par, str.mnth.par)#
# {	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.init <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh.mn <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.mn  <- matrix(0, nrow = num.months, ncol = no.grps)#
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1#
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
# MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             # mu.init.par, var.init.par, theta.const.par, #
                             # thetas.par, yrs.old.par, str.mnth.par)#
# {	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.init <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh.mn <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.mn  <- matrix(0, nrow = num.months, ncol = no.grps)#
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf
# Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))
# Function to calculate pis for each month#
# ----------------------------------------#
PiCalc <- function(mm) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  mm: Index for which month we are up to. Not the month itself#
  ##
  # Returns:#
  #  A set of pis for each group for the month#
  # Subset the lengths#
  # mm = 1#
  lengths.sub    <- lengths[which(months == months.lst[mm])]#
  # Calculate the inclusion probablities #
  top <- matrix(0, nrow = length(lengths.sub), ncol = no.grps)#
  bot <- array(0,  length(lengths.sub))#
  for (i in seq(1, no.grps))#
  {#
    top[, i] <- pis[mm, i] * dnorm(lengths.sub, mean.mnth.coh.mn[mm, i], sqrt(var.mnth.coh.mn[mm, i]))	#
  }		#
  bot  <- rowSums(top)#
  # Calculate the tau scores for each group#
  taus <- matrix(0, nrow = length(lengths.sub), ncol = no.grps)#
  for (i in seq(1, no.grps))#
  {#
    taus[, i] <- top[, i] / bot	#
  }		#
  # Return the pis for each group	  	#
  pis.mm <- colSums(taus) / dim(taus)[1]#
  # Return set for that months#
  return(pis.mm)#
}
pis <- t(sapply(num.months.seq, PiCalc))
pis
mean.mnth.coh.mn
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1#
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
# MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             # mu.init.par, var.init.par, theta.const.par, #
                             # thetas.par, yrs.old.par, str.mnth.par)#
# {	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.init <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh.mn <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.mn  <- matrix(0, nrow = num.months, ncol = no.grps)#
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
}#
pars#
MeanVarOptim(pars)
log.like.old <- log.like.full
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1#
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
# MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             # mu.init.par, var.init.par, theta.const.par, #
                             # thetas.par, yrs.old.par, str.mnth.par)#
# {	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.init <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh.mn <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.mn  <- matrix(0, nrow = num.months, ncol = no.grps)#
for (i in seq(1, no.grps))#
{#
  mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
}                  #
# Calculate the variances given the current update of the parameters#
for (i in seq(1, no.grps))#
{           #
  var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh[, i], BscVar, var.par.1 = var.par.1,#
                                var.par.2 = var.par.2)#
}   #
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf
log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))
pis
mean.mnth.coh.mn
mm = 1#
  lengths.sub    <- lengths[which(months == months.lst[mm])]#
  # Calculate the inclusion probablities #
  top <- matrix(0, nrow = length(lengths.sub), ncol = no.grps)#
  bot <- array(0,  length(lengths.sub))#
  for (i in seq(1, no.grps))#
  {#
    top[, i] <- pis[mm, i] * dnorm(lengths.sub, mean.mnth.coh.mn[mm, i], sqrt(var.mnth.coh.mn[mm, i]))	#
  }		#
  bot  <- rowSums(top)#
  # Calculate the tau scores for each group#
  taus <- matrix(0, nrow = length(lengths.sub), ncol = no.grps)#
  for (i in seq(1, no.grps))#
  {#
    taus[, i] <- top[, i] / bot	#
  }		#
  # Return the pis for each group	  	#
  pis.mm <- colSums(taus) / dim(taus)[1]
pis.mm
taus
top
pis
lengths.sub
mean.mnth.coh.mn
var.mnth.coh.mn
mean.mnth.coh.mn <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.mn  <- matrix(0, nrow = num.months, ncol = no.grps)#
for (i in seq(1, no.grps))#
{#
  mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
}                  #
# Calculate the variances given the current update of the parameters#
for (i in seq(1, no.grps))#
{           #
  var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh[, i], BscVar, var.par.1 = var.init[1],#
                                var.par.2 = var.init[2])#
}
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1#
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
# MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             # mu.init.par, var.init.par, theta.const.par, #
                             # thetas.par, yrs.old.par, str.mnth.par)#
# {	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.init <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh.mn <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.mn  <- matrix(0, nrow = num.months, ncol = no.grps)#
for (i in seq(1, no.grps))#
{#
  mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
}                  #
# Calculate the variances given the current update of the parameters#
for (i in seq(1, no.grps))#
{           #
  var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.init[1],#
                                var.par.2 = var.init[2])#
}   #
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf
log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))
pis
# Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
  }#
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))	#
  pars            <- optim.means.var$par#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  if (theta.const == 1)#
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	var.par.1  <- pars[4]#
  	var.par.2  <- pars[5]#
  	mu.yr      <- pars[6:length(pars)]#
  } else #
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	theta.2    <- pars[4]#
  	var.par.1  <- pars[5]#
  	var.par.2  <- pars[6]#
  	mu.yr      <- pars[7:length(pars)]#
  }#
  # If male or female we keep thetas fixed so turn off thetas#
  # above and turn those on below. Look in bsc_mean_var_func.R#
  # for more details#
  if (theta.const == 1)#
  {#
  	theta.2   <- (theta.1 * (sqrt(1 - cos(2 * pi * max.contr)^2))) /#
                 cos(2 * pi * max.contr) #
  }#
  # Calculate the means again for the final likelihood update#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh[, i], BscVar, var.par.1 = var.par.1,#
                                var.par.2 = var.par.2)#
  }#
  # Evaluate the likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood2))
# Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par.1,#
                                var.par.2 = var.par.2)#
  }
log.like.full <- sum(sapply(num.months.seq, LogLikelihood2))
log.like.full
pars.inc <- c(pars, theta.2, BscVar(var.par.1, var.par.2, linf))
print(c(log.like.full, log.like.full - log.like.old))#
  print(pars.inc)
# Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
  }#
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))	#
  pars            <- optim.means.var$par#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  if (theta.const == 1)#
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	var.par.1  <- pars[4]#
  	var.par.2  <- pars[5]#
  	mu.yr      <- pars[6:length(pars)]#
  } else #
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	theta.2    <- pars[4]#
  	var.par.1  <- pars[5]#
  	var.par.2  <- pars[6]#
  	mu.yr      <- pars[7:length(pars)]#
  }#
  # If male or female we keep thetas fixed so turn off thetas#
  # above and turn those on below. Look in bsc_mean_var_func.R#
  # for more details#
  if (theta.const == 1)#
  {#
  	theta.2   <- (theta.1 * (sqrt(1 - cos(2 * pi * max.contr)^2))) /#
                 cos(2 * pi * max.contr) #
  }#
  # Calculate the means again for the final likelihood update#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par.1,#
                                var.par.2 = var.par.2)#
  }#
  # Evaluate the likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood2))#
  # Give a plot of the current state of the model versus the data#
  #BscPlotNew(c(theta.const, pars))#
#
  # Pars including sigma^2 linf and theta 2#
  pars.inc <- c(pars, theta.2, BscVar(var.par.1, var.par.2, linf))#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars.inc)
mean.mnth.coh.mn
pis
optim.means.var
# Function to optimise means using optim#
# --------------------------------------#
MeanVarOptim <- function(pars) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  pars: Vector containing the parameters to optimise#
  #    k0:        Mean  k paramter for VB model#
  #    thetas#
  #    	theta.1:   Seasonality parameter 1#
  #    	theta.2:   Seasonality parameter 1#
  #    linf:      Asymptotic length#
  #    mu.yr  :   vector containing all the strating months means#
  #    var.pars.x: The variance parameters#
  #    theta.const: boolean parametr that specifies if 1 that we should constrain#
  #                 the variance function#
  # Returns:#
  #  The negative of the log likelihood for use in the OPTIM function#
  # Declare each of the parameters to names unique to inside the fucntion#
  # print(theta.const)#
  if (theta.const == 1)#
  {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	var.par.1.fun <- pars[4]#
  	var.par.2.fun <- pars[5]#
  	mu.yr.fun     <- pars[6:length(pars)]#
  } else {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	theta.2.fun   <- pars[4]#
  	var.par.1.fun <- pars[5]#
  	var.par.2.fun <- pars[6]#
  	mu.yr.fun     <- pars[7:length(pars)]	#
  }#
#
  # If male or female we keep the maximum fixed so turn off thetas#
  # above and turn those on below#
  if (theta.const == 1)#
  {#
  	theta.2.fun   <- (theta.1.fun * (sqrt(1 - cos(2 * pi * max.contr) ^ 2))) /#
                     cos(2 * pi * max.contr) #
  }#
  # It seems bad but we need to define the bottom bits as global variables#
  # so that LogLikelihood can see them#
  # Calculate the means given the current update of the parameters#
  #print(mean.mnth.coh)#
  mean.mnth.coh.fun  <<- matrix(0, nrow = num.months, ncol = no.grps)#
   var.mnth.coh.fun  <<- matrix(0, nrow = num.months, ncol = no.grps)#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.fun[, i] <<- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                      	         theta.2 = theta.2.fun, linf = linf.fun , mu.yr = mu.yr.fun,#
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  #print(mean.mnth.coh)#
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.fun[, i] <<- sapply(mean.mnth.coh.fun[, i], BscVar, var.par.1 = var.par.1.fun,#
                                var.par.2 = var.par.2.fun)#
  }#
  #print(var.mnth.coh.fun)                #
  # Calculate the log likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood1))#
#
  print(log.like.full)#
  # Return the negative of the log likelihood#
  return(-log.like.full)#
}
# Function to optimise means using optim#
# --------------------------------------#
MeanVarOptim <- function(pars) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  pars: Vector containing the parameters to optimise#
  #    k0:        Mean  k paramter for VB model#
  #    thetas#
  #    	theta.1:   Seasonality parameter 1#
  #    	theta.2:   Seasonality parameter 1#
  #    linf:      Asymptotic length#
  #    mu.yr  :   vector containing all the strating months means#
  #    var.pars.x: The variance parameters#
  #    theta.const: boolean parametr that specifies if 1 that we should constrain#
  #                 the variance function#
  # Returns:#
  #  The negative of the log likelihood for use in the OPTIM function#
  # Declare each of the parameters to names unique to inside the fucntion#
  # print(theta.const)#
  if (theta.const == 1)#
  {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	var.par.1.fun <- pars[4]#
  	var.par.2.fun <- pars[5]#
  	mu.yr.fun     <- pars[6:length(pars)]#
  } else {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	theta.2.fun   <- pars[4]#
  	var.par.1.fun <- pars[5]#
  	var.par.2.fun <- pars[6]#
  	mu.yr.fun     <- pars[7:length(pars)]	#
  }#
#
  # If male or female we keep the maximum fixed so turn off thetas#
  # above and turn those on below#
  if (theta.const == 1)#
  {#
  	theta.2.fun   <- (theta.1.fun * (sqrt(1 - cos(2 * pi * max.contr) ^ 2))) /#
                     cos(2 * pi * max.contr) #
  }#
  # It seems bad but we need to define the bottom bits as global variables#
  # so that LogLikelihood can see them#
  # Calculate the means given the current update of the parameters#
  #print(mean.mnth.coh)#
  mean.mnth.coh.fun  <<- matrix(0, nrow = num.months, ncol = no.grps)#
   var.mnth.coh.fun  <<- matrix(0, nrow = num.months, ncol = no.grps)#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.fun[, i] <<- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                      	         theta.2 = theta.2.fun, linf = linf.fun , mu.yr = mu.yr.fun,#
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  print(mean.mnth.coh)#
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.fun[, i] <<- sapply(mean.mnth.coh.fun[, i], BscVar, var.par.1 = var.par.1.fun,#
                                var.par.2 = var.par.2.fun)#
  }#
  #print(var.mnth.coh.fun)                #
  # Calculate the log likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood1))#
#
  print(log.like.full)#
  # Return the negative of the log likelihood#
  return(-log.like.full)#
}
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1#
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
# MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             # mu.init.par, var.init.par, theta.const.par, #
                             # thetas.par, yrs.old.par, str.mnth.par)#
# {	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.init <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh.mn <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.mn  <- matrix(0, nrow = num.months, ncol = no.grps)#
for (i in seq(1, no.grps))#
{#
  mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
}                  #
# Calculate the variances given the current update of the parameters#
for (i in seq(1, no.grps))#
{           #
  var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.init[1],#
                                var.par.2 = var.init[2])#
}   #
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf
# Function to optimise means using optim#
# --------------------------------------#
MeanVarOptim <- function(pars) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  pars: Vector containing the parameters to optimise#
  #    k0:        Mean  k paramter for VB model#
  #    thetas#
  #    	theta.1:   Seasonality parameter 1#
  #    	theta.2:   Seasonality parameter 1#
  #    linf:      Asymptotic length#
  #    mu.yr  :   vector containing all the strating months means#
  #    var.pars.x: The variance parameters#
  #    theta.const: boolean parametr that specifies if 1 that we should constrain#
  #                 the variance function#
  # Returns:#
  #  The negative of the log likelihood for use in the OPTIM function#
  # Declare each of the parameters to names unique to inside the fucntion#
  # print(theta.const)#
  if (theta.const == 1)#
  {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	var.par.1.fun <- pars[4]#
  	var.par.2.fun <- pars[5]#
  	mu.yr.fun     <- pars[6:length(pars)]#
  } else {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	theta.2.fun   <- pars[4]#
  	var.par.1.fun <- pars[5]#
  	var.par.2.fun <- pars[6]#
  	mu.yr.fun     <- pars[7:length(pars)]	#
  }#
#
  # If male or female we keep the maximum fixed so turn off thetas#
  # above and turn those on below#
  if (theta.const == 1)#
  {#
  	theta.2.fun   <- (theta.1.fun * (sqrt(1 - cos(2 * pi * max.contr) ^ 2))) /#
                     cos(2 * pi * max.contr) #
  }#
  # It seems bad but we need to define the bottom bits as global variables#
  # so that LogLikelihood can see them#
  # Calculate the means given the current update of the parameters#
  #print(mean.mnth.coh)#
  mean.mnth.coh.fun  <<- matrix(0, nrow = num.months, ncol = no.grps)#
   var.mnth.coh.fun  <<- matrix(0, nrow = num.months, ncol = no.grps)#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.fun[, i] <<- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                      	         theta.2 = theta.2.fun, linf = linf.fun , mu.yr = mu.yr.fun,#
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  print(mean.mnth.coh.fun)#
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.fun[, i] <<- sapply(mean.mnth.coh.fun[, i], BscVar, var.par.1 = var.par.1.fun,#
                                var.par.2 = var.par.2.fun)#
  }#
  #print(var.mnth.coh.fun)                #
  # Calculate the log likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood1))#
#
  print(log.like.full)#
  # Return the negative of the log likelihood#
  return(-log.like.full)#
}
MeanVarOptim(pars)
# Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
  }#
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))	#
  pars            <- optim.means.var$par#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  if (theta.const == 1)#
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	var.par.1  <- pars[4]#
  	var.par.2  <- pars[5]#
  	mu.yr      <- pars[6:length(pars)]#
  } else #
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	theta.2    <- pars[4]#
  	var.par.1  <- pars[5]#
  	var.par.2  <- pars[6]#
  	mu.yr      <- pars[7:length(pars)]#
  }#
  # If male or female we keep thetas fixed so turn off thetas#
  # above and turn those on below. Look in bsc_mean_var_func.R#
  # for more details#
  if (theta.const == 1)#
  {#
  	theta.2   <- (theta.1 * (sqrt(1 - cos(2 * pi * max.contr)^2))) /#
                 cos(2 * pi * max.contr) #
  }#
  # Calculate the means again for the final likelihood update#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par.1,#
                                var.par.2 = var.par.2)#
  }#
  # Evaluate the likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood2))#
  # Give a plot of the current state of the model versus the data#
  #BscPlotNew(c(theta.const, pars))#
#
  # Pars including sigma^2 linf and theta 2#
  pars.inc <- c(pars, theta.2, BscVar(var.par.1, var.par.2, linf))#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars.inc)
var.mnth.coh.mn
log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))
pis
if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
  }
pars
optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))
mean.mnth.coh.fun
theta.2.fun
if (theta.const == 1)#
  {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	var.par.1.fun <- pars[4]#
  	var.par.2.fun <- pars[5]#
  	mu.yr.fun     <- pars[6:length(pars)]#
  } else {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	theta.2.fun   <- pars[4]#
  	var.par.1.fun <- pars[5]#
  	var.par.2.fun <- pars[6]#
  	mu.yr.fun     <- pars[7:length(pars)]	#
  }#
#
  # If male or female we keep the maximum fixed so turn off thetas#
  # above and turn those on below#
  if (theta.const == 1)#
  {#
  	theta.2.fun   <- (theta.1.fun * (sqrt(1 - cos(2 * pi * max.contr) ^ 2))) /#
                     cos(2 * pi * max.contr) #
  }
theta.2.fun
pars
mu.yr
var.init
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1#
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
# MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             # mu.init.par, var.init.par, theta.const.par, #
                             # thetas.par, yrs.old.par, str.mnth.par)#
# {	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.init <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh.mn <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.mn  <- matrix(0, nrow = num.months, ncol = no.grps)#
for (i in seq(1, no.grps))#
{#
  mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
}                  #
# Calculate the variances given the current update of the parameters#
for (i in seq(1, no.grps))#
{           #
  var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.init[1],#
                                var.par.2 = var.init[2])#
}   #
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf
# Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], c(var.par.1, var.par.2), mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, c(var.par.1, var.par.2), mu.yr)#
  }#
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))	#
  pars            <- optim.means.var$par#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  if (theta.const == 1)#
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	var.par.1  <- pars[4]#
  	var.par.2  <- pars[5]#
  	mu.yr      <- pars[6:length(pars)]#
  } else #
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	theta.2    <- pars[4]#
  	var.par.1  <- pars[5]#
  	var.par.2  <- pars[6]#
  	mu.yr      <- pars[7:length(pars)]#
  }#
  # If male or female we keep thetas fixed so turn off thetas#
  # above and turn those on below. Look in bsc_mean_var_func.R#
  # for more details#
  if (theta.const == 1)#
  {#
  	theta.2   <- (theta.1 * (sqrt(1 - cos(2 * pi * max.contr)^2))) /#
                 cos(2 * pi * max.contr) #
  }#
  # Calculate the means again for the final likelihood update#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par.1,#
                                var.par.2 = var.par.2)#
  }#
  # Evaluate the likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood2))#
  # Give a plot of the current state of the model versus the data#
  #BscPlotNew(c(theta.const, pars))#
#
  # Pars including sigma^2 linf and theta 2#
  pars.inc <- c(pars, theta.2, BscVar(var.par.1, var.par.2, linf))#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars.inc)
# Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], c(var.par.1, var.par.2), mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, c(var.par.1, var.par.2), mu.yr)#
  }#
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))	#
  pars            <- optim.means.var$par#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  if (theta.const == 1)#
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	var.par.1  <- pars[4]#
  	var.par.2  <- pars[5]#
  	mu.yr      <- pars[6:length(pars)]#
  } else #
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	theta.2    <- pars[4]#
  	var.par.1  <- pars[5]#
  	var.par.2  <- pars[6]#
  	mu.yr      <- pars[7:length(pars)]#
  }#
  # If male or female we keep thetas fixed so turn off thetas#
  # above and turn those on below. Look in bsc_mean_var_func.R#
  # for more details#
  if (theta.const == 1)#
  {#
  	theta.2   <- (theta.1 * (sqrt(1 - cos(2 * pi * max.contr)^2))) /#
                 cos(2 * pi * max.contr) #
  }#
  # Calculate the means again for the final likelihood update#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par.1,#
                                var.par.2 = var.par.2)#
  }#
  # Evaluate the likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood2))#
  # Give a plot of the current state of the model versus the data#
  #BscPlotNew(c(theta.const, pars))#
#
  # Pars including sigma^2 linf and theta 2#
  pars.inc <- c(pars, theta.2, BscVar(var.par.1, var.par.2, linf))#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars.inc)
# Function to optimise means using optim#
# --------------------------------------#
MeanVarOptim <- function(pars) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  pars: Vector containing the parameters to optimise#
  #    k0:        Mean  k paramter for VB model#
  #    thetas#
  #    	theta.1:   Seasonality parameter 1#
  #    	theta.2:   Seasonality parameter 1#
  #    linf:      Asymptotic length#
  #    mu.yr  :   vector containing all the strating months means#
  #    var.pars.x: The variance parameters#
  #    theta.const: boolean parametr that specifies if 1 that we should constrain#
  #                 the variance function#
  # Returns:#
  #  The negative of the log likelihood for use in the OPTIM function#
  # Declare each of the parameters to names unique to inside the fucntion#
  # print(theta.const)#
  if (theta.const == 1)#
  {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	var.par.1.fun <- pars[4]#
  	var.par.2.fun <- pars[5]#
  	mu.yr.fun     <- pars[6:length(pars)]#
  } else {#
  	k0.fun        <- pars[1]#
  	linf.fun      <- pars[2]#
  	theta.1.fun   <- pars[3]#
  	theta.2.fun   <- pars[4]#
  	var.par.1.fun <- pars[5]#
  	var.par.2.fun <- pars[6]#
  	mu.yr.fun     <- pars[7:length(pars)]	#
  }#
#
  # If male or female we keep the maximum fixed so turn off thetas#
  # above and turn those on below#
  if (theta.const == 1)#
  {#
  	theta.2.fun   <- (theta.1.fun * (sqrt(1 - cos(2 * pi * max.contr) ^ 2))) /#
                     cos(2 * pi * max.contr) #
  }#
  # It seems bad but we need to define the bottom bits as global variables#
  # so that LogLikelihood can see them#
  # Calculate the means given the current update of the parameters#
  #print(mean.mnth.coh)#
  mean.mnth.coh.fun  <<- matrix(0, nrow = num.months, ncol = no.grps)#
   var.mnth.coh.fun  <<- matrix(0, nrow = num.months, ncol = no.grps)#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.fun[, i] <<- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                      	         theta.2 = theta.2.fun, linf = linf.fun , mu.yr = mu.yr.fun,#
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  #print(mean.mnth.coh.fun)#
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.fun[, i] <<- sapply(mean.mnth.coh.fun[, i], BscVar, var.par.1 = var.par.1.fun,#
                                var.par.2 = var.par.2.fun)#
  }#
  #print(var.mnth.coh.fun)                #
  # Calculate the log likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood1))#
#
  print(log.like.full)#
  # Return the negative of the log likelihood#
  return(-log.like.full)#
}
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1#
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
# MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             # mu.init.par, var.init.par, theta.const.par, #
                             # thetas.par, yrs.old.par, str.mnth.par)#
# {	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.init <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh.mn <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.mn  <- matrix(0, nrow = num.months, ncol = no.grps)#
for (i in seq(1, no.grps))#
{#
  mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
}                  #
# Calculate the variances given the current update of the parameters#
for (i in seq(1, no.grps))#
{           #
  var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.init[1],#
                                var.par.2 = var.init[2])#
}   #
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf	#
# ------------------------------------------------------------------------------	#
# Run while loop over procedure until convergence#
# -----------------------------------------------	#
while (log.like.full - log.like.old > tol) {#
#
  # Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], c(var.par.1, var.par.2), mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, c(var.par.1, var.par.2), mu.yr)#
  }#
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))	#
  pars            <- optim.means.var$par#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  if (theta.const == 1)#
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	var.par.1  <- pars[4]#
  	var.par.2  <- pars[5]#
  	mu.yr      <- pars[6:length(pars)]#
  } else #
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	theta.2    <- pars[4]#
  	var.par.1  <- pars[5]#
  	var.par.2  <- pars[6]#
  	mu.yr      <- pars[7:length(pars)]#
  }#
  # If male or female we keep thetas fixed so turn off thetas#
  # above and turn those on below. Look in bsc_mean_var_func.R#
  # for more details#
  if (theta.const == 1)#
  {#
  	theta.2   <- (theta.1 * (sqrt(1 - cos(2 * pi * max.contr)^2))) /#
                 cos(2 * pi * max.contr) #
  }#
  # Calculate the means again for the final likelihood update#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par.1,#
                                var.par.2 = var.par.2)#
  }#
  # Evaluate the likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood2))#
  # Give a plot of the current state of the model versus the data#
  #BscPlotNew(c(theta.const, pars))#
#
  # Pars including sigma^2 linf and theta 2#
  pars.inc <- c(pars, theta.2, BscVar(var.par.1, var.par.2, linf))#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars.inc)#
}#
# }
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1#
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
# MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             # mu.init.par, var.init.par, theta.const.par, #
                             # thetas.par, yrs.old.par, str.mnth.par)#
# {	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.par <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh.mn <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.mn  <- matrix(0, nrow = num.months, ncol = no.grps)#
for (i in seq(1, no.grps))#
{#
  mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
}                  #
# Calculate the variances given the current update of the parameters#
for (i in seq(1, no.grps))#
{           #
  var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.init[1],#
                                var.par.2 = var.init[2])#
}   #
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.init, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.init, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf	#
# ------------------------------------------------------------------------------	#
# Run while loop over procedure until convergence#
# -----------------------------------------------	#
while (log.like.full - log.like.old > tol) {#
#
  # Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], var.par, mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, var.par, mu.yr)#
  }#
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))	#
  pars            <- optim.means.var$par#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  if (theta.const == 1)#
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	var.par.1  <- pars[4]#
  	var.par.2  <- pars[5]#
  	mu.yr      <- pars[6:length(pars)]#
  } else #
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	theta.2    <- pars[4]#
  	var.par.1  <- pars[5]#
  	var.par.2  <- pars[6]#
  	mu.yr      <- pars[7:length(pars)]#
  }#
  # If male or female we keep thetas fixed so turn off thetas#
  # above and turn those on below. Look in bsc_mean_var_func.R#
  # for more details#
  if (theta.const == 1)#
  {#
  	theta.2   <- (theta.1 * (sqrt(1 - cos(2 * pi * max.contr)^2))) /#
                 cos(2 * pi * max.contr) #
  }#
  # Calculate the means again for the final likelihood update#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par.1,#
                                var.par.2 = var.par.2)#
  }#
  # Evaluate the likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood2))#
  # Give a plot of the current state of the model versus the data#
  #BscPlotNew(c(theta.const, pars))#
#
  # Pars including sigma^2 linf and theta 2#
  pars.inc <- c(pars, theta.2, BscVar(var.par.1, var.par.2, linf))#
  var.par <- c(var.par.1, var.par.2)#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars.inc)#
}#
# }
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1#
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
# MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             # mu.init.par, var.init.par, theta.const.par, #
                             # thetas.par, yrs.old.par, str.mnth.par)#
# {	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.par <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh.mn <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.mn  <- matrix(0, nrow = num.months, ncol = no.grps)#
for (i in seq(1, no.grps))#
{#
  mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
}                  #
# Calculate the variances given the current update of the parameters#
for (i in seq(1, no.grps))#
{           #
  var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.init[1],#
                                var.par.2 = var.init[2])#
}   #
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.par, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.par, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf	#
# ------------------------------------------------------------------------------	#
# Run while loop over procedure until convergence#
# -----------------------------------------------	#
while (log.like.full - log.like.old > tol) {#
#
  # Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], var.par, mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, var.par, mu.yr)#
  }#
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))	#
  pars            <- optim.means.var$par#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  if (theta.const == 1)#
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	var.par.1  <- pars[4]#
  	var.par.2  <- pars[5]#
  	mu.yr      <- pars[6:length(pars)]#
  } else #
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	theta.2    <- pars[4]#
  	var.par.1  <- pars[5]#
  	var.par.2  <- pars[6]#
  	mu.yr      <- pars[7:length(pars)]#
  }#
  # If male or female we keep thetas fixed so turn off thetas#
  # above and turn those on below. Look in bsc_mean_var_func.R#
  # for more details#
  if (theta.const == 1)#
  {#
  	theta.2   <- (theta.1 * (sqrt(1 - cos(2 * pi * max.contr)^2))) /#
                 cos(2 * pi * max.contr) #
  }#
  # Calculate the means again for the final likelihood update#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par.1,#
                                var.par.2 = var.par.2)#
  }#
  # Evaluate the likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood2))#
  # Give a plot of the current state of the model versus the data#
  #BscPlotNew(c(theta.const, pars))#
#
  # Pars including sigma^2 linf and theta 2#
  pars.inc <- c(pars, theta.2, BscVar(var.par.1, var.par.2, linf))#
  var.par <- c(var.par.1, var.par.2)#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars.inc)#
}#
# }
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1#
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
# MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             # mu.init.par, var.init.par, theta.const.par, #
                             # thetas.par, yrs.old.par, str.mnth.par)#
# {	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.par <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh.mn <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.mn  <- matrix(0, nrow = num.months, ncol = no.grps)#
for (i in seq(1, no.grps))#
{#
  mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
}                  #
# Calculate the variances given the current update of the parameters#
for (i in seq(1, no.grps))#
{           #
  var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.init[1],#
                                var.par.2 = var.init[2])#
}   #
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.par, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.par, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1#
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
# MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             # mu.init.par, var.init.par, theta.const.par, #
                             # thetas.par, yrs.old.par, str.mnth.par)#
# {	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.par <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh.mn <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.mn  <- matrix(0, nrow = num.months, ncol = no.grps)#
for (i in seq(1, no.grps))#
{#
  mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
}                  #
# Calculate the variances given the current update of the parameters#
for (i in seq(1, no.grps))#
{           #
  var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par[1],#
                                var.par.2 = var.par[2])#
}   #
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.par, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.par, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf	#
# ------------------------------------------------------------------------------	#
# Run while loop over procedure until convergence#
# -----------------------------------------------	#
while (log.like.full - log.like.old > tol) {#
#
  # Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], var.par, mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, var.par, mu.yr)#
  }#
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))	#
  pars            <- optim.means.var$par#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  if (theta.const == 1)#
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	var.par.1  <- pars[4]#
  	var.par.2  <- pars[5]#
  	mu.yr      <- pars[6:length(pars)]#
  } else #
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	theta.2    <- pars[4]#
  	var.par.1  <- pars[5]#
  	var.par.2  <- pars[6]#
  	mu.yr      <- pars[7:length(pars)]#
  }#
  # If male or female we keep thetas fixed so turn off thetas#
  # above and turn those on below. Look in bsc_mean_var_func.R#
  # for more details#
  if (theta.const == 1)#
  {#
  	theta.2   <- (theta.1 * (sqrt(1 - cos(2 * pi * max.contr)^2))) /#
                 cos(2 * pi * max.contr) #
  }#
  # Calculate the means again for the final likelihood update#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par.1,#
                                var.par.2 = var.par.2)#
  }#
  # Evaluate the likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood2))#
  # Give a plot of the current state of the model versus the data#
  #BscPlotNew(c(theta.const, pars))#
#
  # Pars including sigma^2 linf and theta 2#
  pars.inc <- c(pars, theta.2, BscVar(var.par.1, var.par.2, linf))#
  var.par <- c(var.par.1, var.par.2)#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars.inc)#
}#
# }
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1#
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
# MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             # mu.init.par, var.init.par, theta.const.par, #
                             # thetas.par, yrs.old.par, str.mnth.par)#
# {	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.par <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh.mn <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.mn  <- matrix(0, nrow = num.months, ncol = no.grps)#
for (i in seq(1, no.grps))#
{#
  mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
}                  #
# Calculate the variances given the current update of the parameters#
for (i in seq(1, no.grps))#
{           #
  var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par[1],#
                                var.par.2 = var.par[2])#
}   #
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.par, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.par, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf	#
# ------------------------------------------------------------------------------	#
# Run while loop over procedure until convergence#
# -----------------------------------------------	#
while (log.like.full - log.like.old > tol) {#
#
  # Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], var.par, mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, var.par, mu.yr)#
  }#
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))	#
  pars            <- optim.means.var$par#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  if (theta.const == 1)#
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	var.par.1  <- pars[4]#
  	var.par.2  <- pars[5]#
  	mu.yr      <- pars[6:length(pars)]#
  } else #
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	theta.2    <- pars[4]#
  	var.par.1  <- pars[5]#
  	var.par.2  <- pars[6]#
  	mu.yr      <- pars[7:length(pars)]#
  }#
  # If male or female we keep thetas fixed so turn off thetas#
  # above and turn those on below. Look in bsc_mean_var_func.R#
  # for more details#
  if (theta.const == 1)#
  {#
  	theta.2   <- (theta.1 * (sqrt(1 - cos(2 * pi * max.contr)^2))) /#
                 cos(2 * pi * max.contr) #
  }#
  # Calculate the means again for the final likelihood update#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par.1,#
                                var.par.2 = var.par.2)#
  }#
  # Evaluate the likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood2))#
  # Give a plot of the current state of the model versus the data#
  #BscPlotNew(c(theta.const, pars))#
#
  # Pars including sigma^2 linf and theta 2#
  pars.inc <- c(pars, theta.2, BscVar(var.par.1, var.par.2, linf))#
  var.par <- c(var.par.1, var.par.2)#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars.inc)#
}#
# }
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1#
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
# MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             # mu.init.par, var.init.par, theta.const.par, #
                             # thetas.par, yrs.old.par, str.mnth.par)#
# {	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.par <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh.mn <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.mn  <- matrix(0, nrow = num.months, ncol = no.grps)#
for (i in seq(1, no.grps))#
{#
  mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
}                  #
# Calculate the variances given the current update of the parameters#
for (i in seq(1, no.grps))#
{           #
  var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par[1],#
                                var.par.2 = var.par[2])#
}   #
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.par, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.par, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf
# Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], var.par, mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, var.par, mu.yr)#
  }#
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))	#
  pars            <- optim.means.var$par#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  if (theta.const == 1)#
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	var.par.1  <- pars[4]#
  	var.par.2  <- pars[5]#
  	mu.yr      <- pars[6:length(pars)]#
  } else #
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	theta.2    <- pars[4]#
  	var.par.1  <- pars[5]#
  	var.par.2  <- pars[6]#
  	mu.yr      <- pars[7:length(pars)]#
  }#
  # If male or female we keep thetas fixed so turn off thetas#
  # above and turn those on below. Look in bsc_mean_var_func.R#
  # for more details#
  if (theta.const == 1)#
  {#
  	theta.2   <- (theta.1 * (sqrt(1 - cos(2 * pi * max.contr)^2))) /#
                 cos(2 * pi * max.contr) #
  }#
  # Calculate the means again for the final likelihood update#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par.1,#
                                var.par.2 = var.par.2)#
  }#
  # Evaluate the likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood2))#
  # Give a plot of the current state of the model versus the data#
  #BscPlotNew(c(theta.const, pars))#
#
  # Pars including sigma^2 linf and theta 2#
  pars.inc <- c(pars, theta.2, BscVar(var.par.1, var.par.2, linf))#
  var.par <- c(var.par.1, var.par.2)#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars.inc)
log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], var.par, mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, var.par, mu.yr)#
  }
pars
theta.1
var.par  <- c(var.par.1, var.par.2)#
  thetas   <- c(theta.1, theta.2)
if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], var.par, mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, var.par, mu.yr)#
  }
pars
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1#
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
# MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             # mu.init.par, var.init.par, theta.const.par, #
                             # thetas.par, yrs.old.par, str.mnth.par)#
# {	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.par <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh.mn <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.mn  <- matrix(0, nrow = num.months, ncol = no.grps)#
for (i in seq(1, no.grps))#
{#
  mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
}                  #
# Calculate the variances given the current update of the parameters#
for (i in seq(1, no.grps))#
{           #
  var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par[1],#
                                var.par.2 = var.par[2])#
}   #
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.par, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.par, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf	#
# ------------------------------------------------------------------------------	#
# Run while loop over procedure until convergence#
# -----------------------------------------------	#
while (log.like.full - log.like.old > tol) {#
#
  # Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], var.par, mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, var.par, mu.yr)#
  }#
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))	#
  pars            <- optim.means.var$par#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  if (theta.const == 1)#
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	var.par.1  <- pars[4]#
  	var.par.2  <- pars[5]#
  	mu.yr      <- pars[6:length(pars)]#
  } else #
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	theta.2    <- pars[4]#
  	var.par.1  <- pars[5]#
  	var.par.2  <- pars[6]#
  	mu.yr      <- pars[7:length(pars)]#
  }#
  # If male or female we keep thetas fixed so turn off thetas#
  # above and turn those on below. Look in bsc_mean_var_func.R#
  # for more details#
  if (theta.const == 1)#
  {#
  	theta.2   <- (theta.1 * (sqrt(1 - cos(2 * pi * max.contr)^2))) /#
                 cos(2 * pi * max.contr) #
  }#
  # Calculate the means again for the final likelihood update#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par.1,#
                                var.par.2 = var.par.2)#
  }#
  # Evaluate the likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood2))#
  # Give a plot of the current state of the model versus the data#
  #BscPlotNew(c(theta.const, pars))#
#
  # Pars including sigma^2 linf and theta 2#
  pars.inc <- c(pars, theta.2, BscVar(var.par.1, var.par.2, linf))#
  var.par  <- c(var.par.1, var.par.2)#
  thetas   <- c(theta.1, theta.2)#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars.inc)#
}#
# }
MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             mu.init.par, var.init.par, theta.const.par, #
                             thetas.par, yrs.old.par, str.mnth.par)#
{	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.par <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh.mn <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.mn  <- matrix(0, nrow = num.months, ncol = no.grps)#
for (i in seq(1, no.grps))#
{#
  mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
}                  #
# Calculate the variances given the current update of the parameters#
for (i in seq(1, no.grps))#
{           #
  var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par[1],#
                                var.par.2 = var.par[2])#
}   #
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.par, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.par, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf	#
# ------------------------------------------------------------------------------	#
# Run while loop over procedure until convergence#
# -----------------------------------------------	#
while (log.like.full - log.like.old > tol) {#
#
  # Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], var.par, mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, var.par, mu.yr)#
  }#
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))	#
  pars            <- optim.means.var$par#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  if (theta.const == 1)#
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	var.par.1  <- pars[4]#
  	var.par.2  <- pars[5]#
  	mu.yr      <- pars[6:length(pars)]#
  } else #
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	theta.2    <- pars[4]#
  	var.par.1  <- pars[5]#
  	var.par.2  <- pars[6]#
  	mu.yr      <- pars[7:length(pars)]#
  }#
  # If male or female we keep thetas fixed so turn off thetas#
  # above and turn those on below. Look in bsc_mean_var_func.R#
  # for more details#
  if (theta.const == 1)#
  {#
  	theta.2   <- (theta.1 * (sqrt(1 - cos(2 * pi * max.contr)^2))) /#
                 cos(2 * pi * max.contr) #
  }#
  # Calculate the means again for the final likelihood update#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par.1,#
                                var.par.2 = var.par.2)#
  }#
  # Evaluate the likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood2))#
  # Give a plot of the current state of the model versus the data#
  #BscPlotNew(c(theta.const, pars))#
#
  # Pars including sigma^2 linf and theta 2#
  pars.inc <- c(pars, theta.2, BscVar(var.par.1, var.par.2, linf))#
  var.par  <- c(var.par.1, var.par.2)#
  thetas   <- c(theta.1, theta.2)#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars.inc)#
 }#
}
no.mnths.par
mu.init.par
MixTimeDepGroMod(lengths, months, no.grps.par, no.mnths.par,#
				 mu.init.par, var.init.par, theta.const.par, #
                  thetas.par,  yrs.old.par, str.mnth.par)
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.par <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh.mn <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.mn  <- matrix(0, nrow = num.months, ncol = no.grps)#
for (i in seq(1, no.grps))#
{#
  mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
}                  #
# Calculate the variances given the current update of the parameters#
for (i in seq(1, no.grps))#
{           #
  var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par[1],#
                                var.par.2 = var.par[2])#
}   #
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.par, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.par, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf	#
# ------------------------------------------------------------------------------	#
# Run while loop over procedure until convergence#
# -----------------------------------------------	#
while (log.like.full - log.like.old > tol) {#
#
  # Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], var.par, mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, var.par, mu.yr)#
  }#
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))	#
  pars            <- optim.means.var$par#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  if (theta.const == 1)#
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	var.par.1  <- pars[4]#
  	var.par.2  <- pars[5]#
  	mu.yr      <- pars[6:length(pars)]#
  } else #
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	theta.2    <- pars[4]#
  	var.par.1  <- pars[5]#
  	var.par.2  <- pars[6]#
  	mu.yr      <- pars[7:length(pars)]#
  }#
  # If male or female we keep thetas fixed so turn off thetas#
  # above and turn those on below. Look in bsc_mean_var_func.R#
  # for more details#
  if (theta.const == 1)#
  {#
  	theta.2   <- (theta.1 * (sqrt(1 - cos(2 * pi * max.contr)^2))) /#
                 cos(2 * pi * max.contr) #
  }#
  # Calculate the means again for the final likelihood update#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par.1,#
                                var.par.2 = var.par.2)#
  }#
  # Evaluate the likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood2))#
  # Give a plot of the current state of the model versus the data#
  #BscPlotNew(c(theta.const, pars))#
#
  # Pars including sigma^2 linf and theta 2#
  pars.inc <- c(pars, theta.2, BscVar(var.par.1, var.par.2, linf))#
  var.par  <- c(var.par.1, var.par.2)#
  thetas   <- c(theta.1, theta.2)#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars.inc)#
 }
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             mu.init.par, var.init.par, theta.const.par, #
                             thetas.par, yrs.old.par, str.mnth.par)#
{	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.par <- var.init.par                       # Variance fun parameter vector#
theta.const <- 1#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh.mn <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.mn  <- matrix(0, nrow = num.months, ncol = no.grps)#
for (i in seq(1, no.grps))#
{#
  mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
}                  #
# Calculate the variances given the current update of the parameters#
for (i in seq(1, no.grps))#
{           #
  var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par[1],#
                                var.par.2 = var.par[2])#
}   #
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.par, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.par, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf	#
# ------------------------------------------------------------------------------	#
# Run while loop over procedure until convergence#
# -----------------------------------------------	#
while (log.like.full - log.like.old > tol) {#
#
  # Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], var.par, mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, var.par, mu.yr)#
  }#
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))	#
  pars            <- optim.means.var$par#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  if (theta.const == 1)#
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	var.par.1  <- pars[4]#
  	var.par.2  <- pars[5]#
  	mu.yr      <- pars[6:length(pars)]#
  } else #
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	theta.2    <- pars[4]#
  	var.par.1  <- pars[5]#
  	var.par.2  <- pars[6]#
  	mu.yr      <- pars[7:length(pars)]#
  }#
  # If male or female we keep thetas fixed so turn off thetas#
  # above and turn those on below. Look in bsc_mean_var_func.R#
  # for more details#
  if (theta.const == 1)#
  {#
  	theta.2   <- (theta.1 * (sqrt(1 - cos(2 * pi * max.contr)^2))) /#
                 cos(2 * pi * max.contr) #
  }#
  # Calculate the means again for the final likelihood update#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par.1,#
                                var.par.2 = var.par.2)#
  }#
  # Evaluate the likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood2))#
  # Give a plot of the current state of the model versus the data#
  #BscPlotNew(c(theta.const, pars))#
#
  # Pars including sigma^2 linf and theta 2#
  pars.inc <- c(pars, theta.2, BscVar(var.par.1, var.par.2, linf))#
  var.par  <- c(var.par.1, var.par.2)#
  thetas   <- c(theta.1, theta.2)#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars.inc)#
 }#
}
MixTimeDepGroMod(lengths, months, no.grps.par, no.mnths.par,#
				 mu.init.par, var.init.par, theta.const.par, #
                 thetas.par,  yrs.old.par, str.mnth.par)
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1
MixTimeDepGroMod(lengths, months, no.grps.par, no.mnths.par,#
				 mu.init.par, var.init.par, theta.const.par, #
                 thetas.par,  yrs.old.par, str.mnth.par)
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             mu.init.par, var.init.par, theta.const.par, #
                             thetas.par, yrs.old.par, str.mnth.par)#
{	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.par <- var.init.par                       # Variance fun parameter vector#
theta.const <- theta.const.par#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh.mn <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.mn  <- matrix(0, nrow = num.months, ncol = no.grps)#
for (i in seq(1, no.grps))#
{#
  mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
}                  #
# Calculate the variances given the current update of the parameters#
for (i in seq(1, no.grps))#
{           #
  var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par[1],#
                                var.par.2 = var.par[2])#
}   #
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.par, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.par, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf	#
# ------------------------------------------------------------------------------	#
# Run while loop over procedure until convergence#
# -----------------------------------------------	#
while (log.like.full - log.like.old > tol) {#
#
  # Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], var.par, mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, var.par, mu.yr)#
  }#
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))	#
  pars            <- optim.means.var$par#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  if (theta.const == 1)#
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	var.par.1  <- pars[4]#
  	var.par.2  <- pars[5]#
  	mu.yr      <- pars[6:length(pars)]#
  } else #
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	theta.2    <- pars[4]#
  	var.par.1  <- pars[5]#
  	var.par.2  <- pars[6]#
  	mu.yr      <- pars[7:length(pars)]#
  }#
  # If male or female we keep thetas fixed so turn off thetas#
  # above and turn those on below. Look in bsc_mean_var_func.R#
  # for more details#
  if (theta.const == 1)#
  {#
  	theta.2   <- (theta.1 * (sqrt(1 - cos(2 * pi * max.contr)^2))) /#
                 cos(2 * pi * max.contr) #
  }#
  # Calculate the means again for the final likelihood update#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par.1,#
                                var.par.2 = var.par.2)#
  }#
  # Evaluate the likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood2))#
  # Give a plot of the current state of the model versus the data#
  #BscPlotNew(c(theta.const, pars))#
#
  # Pars including sigma^2 linf and theta 2#
  pars.inc <- c(pars, theta.2, BscVar(var.par.1, var.par.2, linf))#
  var.par  <- c(var.par.1, var.par.2)#
  thetas   <- c(theta.1, theta.2)#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars.inc)#
 }
}
MixTimeDepGroMod(lengths, months, no.grps.par, no.mnths.par,#
				 mu.init.par, var.init.par, theta.const.par, #
                 thetas.par,  yrs.old.par, str.mnth.par)
theta.const.par
MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             mu.init.par, var.init.par, theta.const.par, #
                             thetas.par, yrs.old.par, str.mnth.par)#
{	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <- lengths.par#
months         <- months.par#
num.months     <- length(unique(months))#
months.lst     <- as.numeric(names(table(months)))#
num.months.seq <- seq(1, num.months)#
yrs.old.par    <- yrs.old.par#
str.mnth.par   <- str.mnth.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <- length(months)                     # Number of individuals #
no.grps  <- no.grps.par#
pi.init  <- rep(1 / no.grps, num.months)#
pis      <- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <- mu.init.par#
if (theta.const.par == 1)#
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
	max.contr  <- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <- thetas.par[1]   #
	theta.2    <- thetas.par[2] #
}#
k0    <- mu.init[1]#
linf  <- mu.init[2]#
mu.yr <- mu.init[3:length(mu.init)]#
thetas   <- c(theta.1, theta.2)#
var.par <- var.init.par                       # Variance fun parameter vector#
theta.const <<- theta.const.par#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh.mn <- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.mn  <- matrix(0, nrow = num.months, ncol = no.grps)#
for (i in seq(1, no.grps))#
{#
  mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
}                  #
# Calculate the variances given the current update of the parameters#
for (i in seq(1, no.grps))#
{           #
  var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par[1],#
                                var.par.2 = var.par[2])#
}   #
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.par, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.par, mu.yr)#
}#
pars#
MeanVarOptim(pars)	#
log.like.full <- -10e5#
tol           <- 10e-6#
log.like.old  <- -Inf	#
# ------------------------------------------------------------------------------	#
# Run while loop over procedure until convergence#
# -----------------------------------------------	#
while (log.like.full - log.like.old > tol) {#
#
  # Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], var.par, mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, var.par, mu.yr)#
  }#
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))	#
  pars            <- optim.means.var$par#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  if (theta.const == 1)#
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	var.par.1  <- pars[4]#
  	var.par.2  <- pars[5]#
  	mu.yr      <- pars[6:length(pars)]#
  } else #
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	theta.2    <- pars[4]#
  	var.par.1  <- pars[5]#
  	var.par.2  <- pars[6]#
  	mu.yr      <- pars[7:length(pars)]#
  }#
  # If male or female we keep thetas fixed so turn off thetas#
  # above and turn those on below. Look in bsc_mean_var_func.R#
  # for more details#
  if (theta.const == 1)#
  {#
  	theta.2   <- (theta.1 * (sqrt(1 - cos(2 * pi * max.contr)^2))) /#
                 cos(2 * pi * max.contr) #
  }#
  # Calculate the means again for the final likelihood update#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par.1,#
                                var.par.2 = var.par.2)#
  }#
  # Evaluate the likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood2))#
  # Give a plot of the current state of the model versus the data#
  #BscPlotNew(c(theta.const, pars))#
#
  # Pars including sigma^2 linf and theta 2#
  pars.inc <- c(pars, theta.2, BscVar(var.par.1, var.par.2, linf))#
  var.par  <- c(var.par.1, var.par.2)#
  thetas   <- c(theta.1, theta.2)#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars.inc)#
 }#
}
MixTimeDepGroMod(lengths, months, no.grps.par, no.mnths.par,#
				 mu.init.par, var.init.par, theta.const.par, #
                 thetas.par,  yrs.old.par, str.mnth.par)
# ------------------------------------------------------------------------------#
# Initialise the main function that call all subsidiary functions#
# ------------------------------------------------------------------------------#
MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             mu.init.par, var.init.par, theta.const.par, #
                             thetas.par, yrs.old.par, str.mnth.par)#
{	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <<- lengths.par#
months         <<- months.par#
num.months     <<- length(unique(months))#
months.lst     <<- as.numeric(names(table(months)))#
num.months.seq <<- seq(1, num.months)#
yrs.old.par    <<- yrs.old.par#
str.mnth.par   <<- str.mnth.par#
theta.const <<- theta.const.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <<- length(months)                     # Number of individuals #
no.grps  <<- no.grps.par#
pi.init  <<- rep(1 / no.grps, num.months)#
pis      <<- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <<- mu.init.par#
if (theta.const == 1)#
{#
	theta.1    <<- thetas.par[1]   #
	theta.2    <<- thetas.par[2] #
	max.contr  <<- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <<- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <<- thetas.par[1]   #
	theta.2    <<- thetas.par[2] #
}#
k0    <<- mu.init[1]#
linf  <<- mu.init[2]#
mu.yr <<- mu.init[3:length(mu.init)]#
thetas   <<- c(theta.1, theta.2)#
var.par <<- var.init.par                       # Variance fun parameter vector#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh.mn <<- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.mn  <<- matrix(0, nrow = num.months, ncol = no.grps)#
for (i in seq(1, no.grps))#
{#
  mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
}                  #
# Calculate the variances given the current update of the parameters#
for (i in seq(1, no.grps))#
{           #
  var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par[1],#
                                var.par.2 = var.par[2])#
}   #
if (theta.const == 1)#
{#
	pars <- c(k0, linf, thetas[1], var.par, mu.yr)#
} else {#
	pars <- c(k0, linf, thetas, var.par, mu.yr)#
}#
MeanVarOptim(pars)	#
log.like.full <<- -10e5#
tol           <<- 10e-6#
log.like.old  <<- -Inf	#
# ------------------------------------------------------------------------------	#
# Run while loop over procedure until convergence#
# -----------------------------------------------	#
while (log.like.full - log.like.old > tol) {#
#
  # Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], var.par, mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, var.par, mu.yr)#
  }#
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))	#
  pars            <- optim.means.var$par#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  if (theta.const == 1)#
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	var.par.1  <- pars[4]#
  	var.par.2  <- pars[5]#
  	mu.yr      <- pars[6:length(pars)]#
  } else #
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	theta.2    <- pars[4]#
  	var.par.1  <- pars[5]#
  	var.par.2  <- pars[6]#
  	mu.yr      <- pars[7:length(pars)]#
  }#
  # If male or female we keep thetas fixed so turn off thetas#
  # above and turn those on below. Look in bsc_mean_var_func.R#
  # for more details#
  if (theta.const == 1)#
  {#
  	theta.2   <- (theta.1 * (sqrt(1 - cos(2 * pi * max.contr)^2))) /#
                 cos(2 * pi * max.contr) #
  }#
  # Calculate the means again for the final likelihood update#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par.1,#
                                var.par.2 = var.par.2)#
  }#
  # Evaluate the likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood2))#
  # Give a plot of the current state of the model versus the data#
  #BscPlotNew(c(theta.const, pars))#
#
  # Pars including sigma^2 linf and theta 2#
  pars.inc <- c(pars, theta.2, BscVar(var.par.1, var.par.2, linf))#
  var.par  <- c(var.par.1, var.par.2)#
  thetas   <- c(theta.1, theta.2)#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars.inc)#
 }#
}
MixTimeDepGroMod(lengths, months, no.grps.par, no.mnths.par,#
				 mu.init.par, var.init.par, theta.const.par, #
                 thetas.par,  yrs.old.par, str.mnth.par)
mean.mnth.coh.mn
MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             mu.init.par, var.init.par, theta.const.par, #
                             thetas.par, yrs.old.par, str.mnth.par)#
{	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <<- lengths.par#
months         <<- months.par#
num.months     <<- length(unique(months))#
months.lst     <<- as.numeric(names(table(months)))#
num.months.seq <<- seq(1, num.months)#
yrs.old.par    <<- yrs.old.par#
str.mnth.par   <<- str.mnth.par#
theta.const <<- theta.const.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <<- length(months)                     # Number of individuals #
no.grps  <<- no.grps.par#
pi.init  <<- rep(1 / no.grps, num.months)#
pis      <<- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <<- mu.init.par#
if (theta.const == 1)#
{#
	theta.1    <<- thetas.par[1]   #
	theta.2    <<- thetas.par[2] #
	max.contr  <<- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <<- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <<- thetas.par[1]   #
	theta.2    <<- thetas.par[2] #
}#
k0    <<- mu.init[1]#
linf  <<- mu.init[2]#
mu.yr <<- mu.init[3:length(mu.init)]#
thetas   <<- c(theta.1, theta.2)#
var.par <<- var.init.par                       # Variance fun parameter vector#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh.mn <<- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.mn  <<- matrix(0, nrow = num.months, ncol = no.grps)#
for (i in seq(1, no.grps))#
{#
  mean.mnth.coh.mn[, i] <<- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
}                  #
# Calculate the variances given the current update of the parameters#
for (i in seq(1, no.grps))#
{           #
  var.mnth.coh.mn[, i] <<- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par[1],#
                                var.par.2 = var.par[2])#
}   #
if (theta.const == 1)#
{#
	pars <<- c(k0, linf, thetas[1], var.par, mu.yr)#
} else {#
	pars <<- c(k0, linf, thetas, var.par, mu.yr)#
}#
MeanVarOptim(pars)	#
log.like.full <<- -10e5#
tol           <<- 10e-6#
log.like.old  <<- -Inf	#
# ------------------------------------------------------------------------------	#
# Run while loop over procedure until convergence#
# -----------------------------------------------	#
while (log.like.full - log.like.old > tol) {#
#
  # Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], var.par, mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, var.par, mu.yr)#
  }#
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))	#
  pars            <- optim.means.var$par#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  if (theta.const == 1)#
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	var.par.1  <- pars[4]#
  	var.par.2  <- pars[5]#
  	mu.yr      <- pars[6:length(pars)]#
  } else #
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	theta.2    <- pars[4]#
  	var.par.1  <- pars[5]#
  	var.par.2  <- pars[6]#
  	mu.yr      <- pars[7:length(pars)]#
  }#
  # If male or female we keep thetas fixed so turn off thetas#
  # above and turn those on below. Look in bsc_mean_var_func.R#
  # for more details#
  if (theta.const == 1)#
  {#
  	theta.2   <- (theta.1 * (sqrt(1 - cos(2 * pi * max.contr)^2))) /#
                 cos(2 * pi * max.contr) #
  }#
  # Calculate the means again for the final likelihood update#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par.1,#
                                var.par.2 = var.par.2)#
  }#
  # Evaluate the likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood2))#
  # Give a plot of the current state of the model versus the data#
  #BscPlotNew(c(theta.const, pars))#
#
  # Pars including sigma^2 linf and theta 2#
  pars.inc <- c(pars, theta.2, BscVar(var.par.1, var.par.2, linf))#
  var.par  <- c(var.par.1, var.par.2)#
  thetas   <- c(theta.1, theta.2)#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars.inc)#
 }#
}
# ==============================================================================#
# ==============================================================================#
#     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     #
#     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     #
#     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     #
#     TA SETS.                                                            #
# ==============================================================================#
# ==============================================================================#
# Remove any objects to clear the slate#
rm(list = ls( ))#
# ------------------------------------------------------------------------------#
# Source the function files needed#
# ------------------------------------------------------------------------------#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_R")#
source("MTDGM_BSC/mtdgm_log_likelihood_func.R")#
source("MTDGM_BSC/mtdgm_mean_length_func.R")#
source("MTDGM_BSC/mtdgm_mean_var_optim_func.R")#
source("MTDGM_BSC/mtdgm_plot_func.R")#
source("MTDGM_BSC/mtdgm_seas_integral_func.R")#
source("MTDGM_BSC/mtdgm_seas_root_func.R")#
source("MTDGM_BSC/mtdgm_var_ricker_func.R")#
source("MTDGM_BSC/mtdgm_pi_calc_func.R")#
# ------------------------------------------------------------------------------#
# Data preliminaries#
# ------------------------------------------------------------------------------#
# Read in the data set on the asymptotic males that was gathered through pots#
lfd.big.males.females <- read.table("Data/BSC/bsc_lfd_pot.txt", header = T)#
# Pull out the lengths and the dates from these data files#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
lfd.trawl.males.females <- read.table("Data/BSC/bsc_lfd_trawl.txt")#
# Pull out the lengths and the dates from these data files#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Subset for males or females#
# Males#
# combined.sex <- c(lfd.trawl.males.females$Sex,   lfd.big.males.females$Sex)#
# males        <- which(combined.sex == 1)#
# lfd.dates    <- lfd.dates[males]#
# lfd.lengths  <- lfd.lengths[males]#
# Females#
# combined.sex <- c(lfd.trawl.males.females$Sex, lfd.big.males.females$Sex)#
# females      <- which(combined.sex == 2)#
# lfd.dates    <- lfd.dates[females]#
# lfd.lengths  <- lfd.lengths[females]#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# ------------------------------------------------------------------------------#
# Initialise the data for the model #
# ------------------------------------------------------------------------------#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
lengths.par     <- lengths#
months.par      <- months#
no.grps.par     <- 3#
no.mnths.par    <- 11#
mu.init.par     <- c(1.1, 175, 60, 80)#
var.init.par    <- c(10, 0.015)#
theta.const.par <- 1#
thetas.par      <- c(1.02346756, 0.32301298)#
var.init.par    <- c(10, 0.015) #
yrs.old.par     <- c(0, 1, 2)#
str.mnth.par    <- 1#
MixTimeDepGroMod(lengths, months, no.grps.par, no.mnths.par,#
				 mu.init.par, var.init.par, theta.const.par, #
                 thetas.par,  yrs.old.par, str.mnth.par)
MixTimeDepGroMod <- function(lengths.par, months.par, no.grps.par, no.mnths.par,#
                             mu.init.par, var.init.par, theta.const.par, #
                             thetas.par, yrs.old.par, str.mnth.par)#
{	#
# ------------------------------------------------------------------------------#
# Initialise the data#
# ------------------------------------------------------------------------------#
lengths        <<- lengths.par#
months         <<- months.par#
num.months     <<- length(unique(months))#
months.lst     <<- as.numeric(names(table(months)))#
num.months.seq <<- seq(1, num.months)#
yrs.old.par    <<- yrs.old.par#
str.mnth.par   <<- str.mnth.par#
theta.const <<- theta.const.par#
# ------------------------------------------------------------------------------#
# Initialise the parameters of the model #
# ------------------------------------------------------------------------------	#
num.inds <<- length(months)                     # Number of individuals #
no.grps  <<- no.grps.par#
pi.init  <<- rep(1 / no.grps, num.months)#
pis      <<- matrix(rep(pi.init, each = no.grps), nrow = num.months, #
                   ncol = no.grps)#
mu.init  <<- mu.init.par#
if (theta.const == 1)#
{#
	theta.1    <<- thetas.par[1]   #
	theta.2    <<- thetas.par[2] #
	max.contr  <<- (1 / (2 * pi)) * #
                  acos(theta.1  /#
                  (sqrt(theta.2 ^ 2 + #
               	  theta.1 ^ 2)))                # Calculates max of seas curve#
	theta.2    <<- (theta.1 * (sqrt(1 - cos(2 * #
              	  pi * max.contr) ^ 2))) /#
                  cos(2 * pi * max.contr)       # Theta 2 constrained by max #
} else #
{#
	theta.1    <<- thetas.par[1]   #
	theta.2    <<- thetas.par[2] #
}#
k0    <<- mu.init[1]#
linf  <<- mu.init[2]#
mu.yr <<- mu.init[3:length(mu.init)]#
thetas   <<- c(theta.1, theta.2)#
var.par <<- var.init.par                       # Variance fun parameter vector#
# ------------------------------------------------------------------------------#
# Initialise the likelihood and set tolerence#
# ------------------------------------------------------------------------------#
mean.mnth.coh.mn <<- matrix(0, nrow = num.months, ncol = no.grps)#
var.mnth.coh.mn  <<- matrix(0, nrow = num.months, ncol = no.grps)#
for (i in seq(1, no.grps))#
{#
  mean.mnth.coh.mn[, i] <<- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
}                  #
# Calculate the variances given the current update of the parameters#
for (i in seq(1, no.grps))#
{           #
  var.mnth.coh.mn[, i] <<- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par[1],#
                                var.par.2 = var.par[2])#
}   #
if (theta.const == 1)#
{#
	pars <<- c(k0, linf, thetas[1], var.par, mu.yr)#
} else {#
	pars <<- c(k0, linf, thetas, var.par, mu.yr)#
}#
MeanVarOptim(pars)	#
log.like.full <<- -10e5#
tol           <<- 10e-6#
log.like.old  <<- -Inf	#
# ------------------------------------------------------------------------------	#
# Run while loop over procedure until convergence#
# -----------------------------------------------	#
while (log.like.full - log.like.old > tol) {#
#
  # Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pis <- t(sapply(num.months.seq, PiCalc))#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  if (theta.const == 1)#
  {#
	pars <- c(k0, linf, thetas[1], var.par, mu.yr)#
  } else {#
	pars <- c(k0, linf, thetas, var.par, mu.yr)#
  }#
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 100000))	#
  pars            <- optim.means.var$par#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  if (theta.const == 1)#
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	var.par.1  <- pars[4]#
  	var.par.2  <- pars[5]#
  	mu.yr      <- pars[6:length(pars)]#
  } else #
  {#
  	k0         <- pars[1]#
  	linf       <- pars[2]#
  	theta.1    <- pars[3]#
  	theta.2    <- pars[4]#
  	var.par.1  <- pars[5]#
  	var.par.2  <- pars[6]#
  	mu.yr      <- pars[7:length(pars)]#
  }#
  # If male or female we keep thetas fixed so turn off thetas#
  # above and turn those on below. Look in bsc_mean_var_func.R#
  # for more details#
  if (theta.const == 1)#
  {#
  	theta.2   <- (theta.1 * (sqrt(1 - cos(2 * pi * max.contr)^2))) /#
                 cos(2 * pi * max.contr) #
  }#
  # Calculate the means again for the final likelihood update#
  for (i in seq(1, no.grps))#
  {#
  	mean.mnth.coh.mn[, i] <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                      	         theta.2 = theta.2, linf = linf , mu.yr = mu.yr, #
                      	         yrs.old = yrs.old.par[i], str.mnth = str.mnth.par)       #
  }                  #
  # Calculate the variances given the current update of the parameters#
  for (i in seq(1, no.grps))#
  {           #
  	var.mnth.coh.mn[, i] <- sapply(mean.mnth.coh.mn[, i], BscVar, var.par.1 = var.par.1,#
                                var.par.2 = var.par.2)#
  }#
  # Evaluate the likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood2))#
  # Give a plot of the current state of the model versus the data#
  #BscPlotNew(c(theta.const, pars))#
#
  # Pars including sigma^2 linf and theta 2#
  pars.inc <- c(pars, theta.2, BscVar(var.par.1, var.par.2, linf))#
  var.par  <- c(var.par.1, var.par.2)#
  thetas   <- c(theta.1, theta.2)#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars.inc)#
 }#
}
MixTimeDepGroMod(lengths, months, no.grps.par, no.mnths.par,#
				 mu.init.par, var.init.par, theta.const.par, #
                 thetas.par,  yrs.old.par, str.mnth.par)
log.like.old
log.like.full
log.like.old
