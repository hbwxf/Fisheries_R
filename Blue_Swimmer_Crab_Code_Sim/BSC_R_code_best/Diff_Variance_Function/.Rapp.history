# Mean function for calcuating the mean length for the current month#
# ------------------------------------------------------------------#
MeanLength <- function(month, k0, theta.1, theta.2 , linf, mu.yr.1, mu.yr.2, #
			  yrs.old, str.mnth) {#
  # Computes the mean length of the distribution for the current month#
  # based on an integration over the seasonal curve from a von Bertal#
  # anffy growth model.#
  ##
  # Args:#
  #  month:    Current month to calulate mean at. Numbered from Jan=0#
  #  k0:       Mean  k paramter for VB model#
  #  theta.1:  Seasonality parameter 1#
  #  theta.2:  Seasonality parameter 1#
  #  linf:     Asymptotic length#
  #  mu.yr.1:  First month's average length yr 1#
  #  mu.yr.2:  First month's average length yr 2#
  #  yrs.old:  How old the individuals in this group are#
  #  str.mnth: The month that we start calculating means for #
  ##
  # Returns:#
  #  Mean length for the month in the current iteration#
  # Set each of the months to be the middle of the month (1/24 to be used#
  # with the seasonal function.#
  mm.val  <- (month %% 12) / 12 + 1 / 24 + yrs.old#
  str.mid <- str.mnth / 12 + 1 / 24 + yrs.old#
  end.mid <- str.mid + 1#
  # Assess whether the parameters at this update cross the y=0 axis#
  # This will allow us to assess whether we need to calculate roots #
  # for the seasonal function or not#
  time      <- seq(0, 1, 0.01)#
  seas.func <- SeasFunc(k0, theta.1, theta.2, time)#
  is.neg.1  <- min(seas.func)#
  is.neg.2  <- max(seas.func)#
  if (is.neg.1 < 0 & is.neg.2 > 0) {#
	# Calculate the roots of the seasonal function #
    root.1 <- SeasRootCalc(k0, theta.1, theta.2, yrs.old)[1]#
    root.2 <- SeasRootCalc(k0, theta.1, theta.2, yrs.old)[2]#
	# Given the roots calculate the integral over the previous years#
	# This is equal to the integral up to the first root + the in#
	int.root.1   <- SeasIntegFunc(k0, theta.1, theta.2, str.mid, root.1)#
	int.root.2   <- SeasIntegFunc(k0, theta.1, theta.2, root.2,  end.mid)#
	int.yrs.prvs <- yrs.old * (int.root.1 + int.root.2)#
    # Integral for those months less than root 1#
    if (mm.val <= root.1) {#
      integral = int.yrs.prvs #
                 + SeasIntegFunc(k0, theta.1, theta.2, str.mid, mm.val)#
    }#
    # Integral for those months greater than root 1 but less than root 2#
#
    if (mm.val > root.1 & mm.val < root.2) {#
    	integral = int.yrs.prvs #
                   + SeasIntegFunc(k0, theta.1, theta.2, str.mid, root.1)#
    }#
    # Integral for those months less than root 1#
    if (mm.val >= root.2) {#
       int.root.1.1 <- SeasIntegFunc(k0, theta.1, theta.2, str.mid, root.1)#
       int.root.2.1 <- SeasIntegFunc(k0, theta.1, theta.2, root.2,  mm.val)#
	   integral     <- int.root.1.1 + int.root.2.1 + int.yrs.prvs#
	  }#
    } else {#
    # If the integral doesn't have a negative component#
    integral = SeasIntegFunc(k0, theta.1, theta.2, str.mid, mm.val)#
    }#
  if (month > 11) {#
    mu.yr.2 + (linf - mu.yr.2) * (1-exp(-integral))#
  } else {#
 	# For the months in the first year #
    mu.yr.1 + (linf - mu.yr.1) * (1-exp(-integral))#
  }#
}
# Function to calculate roots of the integral of the VB seasonal curve#
# ---------------------------------------------------------------------#
#
SeasIntegFunc <- function(k0, theta.1, theta.2, str.time, end.time) {#
  # Calculates the canonical seasonal function for the VB model#
  ##
  # Args:#
  #  k0:       Mean  k paramter for VB model#
  #  theta.1:  Seasonality parameter 1#
  #  theta.2:  Seasonality parameter 1#
  #  str.time  start time for integral#
  #  end.time  end time for integral#
  ##
  # Returns:#
  #  The resultant value of the seasonal function#
  integral <- k0 * (end.time - str.time) + #
              (theta.1 / (2 * pi)) * (sin(2 * pi * end.time) - sin(2 * pi * str.time)) - #
              (theta.2 / (2 * pi)) * (cos(2 * pi * end.time) - cos(2 * pi * str.time))#
  return(integral)#
}
# Function to calculate roots of the seasonal function for the VB model#
# ---------------------------------------------------------------------#
#
SeasFunc <- function(k0, theta.1, theta.2, time.var) {#
  # Calculates the canonical seasonal function for the VB model#
  ##
  # Args:#
  #  k0:       Mean  k paramter for VB model#
  #  theta.1:  Seasonality parameter 1#
  #  theta.2:  Seasonality parameter 1#
  #  time.var  time variable#
  ##
  # Returns:#
  #  The resultant value of the seasonal function#
  return(k0 + theta.1 * cos(2 * pi * time.var) + theta.2 * sin(2 * pi * time.var))#
}#
SeasRootCalc <- function(k0, theta.1, theta.2, yrs.old) {#
  # Computes the roots of the seasonal function used #
  # in VB growth models. This allows for easy integration#
  # of the #
  ##
  # Args:#
  #  k0:       Mean  k paramter for VB model#
  #  theta.1:  Seasonality parameter 1#
  #  theta.2:  Seasonality parameter 1#
  #  yrs.old:  How old the individuals in this group are#
  ##
  # Returns:#
  #  The two roots between 0 and 1 #
  # Define a set of aux variables#
  a = theta.1^2 + theta.2^2#
  b = 2 * k0 * theta.1#
  c = -theta.2^2 + k0^2#
  # Find the set of aux variables solutions#
  u1 = (-b + sqrt(b^2 -4 * a * c)) / (2 * a)#
  u2 = (-b - sqrt(b^2 -4 * a * c)) / (2 * a)#
  # Map them back via arc cos#
  r11 = 1 - acos(u1) / (2 * pi) + yrs.old#
  r12 =     acos(u1) / (2 * pi) + yrs.old#
  r21 = 1 - acos(u2) / (2 * pi) + yrs.old#
  r22 =     acos(u2) / (2 * pi) + yrs.old#
  # Find those that satisfy the roots of our function#
  roots  = c(r11, r12, r21, r22)#
  g.root = SeasFunc(k0, theta.1, theta.2, roots)#
  g.min  = round(g.root)#
  r1     = min(roots[which(g.min == 0)])#
  r2     = max(roots[which(g.min == 0)])#
  # Return the roots#
  return(c(r1, r2))#
  }
# Remove any objects to clear the slate#
#
rm(list = ls( ))#
# Data preliminaries#
# ------------------#
# Set the working directories#
#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_Code_Sim/")#
setwd("BSC_R_code_best/Diff_Variance_Function/")#
# Read in the data set on the asymptotic males that was gathered through pots#
#
lfd.big.males.females <- read.table("LFD_bigMalesFem", header = T)#
# Pull out the lengths and the dates from these data files#
#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
#
lfd.trawl.males.females <- read.table("LFD")#
# Pull out the lengths and the dates from these data files#
#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
#
str.month.yr.1 <- 2#
end.month.yr.1 <- 2#
#
str.month.yr.2 <- 8#
end.month.yr.2 <- 5#
#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# Initialise the data for the model #
# ---------------------------------#
#
num.months      <- 11													#
lfd.lengths.sub <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85		<- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86 		<- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months 			<- c(months.85, months.86)#
months.lst      <- as.numeric(names(table(months)))	#
# Initialise the parameters of the model #
# --------------------------------------#
num.inds <- length(months)					# Number of individuals we have#
pi.1     <- rep(1/3, num.months)			# Pi mixing prop group 1#
pi.2     <- rep(1/3, num.months)			# Pi mixing prop group 2#
k0       <- 1		 						# K0 average K#
linf     <- 200								# Asym length#
mu.yr.1  <- 40								# First month's average length yr 1#
mu.yr.2  <- 40								# First month's average length yr 2#
theta.1  <- 0.2								# Seasonality parameter 1#
theta.2  <- 0.1								# Seasonality parameter 2#
var.pars <- c(5, 1/100, 3, 1)				# Variance function parameter vector
months.lst
months
table(months)
months.85
months.86
lfd.months
lfd.85.feb.aug
as.numeric(lfd.months[lfd.85.feb.aug])
lfd.months[lfd.85.feb.aug]
lfd.months
lfd.85.feb.aug
lfd.months[lfd.85.feb.aug]
lfd.86.feb.may
lfd.months[lfd.86.feb.may]
as.numeric(lfd.months)
lfd.lengths.sub
lfd.months[lfd.85.feb.aug]
lfd.months
as.numeric(lfd.months)
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))
num.months      <- 11													#
lfd.lengths.sub <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85		<- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86 		<- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months 			<- c(months.85, months.86)#
months.lst      <- as.numeric(names(table(months)))
num.inds <- length(months)					# Number of individuals we have#
pi.1     <- rep(1/3, num.months)			# Pi mixing prop group 1#
pi.2     <- rep(1/3, num.months)			# Pi mixing prop group 2#
k0       <- 1		 						# K0 average K#
linf     <- 200								# Asym length#
mu.yr.1  <- 40								# First month's average length yr 1#
mu.yr.2  <- 40								# First month's average length yr 2#
theta.1  <- 0.2								# Seasonality parameter 1#
theta.2  <- 0.1								# Seasonality parameter 2#
var.pars <- c(5, 1/100, 3, 1)				# Variance function parameter vector
months.lst
str.month.yr
str.month.yr.1
lfd.months
num.inds <- length(months)					# Number of individuals we have#
pi.1     <- rep(1/3, num.months)			# Pi mixing prop group 1#
pi.2     <- rep(1/3, num.months)			# Pi mixing prop group 2#
k0       <- 1		 						# K0 average K#
linf     <- 200								# Asym length#
mu.yr.1  <- 40								# First month's average length yr 1#
mu.yr.2  <- 40								# First month's average length yr 2#
theta.1  <- 2								# Seasonality parameter 1#
theta.2  <- 2								# Seasonality parameter 2#
var.pars <- c(5, 1/100, 3, 1)				# Variance function parameter vector
mean_2.yr <- MeanLength(months.lst, k0, theta.1, theta.2, linf, mu.yr.1,
mu.yr.2, 2, 1)
# Mean function for calcuating the mean length for the current month#
# ------------------------------------------------------------------#
MeanLength <- function(month, k0, theta.1, theta.2 , linf, mu.yr.1, mu.yr.2, #
			  yrs.old, str.mnth) {#
  # Computes the mean length of the distribution for the current month#
  # based on an integration over the seasonal curve from a von Bertal#
  # anffy growth model.#
  ##
  # Args:#
  #  month:    Current month to calulate mean at. Numbered from Jan=0#
  #  k0:       Mean  k paramter for VB model#
  #  theta.1:  Seasonality parameter 1#
  #  theta.2:  Seasonality parameter 1#
  #  linf:     Asymptotic length#
  #  mu.yr.1:  First month's average length yr 1#
  #  mu.yr.2:  First month's average length yr 2#
  #  yrs.old:  How old the individuals in this group are#
  #  str.mnth: The month that we start calculating means for #
  ##
  # Returns:#
  #  Mean length for the month in the current iteration#
  # Set each of the months to be the middle of the month (1/24 to be used#
  # with the seasonal function.#
  mm.val  <- (month %% 12) / 12 + 1 / 24 + yrs.old#
  str.mid <- str.mnth / 12 + 1 / 24 + yrs.old#
  end.mid <- str.mid + 1#
  # Assess whether the parameters at this update cross the y=0 axis#
  # This will allow us to assess whether we need to calculate roots #
  # for the seasonal function or not#
  time      <- seq(0, 1, 0.01)#
  seas.func <- SeasFunc(k0, theta.1, theta.2, time)#
  is.neg.1  <- min(seas.func)#
  is.neg.2  <- max(seas.func)#
  if (is.neg.1 < 0 & is.neg.2 > 0) {#
	# Calculate the roots of the seasonal function #
    root.1 <- SeasRootCalc(k0, theta.1, theta.2, yrs.old)[1]#
    root.2 <- SeasRootCalc(k0, theta.1, theta.2, yrs.old)[2]#
	# Given the roots calculate the integral over the previous years#
	# This is equal to the integral up to the first root + the in#
	int.root.1   <- SeasIntegFunc(k0, theta.1, theta.2, str.mid, root.1)#
	int.root.2   <- SeasIntegFunc(k0, theta.1, theta.2, root.2,  end.mid)#
	int.yrs.prvs <- yrs.old * (int.root.1 + int.root.2)#
    # Integral for those months less than root 1#
    if (mm.val <= root.1) {#
      integral = int.yrs.prvs #
                 + SeasIntegFunc(k0, theta.1, theta.2, str.mid, mm.val)#
    }#
    # Integral for those months greater than root 1 but less than root 2#
#
    if (mm.val > root.1 & mm.val < root.2) {#
    	integral = int.yrs.prvs #
                   + SeasIntegFunc(k0, theta.1, theta.2, str.mid, root.1)#
    }#
    # Integral for those months less than root 1#
    if (mm.val >= root.2) {#
       int.root.1.1 <- SeasIntegFunc(k0, theta.1, theta.2, str.mid, root.1)#
       int.root.2.1 <- SeasIntegFunc(k0, theta.1, theta.2, root.2,  mm.val)#
	   integral     <- int.root.1.1 + int.root.2.1 + int.yrs.prvs#
	  }#
    } else {#
    # If the integral doesn't have a negative component#
    integral = SeasIntegFunc(k0, theta.1, theta.2, str.mid, mm.val)#
    }#
  if (month > 11) {#
    mu.yr.2 + (linf - mu.yr.2) * (1-exp(-integral))#
  } else {#
 	# For the months in the first year #
    mu.yr.1 + (linf - mu.yr.1) * (1-exp(-integral))#
  }#
}
mean_2.yr <- MeanLength(months.lst, k0, theta.1, theta.2, linf, mu.yr.1,
mu.yr.2, 2, 1)
source("bsc_seas_integral_func.R")#
source("bsc_mean_length_func.R")#
source("bsc_seas_root_func")#
source("bsc_variance_func")
getwd()
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Code_New")
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Code_New")#
source("bsc_seas_integral_func.R")#
source("bsc_mean_length_func.R")#
source("bsc_seas_root_func.R")#
source("bsc_variance_func.R")
mean_2.yr <- MeanLength(months.lst, k0, theta.1, theta.2, linf, mu.yr.1,
mu.yr.2, 2, 1)
mean_2.yr
months.lst
mean_2.yr <- MeanLength(1, k0, theta.1, theta.2, linf, mu.yr.1,#
             mu.yr.2, 2, 1)
mean_2.yr
mean_2.yr <- MeanLength(2, k0, theta.1, theta.2, linf, mu.yr.1,#
             mu.yr.2, 2, 1)
mean_2.yr
mean_2.yr <- MeanLength(3, k0, theta.1, theta.2, linf, mu.yr.1,#
             mu.yr.2, 2, 1)
mean_2.yr
mu.yr.1
linf
# Remove any objects to clear the slate#
#
rm(list = ls( ))#
#
# Source the function files needed#
# --------------------------------#
#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Code_New")#
source("bsc_seas_integral_func.R")#
source("bsc_mean_length_func.R")#
source("bsc_seas_root_func.R")#
source("bsc_variance_func.R")#
source("bsc_log_likelihood_func.R")#
#
# Data preliminaries#
# ------------------#
#
# Set the working directories#
#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_Code_Sim/")#
setwd("BSC_R_code_best/Diff_Variance_Function/")#
# Read in the data set on the asymptotic males that was gathered through pots#
#
lfd.big.males.females <- read.table("LFD_bigMalesFem", header = T)#
# Pull out the lengths and the dates from these data files#
#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
#
lfd.trawl.males.females <- read.table("LFD")#
# Pull out the lengths and the dates from these data files#
#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# Initialise the data for the model #
# ---------------------------------#
#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
months.lst       <- as.numeric(names(table(months)))	#
num.months.seq   <- seq(1, num.months)#
#
# Initialise the parameters of the model #
# --------------------------------------#
num.inds <- length(months)                    # Number of individuals we have#
pi.1     <- rep(1/3, num.months)              # Pi mixing prop group 1#
pi.2     <- rep(1/3, num.months)              # Pi mixing prop group 2#
pi.3     <- (1- (pi.1 + pi.2))                # Pi group 3. Diff from 1#
k0       <- 1                                 # K0 average K#
linf     <- 200                               # Asym length#
mu.yr.1  <- 40                                # First month's average length yr 1#
mu.yr.2  <- 60                                # First month's average length yr 2#
theta.1  <- 1.0                               # Seasonality parameter 1#
theta.2  <- 1.0                               # Seasonality parameter 2#
var.pars <- c(5, 1/100, 3, 1)                 # Variance fun parameter vector#
# Initialise the means for each of the three groups#
# -------------------------------------------------#
#
# Function paramters are month, k0, theta 1, theta 2, Linf, mean yr 1, #
# mean yr 2, years old, start month or first month included#
#
mean.2.yr <- c()#
mean.1.yr <- c()#
mean.0.yr <- c()#
#
mean.2.yr <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                    theta.2 = theta.2, linf = linf , mu.yr.1 = mu.yr.1, #
                    mu.yr.2 = mu.yr.2, yrs.old = 2, str.mnth = 1)#
mean.1.yr <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                    theta.2 = theta.2, linf = linf , mu.yr.1 = mu.yr.1, #
                    mu.yr.2 = mu.yr.2, yrs.old = 1, str.mnth = 1)#
mean.0.yr <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                    theta.2 = theta.2, linf = linf , mu.yr.1 = mu.yr.1, #
                    mu.yr.2 = mu.yr.2, yrs.old = 0, str.mnth = 1)#
# Initialise the variances for each of the three groups#
# -----------------------------------------------------#
#
# Function paramters are month, k0, theta 1, theta 2, Linf, mean yr 1, #
# mean yr 2, years old, start month or first month included#
#
var.2.yr <- c()#
var.1.yr <- c()#
var.0.yr <- c()#
#
var.2.yr <- sapply(mean.2.yr, BscVar, var.par.1 = var.pars[1],#
                   var.par.2 = var.pars[2], var.par.3 = var.pars[3],#
                   var.par.4 = var.pars[4])#
var.1.yr <- sapply(mean.1.yr, BscVar, var.par.1 = var.pars[1],#
                   var.par.2 = var.pars[2], var.par.3 = var.pars[3],#
                   var.par.4 = var.pars[4])#
var.0.yr <- sapply(mean.0.yr, BscVar, var.par.1 = var.pars[1],#
                   var.par.2 = var.pars[2], var.par.3 = var.pars[3],#
                   var.par.4 = var.pars[4])#
# Initialise the likelihood and set tolerence#
# -------------------------------------------#
log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
tol           <- 10e-6#
log.like.old  <- -10^6
pi.all <- sapply(num.months.seq, PiCalc)#
  pi.1   <- pi.all[1, ]#
  pi.2   <- pi.all[2, ]#
  pi.3   <- pi.all[3, ]
source("bsc_seas_integral_func.R")#
source("bsc_mean_length_func.R")#
source("bsc_seas_root_func.R")#
source("bsc_variance_func.R")#
source("bsc_log_likelihood_func.R")#
source("bsc_pi_calc_func.R")#
source("bsc_mean_optim_func.R")
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Code_New")#
source("bsc_seas_integral_func.R")#
source("bsc_mean_length_func.R")#
source("bsc_seas_root_func.R")#
source("bsc_variance_func.R")#
source("bsc_log_likelihood_func.R")#
source("bsc_pi_calc_func.R")#
source("bsc_mean_optim_func.R")
# Data preliminaries#
# ------------------#
#
# Set the working directories#
#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_Code_Sim/")#
setwd("BSC_R_code_best/Diff_Variance_Function/")#
# Read in the data set on the asymptotic males that was gathered through pots#
#
lfd.big.males.females <- read.table("LFD_bigMalesFem", header = T)#
# Pull out the lengths and the dates from these data files#
#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
#
lfd.trawl.males.females <- read.table("LFD")#
# Pull out the lengths and the dates from these data files#
#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# Initialise the data for the model #
# ---------------------------------#
#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
months.lst       <- as.numeric(names(table(months)))	#
num.months.seq   <- seq(1, num.months)#
#
# Initialise the parameters of the model #
# --------------------------------------#
num.inds <- length(months)                    # Number of individuals we have#
pi.1     <- rep(1/3, num.months)              # Pi mixing prop group 1#
pi.2     <- rep(1/3, num.months)              # Pi mixing prop group 2#
pi.3     <- (1- (pi.1 + pi.2))                # Pi group 3. Diff from 1#
k0       <- 1                                 # K0 average K#
linf     <- 200                               # Asym length#
mu.yr.1  <- 40                                # First month's average length yr 1#
mu.yr.2  <- 60                                # First month's average length yr 2#
theta.1  <- 1.0                               # Seasonality parameter 1#
theta.2  <- 1.0                               # Seasonality parameter 2#
var.pars <- c(5, 1/100, 3, 1)                 # Variance fun parameter vector#
# Initialise the means for each of the three groups#
# -------------------------------------------------#
#
# Function paramters are month, k0, theta 1, theta 2, Linf, mean yr 1, #
# mean yr 2, years old, start month or first month included#
#
mean.2.yr <- c()#
mean.1.yr <- c()#
mean.0.yr <- c()#
#
mean.2.yr <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                    theta.2 = theta.2, linf = linf , mu.yr.1 = mu.yr.1, #
                    mu.yr.2 = mu.yr.2, yrs.old = 2, str.mnth = 1)#
mean.1.yr <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                    theta.2 = theta.2, linf = linf , mu.yr.1 = mu.yr.1, #
                    mu.yr.2 = mu.yr.2, yrs.old = 1, str.mnth = 1)#
mean.0.yr <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                    theta.2 = theta.2, linf = linf , mu.yr.1 = mu.yr.1, #
                    mu.yr.2 = mu.yr.2, yrs.old = 0, str.mnth = 1)#
# Initialise the variances for each of the three groups#
# -----------------------------------------------------#
#
# Function paramters are month, k0, theta 1, theta 2, Linf, mean yr 1, #
# mean yr 2, years old, start month or first month included#
#
var.2.yr <- c()#
var.1.yr <- c()#
var.0.yr <- c()#
#
var.2.yr <- sapply(mean.2.yr, BscVar, var.par.1 = var.pars[1],#
                   var.par.2 = var.pars[2], var.par.3 = var.pars[3],#
                   var.par.4 = var.pars[4])#
var.1.yr <- sapply(mean.1.yr, BscVar, var.par.1 = var.pars[1],#
                   var.par.2 = var.pars[2], var.par.3 = var.pars[3],#
                   var.par.4 = var.pars[4])#
var.0.yr <- sapply(mean.0.yr, BscVar, var.par.1 = var.pars[1],#
                   var.par.2 = var.pars[2], var.par.3 = var.pars[3],#
                   var.par.4 = var.pars[4])#
# Initialise the likelihood and set tolerence#
# -------------------------------------------#
log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
tol           <- 10e-6#
log.like.old  <- -10^6
pi.all <- sapply(num.months.seq, PiCalc)#
  pi.1   <- pi.all[1, ]#
  pi.2   <- pi.all[2, ]#
  pi.3   <- pi.all[3, ]
pi.3
pi.all
pars        <- c(k0, theta.1, theta.2, linf, mu.yr.1, mu.yr.2, var.pars)
k0.fun        <- pars[1]#
  theta.1.fun   <- pars[2]#
  theta.2.fun   <- pars[3]#
  linf.fun      <- pars[4]#
  mu.yr.1.fun   <- pars[5]#
  mu.yr.2.fun   <- pars[6]#
  var.par.1.fun <- pars[7]#
  var.par.2.fun <- pars[8]#
  var.par.3.fun <- pars[9]#
  var.par.4.fun <- pars[10]
mean.2.yr <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 2, str.mnth = 1)#
  mean.1.yr <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 1, str.mnth = 1)#
  mean.0.yr <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 0, str.mnth = 1)
mean.2.yr
mean.1.yr
mean.0.yr
# TODO: UPDATE THESE WITH NEW NAMES                  #
  var.2.yr  <- sapply(mean.2.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.pars[4])#
  var.1.yr  <- sapply(mean.1.yr, BscVar, var.par.1 = var.pars[1],#
                   var.par.2 = var.pars[2], var.par.3 =  var.par.3.fun,#
                   var.par.4 =  var.par.4.fun)#
  var.0.yr  <- sapply(mean.0.yr, BscVar, var.par.1 =  var.par.4.fun,#
                   var.par.2 = var.par.4.fun, var.par.3 = var.par.4.fun,#
                   var.par.4 = var.par.4.fun)
var.2.yr
var.1.yr
var.0.yr
mean.0.yr
var.2.yr  <- sapply(mean.2.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.pars[4])#
  var.1.yr  <- sapply(mean.1.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 =  var.par.3.fun,#
                   var.par.4 =  var.par.4.fun)#
  var.0.yr  <- sapply(mean.0.yr, BscVar, var.par.1 =  var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.par.4.fun)
var.2.yr
var.1.yr
var.par.4 =  var.par.4.fun)#
  var.0.yr
log.like.full <- sum(sapply(num.months.seq, LogLikelihood))
return(-log.like.full)
-log.like.full
# Function to optimise means using optim#
# --------------------------------------#
MeanOptim <- function(pars) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  pars: Vector containing the parameters to optimise#
  #    k0:        Mean  k paramter for VB model#
  #    theta.1:   Seasonality parameter 1#
  #    theta.2:   Seasonality parameter 1#
  #    linf:      Asymptotic length#
  #    mu.yr.1:   First month's average length yr 1#
  #    mu.yr.2:   First month's average length yr 2T0,T1,LINF,M01,M02#
  #    var.pars.x The variance parameters#
  # Returns:#
  #  The negative of the log likelihood for use in the OPTIM function#
  # Declare each of the parameters to names unique to inside the fucntion#
  k0.fun        <- pars[1]#
  theta.1.fun   <- pars[2]#
  theta.2.fun   <- pars[3]#
  linf.fun      <- pars[4]#
  mu.yr.1.fun   <- pars[5]#
  mu.yr.2.fun   <- pars[6]#
  var.par.1.fun <- pars[7]#
  var.par.2.fun <- pars[8]#
  var.par.3.fun <- pars[9]#
  var.par.4.fun <- pars[10]#
#
  # Calculate the means given #
  mean.2.yr <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 2, str.mnth = 1)#
  mean.1.yr <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 1, str.mnth = 1)#
  mean.0.yr <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 0, str.mnth = 1)#
# TODO: UPDATE THESE WITH NEW NAMES                  #
  var.2.yr  <- sapply(mean.2.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.pars[4])#
  var.1.yr  <- sapply(mean.1.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 =  var.par.3.fun,#
                   var.par.4 =  var.par.4.fun)#
  var.0.yr  <- sapply(mean.0.yr, BscVar, var.par.1 =  var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.par.4.fun)#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  print(-log.like.full)#
  return(-log.like.full)#
}
optim.means <- optim(pars, MeanOptim, control = list(maxit = 10000))
# Function to optimise means using optim#
# --------------------------------------#
MeanOptim <- function(pars) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  pars: Vector containing the parameters to optimise#
  #    k0:        Mean  k paramter for VB model#
  #    theta.1:   Seasonality parameter 1#
  #    theta.2:   Seasonality parameter 1#
  #    linf:      Asymptotic length#
  #    mu.yr.1:   First month's average length yr 1#
  #    mu.yr.2:   First month's average length yr 2T0,T1,LINF,M01,M02#
  #    var.pars.x The variance parameters#
  # Returns:#
  #  The negative of the log likelihood for use in the OPTIM function#
  # Declare each of the parameters to names unique to inside the fucntion#
  k0.fun        <- pars[1]#
  theta.1.fun   <- pars[2]#
  theta.2.fun   <- pars[3]#
  linf.fun      <- pars[4]#
  mu.yr.1.fun   <- pars[5]#
  mu.yr.2.fun   <- pars[6]#
  var.par.1.fun <- pars[7]#
  var.par.2.fun <- pars[8]#
  var.par.3.fun <- pars[9]#
  var.par.4.fun <- pars[10]#
#
  # Calculate the means given #
  mean.2.yr <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 2, str.mnth = 1)#
  mean.1.yr <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 1, str.mnth = 1)#
  mean.0.yr <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 0, str.mnth = 1)#
# TODO: UPDATE THESE WITH NEW NAMES                  #
  var.2.yr  <- sapply(mean.2.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.par.4.fun)#
  var.1.yr  <- sapply(mean.1.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 =  var.par.3.fun,#
                   var.par.4 =  var.par.4.fun)#
  var.0.yr  <- sapply(mean.0.yr, BscVar, var.par.1 =  var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.par.4.fun)#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  print(-log.like.full)#
  print(pars)#
  return(-log.like.full)#
}
optim.means <- optim(pars, MeanOptim, control = list(maxit = 10000))
pars.1      <- c(2.5, theta.1, theta.2, linf, mu.yr.1, mu.yr.2, var.pars )
MeanOptim(pars.1)
pars.1      <- c(2.5, 10, theta.2, linf, mu.yr.1, mu.yr.2, var.pars )
MeanOptim(pars.1)
# Function to optimise means using optim#
# --------------------------------------#
MeanVarOptim <- function(pars) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  pars: Vector containing the parameters to optimise#
  #    k0:        Mean  k paramter for VB model#
  #    theta.1:   Seasonality parameter 1#
  #    theta.2:   Seasonality parameter 1#
  #    linf:      Asymptotic length#
  #    mu.yr.1:   First month's average length yr 1#
  #    mu.yr.2:   First month's average length yr 2T0,T1,LINF,M01,M02#
  #    var.pars.x The variance parameters#
  # Returns:#
  #  The negative of the log likelihood for use in the OPTIM function#
  # Declare each of the parameters to names unique to inside the fucntion#
  k0.fun        <- pars[1]#
  theta.1.fun   <- pars[2]#
  theta.2.fun   <- pars[3]#
  linf.fun      <- pars[4]#
  mu.yr.1.fun   <- pars[5]#
  mu.yr.2.fun   <- pars[6]#
  var.par.1.fun <- pars[7]#
  var.par.2.fun <- pars[8]#
  var.par.3.fun <- pars[9]#
  var.par.4.fun <- pars[10]#
#
  # Calculate the means given #
  mean.2.yr <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 2, str.mnth = 1)#
  mean.1.yr <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 1, str.mnth = 1)#
  mean.0.yr <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 0, str.mnth = 1)#
# TODO: UPDATE THESE WITH NEW NAMES                  #
  var.2.yr  <- sapply(mean.2.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.par.4.fun)#
  var.1.yr  <- sapply(mean.1.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 =  var.par.3.fun,#
                   var.par.4 =  var.par.4.fun)#
  var.0.yr  <- sapply(mean.0.yr, BscVar, var.par.1 =  var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.par.4.fun)#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  print(-log.like.full)#
  print(pars)#
  return(-log.like.full)#
}
# Function to optimise means using optim#
# --------------------------------------#
MeanVarOptim <- function(pars) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  pars: Vector containing the parameters to optimise#
  #    k0:        Mean  k paramter for VB model#
  #    theta.1:   Seasonality parameter 1#
  #    theta.2:   Seasonality parameter 1#
  #    linf:      Asymptotic length#
  #    mu.yr.1:   First month's average length yr 1#
  #    mu.yr.2:   First month's average length yr 2T0,T1,LINF,M01,M02#
  #    var.pars.x The variance parameters#
  # Returns:#
  #  The negative of the log likelihood for use in the OPTIM function#
  # Declare each of the parameters to names unique to inside the fucntion#
  k0.fun        <- pars[1]#
  theta.1.fun   <- pars[2]#
  theta.2.fun   <- pars[3]#
  linf.fun      <- pars[4]#
  mu.yr.1.fun   <- pars[5]#
  mu.yr.2.fun   <- pars[6]#
  var.par.1.fun <- pars[7]#
  var.par.2.fun <- pars[8]#
  var.par.3.fun <- pars[9]#
  var.par.4.fun <- pars[10]#
#
  # Calculate the means given the current update of the parameters#
  mean.2.yr <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 2, str.mnth = 1)#
  mean.1.yr <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 1, str.mnth = 1)#
  mean.0.yr <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 0, str.mnth = 1)#
  # Calculate the variances given the current update of the parameters#
  var.2.yr  <- sapply(mean.2.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.par.4.fun)#
  var.1.yr  <- sapply(mean.1.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 =  var.par.3.fun,#
                   var.par.4 =  var.par.4.fun)#
  var.0.yr  <- sapply(mean.0.yr, BscVar, var.par.1 =  var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.par.4.fun)#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  print(-log.like.full)#
  print(pars)#
  return(-log.like.full)#
}
optim.means <- optim(pars, MeanOptim, control = list(maxit = 10000))
pars
?force
MeanVarOptim <- function(pars) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  pars: Vector containing the parameters to optimise#
  #    k0:        Mean  k paramter for VB model#
  #    theta.1:   Seasonality parameter 1#
  #    theta.2:   Seasonality parameter 1#
  #    linf:      Asymptotic length#
  #    mu.yr.1:   First month's average length yr 1#
  #    mu.yr.2:   First month's average length yr 2T0,T1,LINF,M01,M02#
  #    var.pars.x The variance parameters#
  # Returns:#
  #  The negative of the log likelihood for use in the OPTIM function#
  # Declare each of the parameters to names unique to inside the fucntion#
  k0.fun        <- pars[1]#
  theta.1.fun   <- pars[2]#
  theta.2.fun   <- pars[3]#
  linf.fun      <- pars[4]#
  mu.yr.1.fun   <- pars[5]#
  mu.yr.2.fun   <- pars[6]#
  var.par.1.fun <- pars[7]#
  var.par.2.fun <- pars[8]#
  var.par.3.fun <- pars[9]#
  var.par.4.fun <- pars[10]#
#
  # Calculate the means given the current update of the parameters#
#  mean.2.yr <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
#                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
#                    mu.yr.2 = mu.yr.2.fun, yrs.old = 2, str.mnth = 1)#
  mean.2.yr <- sapply(months.lst, function(z) {#
    force(z)#
    MeanLength(z, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 2, str.mnth = 1)#
})#
  mean.1.yr <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 1, str.mnth = 1)#
  mean.0.yr <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 0, str.mnth = 1)#
  # Calculate the variances given the current update of the parameters#
  var.2.yr  <- sapply(mean.2.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.par.4.fun)#
  var.1.yr  <- sapply(mean.1.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 =  var.par.3.fun,#
                   var.par.4 =  var.par.4.fun)#
  var.0.yr  <- sapply(mean.0.yr, BscVar, var.par.1 =  var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.par.4.fun)#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  print(-log.like.full)#
  print(pars)#
  return(-log.like.full)#
}
optim.means <- optim(pars, MeanVarOptim, control = list(maxit = 10000))
f <- function() f()
f <- function() f()
f <- function() f()
my_fun <-function(a, b) a + 10
my_fun(10, f())
mean.2.yr <- c()#
mean.1.yr <- c()#
mean.0.yr <- c()
mean.2.yr
mean.2.yr <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                    theta.2 = theta.2, linf = linf , mu.yr.1 = mu.yr.1, #
                    mu.yr.2 = mu.yr.2, yrs.old = 2, str.mnth = 1)
mean.2.yr
MeanVarOptim <- function(pars) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  pars: Vector containing the parameters to optimise#
  #    k0:        Mean  k paramter for VB model#
  #    theta.1:   Seasonality parameter 1#
  #    theta.2:   Seasonality parameter 1#
  #    linf:      Asymptotic length#
  #    mu.yr.1:   First month's average length yr 1#
  #    mu.yr.2:   First month's average length yr 2T0,T1,LINF,M01,M02#
  #    var.pars.x The variance parameters#
  # Returns:#
  #  The negative of the log likelihood for use in the OPTIM function#
  # Declare each of the parameters to names unique to inside the fucntion#
  k0.fun        <- pars[1]#
  theta.1.fun   <- pars[2]#
  theta.2.fun   <- pars[3]#
  linf.fun      <- pars[4]#
  mu.yr.1.fun   <- pars[5]#
  mu.yr.2.fun   <- pars[6]#
  var.par.1.fun <- pars[7]#
  var.par.2.fun <- pars[8]#
  var.par.3.fun <- pars[9]#
  var.par.4.fun <- pars[10]#
#
  # Calculate the means given the current update of the parameters#
  mean.2.yr <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 2, str.mnth = 1)#
 # mean.2.yr <- sapply(months.lst, function(z) {#
 #   force(z)#
 #   MeanLength(z, k0 = k0.fun, theta.1 = theta.1.fun, #
 #                   theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
 #                   mu.yr.2 = mu.yr.2.fun, yrs.old = 2, str.mnth = 1)#
 # })#
  mean.1.yr <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 1, str.mnth = 1)#
  mean.0.yr <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 0, str.mnth = 1)#
  # Calculate the variances given the current update of the parameters#
  var.2.yr  <- sapply(mean.2.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.par.4.fun)#
  var.1.yr  <- sapply(mean.1.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 =  var.par.3.fun,#
                   var.par.4 =  var.par.4.fun)#
  var.0.yr  <- sapply(mean.0.yr, BscVar, var.par.1 =  var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.par.4.fun)#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  print(-log.like.full)#
  print(pars)#
  return(-log.like.full)#
}
optim.means <- optim(pars, MeanVarOptim, control = list(maxit = 10000))
optim.means <- optim(pars, MeanOptim, control = list(maxit = 10000))
months.lst
mean.2.yr
mean.1.yr
MeanVarOptim <- function(pars) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  pars: Vector containing the parameters to optimise#
  #    k0:        Mean  k paramter for VB model#
  #    theta.1:   Seasonality parameter 1#
  #    theta.2:   Seasonality parameter 1#
  #    linf:      Asymptotic length#
  #    mu.yr.1:   First month's average length yr 1#
  #    mu.yr.2:   First month's average length yr 2T0,T1,LINF,M01,M02#
  #    var.pars.x The variance parameters#
  # Returns:#
  #  The negative of the log likelihood for use in the OPTIM function#
  # Declare each of the parameters to names unique to inside the fucntion#
  k0.fun        <- pars[1]#
  theta.1.fun   <- pars[2]#
  theta.2.fun   <- pars[3]#
  linf.fun      <- pars[4]#
  mu.yr.1.fun   <- pars[5]#
  mu.yr.2.fun   <- pars[6]#
  var.par.1.fun <- pars[7]#
  var.par.2.fun <- pars[8]#
  var.par.3.fun <- pars[9]#
  var.par.4.fun <- pars[10]#
#
  # Calculate the means given the current update of the parameters#
  mean.2.yr <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 2, str.mnth = 1)#
 # mean.2.yr <- sapply(months.lst, function(z) {#
 #   force(z)#
 #   MeanLength(z, k0 = k0.fun, theta.1 = theta.1.fun, #
 #                   theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
 #                   mu.yr.2 = mu.yr.2.fun, yrs.old = 2, str.mnth = 1)#
 # })#
  mean.1.yr <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 1, str.mnth = 1)#
  mean.0.yr <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 0, str.mnth = 1)#
  # Calculate the variances given the current update of the parameters#
  var.2.yr  <- sapply(mean.2.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.par.4.fun)#
  var.1.yr  <- sapply(mean.1.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 =  var.par.3.fun,#
                   var.par.4 =  var.par.4.fun)#
  var.0.yr  <- sapply(mean.0.yr, BscVar, var.par.1 =  var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.par.4.fun)#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  print(-log.like.full)#
  print(pars)#
  return(-log.like.full)#
}
optim.means <- optim(pars, MeanVarOptim, control = list(maxit = 10000))
TRACEBACK()
traceback()
optim.means <- optim(pars, MeanVarOptim, control = list(maxit = 10000))
traceback()
MeanVarOptim <- function(pars) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  pars: Vector containing the parameters to optimise#
  #    k0:        Mean  k paramter for VB model#
  #    theta.1:   Seasonality parameter 1#
  #    theta.2:   Seasonality parameter 1#
  #    linf:      Asymptotic length#
  #    mu.yr.1:   First month's average length yr 1#
  #    mu.yr.2:   First month's average length yr 2T0,T1,LINF,M01,M02#
  #    var.pars.x The variance parameters#
  # Returns:#
  #  The negative of the log likelihood for use in the OPTIM function#
  # Declare each of the parameters to names unique to inside the fucntion#
  k0.fun        <- pars[1]#
  theta.1.fun   <- pars[2]#
  theta.2.fun   <- pars[3]#
  linf.fun      <- pars[4]#
  mu.yr.1.fun   <- pars[5]#
  mu.yr.2.fun   <- pars[6]#
  var.par.1.fun <- pars[7]#
  var.par.2.fun <- pars[8]#
  var.par.3.fun <- pars[9]#
  var.par.4.fun <- pars[10]#
#
  # Calculate the means given the current update of the parameters#
  mean.2.yr <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 2, str.mnth = 1)#
  mean.1.yr <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 1, str.mnth = 1)#
  mean.0.yr <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 0, str.mnth = 1)#
  # Calculate the variances given the current update of the parameters#
  var.2.yr  <- sapply(mean.2.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.par.4.fun)#
  var.1.yr  <- sapply(mean.1.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 =  var.par.3.fun,#
                   var.par.4 =  var.par.4.fun)#
  var.0.yr  <- sapply(mean.0.yr, BscVar, var.par.1 =  var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.par.4.fun)#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  print(-log.like.full)#
  print(pars)#
  return(-log.like.full)#
}
optim.means <- optim(pars, MeanVarOptim, control = list(maxit = 10000))
var.2.yr
var.1.yr
var.0.yr
rm(list(  mean.0.yr,   mean.1.yr,   var.0.yr , mean.2.yr, var.1.yr, var.2.yr)
)
rm(list(  mean.0.yr,   mean.1.yr,   var.0.yr , mean.2.yr, var.1.yr, var.2.yr))
rm(c(  mean.0.yr,   mean.1.yr,   var.0.yr , mean.2.yr, var.1.yr, var.2.yr))
rm(mean.0.yr)
################################################################################
################################################################################
################################################################################
###                                                                         ####
###     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     ####
###     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     ####
###     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     ####
###     TA SETS.                                                            ####
###                                                                         ###	#
################################################################################
################################################################################
################################################################################
#
# Remove any objects to clear the slate#
#
rm(list = ls( ))#
#
# Source the function files needed#
# --------------------------------#
#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Code_New")#
source("bsc_seas_integral_func.R")#
source("bsc_mean_length_func.R")#
source("bsc_seas_root_func.R")#
source("bsc_variance_func.R")#
source("bsc_log_likelihood_func.R")#
source("bsc_pi_calc_func.R")#
source("bsc_mean_optim_func.R")#
# Data preliminaries#
# ------------------#
#
# Set the working directories#
#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_Code_Sim/")#
setwd("BSC_R_code_best/Diff_Variance_Function/")#
# Read in the data set on the asymptotic males that was gathered through pots#
#
lfd.big.males.females <- read.table("LFD_bigMalesFem", header = T)#
# Pull out the lengths and the dates from these data files#
#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
#
lfd.trawl.males.females <- read.table("LFD")#
# Pull out the lengths and the dates from these data files#
#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# Initialise the data for the model #
# ---------------------------------#
#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
months.lst       <- as.numeric(names(table(months)))	#
num.months.seq   <- seq(1, num.months)#
#
# Initialise the parameters of the model #
# --------------------------------------#
num.inds <- length(months)                    # Number of individuals we have#
pi.1     <- rep(1/3, num.months)              # Pi mixing prop group 1#
pi.2     <- rep(1/3, num.months)              # Pi mixing prop group 2#
pi.3     <- (1- (pi.1 + pi.2))                # Pi group 3. Diff from 1#
k0       <- 1                                 # K0 average K#
linf     <- 200                               # Asym length#
mu.yr.1  <- 40                                # First month's average length yr 1#
mu.yr.2  <- 60                                # First month's average length yr 2#
theta.1  <- 1.0                               # Seasonality parameter 1#
theta.2  <- 1.0                               # Seasonality parameter 2#
var.pars <- c(5, 1/100, 3, 1)                 # Variance fun parameter vector#
# Initialise the means for each of the three groups#
# -------------------------------------------------#
#
# Function paramters are month, k0, theta 1, theta 2, Linf, mean yr 1, #
# mean yr 2, years old, start month or first month included#
#
# mean.2.yr <- c()#
# mean.1.yr <- c()#
# mean.0.yr <- c()#
#
# mean.2.yr <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                    # theta.2 = theta.2, linf = linf , mu.yr.1 = mu.yr.1, #
                    # mu.yr.2 = mu.yr.2, yrs.old = 2, str.mnth = 1)#
# mean.1.yr <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                    # theta.2 = theta.2, linf = linf , mu.yr.1 = mu.yr.1, #
                    # mu.yr.2 = mu.yr.2, yrs.old = 1, str.mnth = 1)#
# mean.0.yr <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                    # theta.2 = theta.2, linf = linf , mu.yr.1 = mu.yr.1, #
                    # mu.yr.2 = mu.yr.2, yrs.old = 0, str.mnth = 1)#
# # Initialise the variances for each of the three groups#
# # -----------------------------------------------------#
#
# # Function paramters are month, k0, theta 1, theta 2, Linf, mean yr 1, #
# # mean yr 2, years old, start month or first month included#
#
# var.2.yr <- c()#
# var.1.yr <- c()#
# var.0.yr <- c()#
#
# var.2.yr <- sapply(mean.2.yr, BscVar, var.par.1 = var.pars[1],#
                   # var.par.2 = var.pars[2], var.par.3 = var.pars[3],#
                   # var.par.4 = var.pars[4])#
# var.1.yr <- sapply(mean.1.yr, BscVar, var.par.1 = var.pars[1],#
                   # var.par.2 = var.pars[2], var.par.3 = var.pars[3],#
                   # var.par.4 = var.pars[4])#
# var.0.yr <- sapply(mean.0.yr, BscVar, var.par.1 = var.pars[1],#
                   # var.par.2 = var.pars[2], var.par.3 = var.pars[3],#
                   # var.par.4 = var.pars[4])#
# Initialise the likelihood and set tolerence#
# -------------------------------------------#
log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
tol           <- 10e-6#
log.like.old  <- -10^6	#
# Run while loop over procedure until convergence#
# -----------------------------------------------	#
#
while (log.like.full - log.like.old > tol) {#
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
#
  pi.all <- sapply(num.months.seq, PiCalc)#
  pi.1   <- pi.all[1, ]#
  pi.2   <- pi.all[2, ]#
  pi.3   <- pi.all[3, ]#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  pars        <- c(k0, theta.1, theta.2, linf, mu.yr.1, mu.yr.2, var.pars) #
  pars.1      <- c(2.5, 10, theta.2, linf, mu.yr.1, mu.yr.2, var.pars )#
  optim.means <- optim(pars, MeanVarOptim, control = list(maxit = 10000))	#
}#
	MeanOptim(pars.1)#
	f <- function() f()#
	my_fun <-function(a, b) a + 10#
	my_fun(10, f())
# Function to optimise means using optim#
# --------------------------------------#
MeanVarOptim <- function(pars) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  pars: Vector containing the parameters to optimise#
  #    k0:        Mean  k paramter for VB model#
  #    theta.1:   Seasonality parameter 1#
  #    theta.2:   Seasonality parameter 1#
  #    linf:      Asymptotic length#
  #    mu.yr.1:   First month's average length yr 1#
  #    mu.yr.2:   First month's average length yr 2T0,T1,LINF,M01,M02#
  #    var.pars.x The variance parameters#
  # Returns:#
  #  The negative of the log likelihood for use in the OPTIM function#
  # Declare each of the parameters to names unique to inside the fucntion#
  k0.fun        <- pars[1]#
  theta.1.fun   <- pars[2]#
  theta.2.fun   <- pars[3]#
  linf.fun      <- pars[4]#
  mu.yr.1.fun   <- pars[5]#
  mu.yr.2.fun   <- pars[6]#
  var.par.1.fun <- pars[7]#
  var.par.2.fun <- pars[8]#
  var.par.3.fun <- pars[9]#
  var.par.4.fun <- pars[10]#
#
  # Calculate the means given the current update of the parameters#
  mean.2.yr <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 2, str.mnth = 1)#
  mean.1.yr <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 1, str.mnth = 1)#
  mean.0.yr <- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 0, str.mnth = 1)#
  # Calculate the variances given the current update of the parameters#
  var.2.yr  <- sapply(mean.2.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.par.4.fun)#
  var.1.yr  <- sapply(mean.1.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 =  var.par.3.fun,#
                   var.par.4 =  var.par.4.fun)#
  var.0.yr  <- sapply(mean.0.yr, BscVar, var.par.1 =  var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.par.4.fun)#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  print(-log.like.full)#
  print(pars)#
  return(-log.like.full)#
}
optim.means <- optim(pars, MeanVarOptim, control = list(maxit = 10000))
pars        <- c(k0, theta.1, theta.2, linf, mu.yr.1, mu.yr.2, var.pars)
optim.means <- optim(pars, MeanVarOptim, control = list(maxit = 10000))
# Function to optimise means using optim#
# --------------------------------------#
MeanVarOptim <- function(pars) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  pars: Vector containing the parameters to optimise#
  #    k0:        Mean  k paramter for VB model#
  #    theta.1:   Seasonality parameter 1#
  #    theta.2:   Seasonality parameter 1#
  #    linf:      Asymptotic length#
  #    mu.yr.1:   First month's average length yr 1#
  #    mu.yr.2:   First month's average length yr 2T0,T1,LINF,M01,M02#
  #    var.pars.x The variance parameters#
  # Returns:#
  #  The negative of the log likelihood for use in the OPTIM function#
  # Declare each of the parameters to names unique to inside the fucntion#
  k0.fun        <- pars[1]#
  theta.1.fun   <- pars[2]#
  theta.2.fun   <- pars[3]#
  linf.fun      <- pars[4]#
  mu.yr.1.fun   <- pars[5]#
  mu.yr.2.fun   <- pars[6]#
  var.par.1.fun <- pars[7]#
  var.par.2.fun <- pars[8]#
  var.par.3.fun <- pars[9]#
  var.par.4.fun <- pars[10]#
#
  # Calculate the means given the current update of the parameters#
  mean.2.yr <<- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 2, str.mnth = 1)       #
  mean.1.yr <<- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 1, str.mnth = 1)#
  mean.0.yr <<- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 0, str.mnth = 1)#
  # Calculate the variances given the current update of the parameters#
  var.2.yr  <<- sapply(mean.2.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.par.4.fun)#
  var.1.yr  <<- sapply(mean.1.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 =  var.par.3.fun,#
                   var.par.4 =  var.par.4.fun)#
  var.0.yr  <<- sapply(mean.0.yr, BscVar, var.par.1 =  var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.par.4.fun)#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  print(-log.like.full)#
  print(pars)#
  return(-log.like.full)#
}
optim.means <- optim(pars, MeanVarOptim, control = list(maxit = 10000))
PiCalc
optim.means.var$par
optim.means$par
LogLikelihood
mean.2.yr
mean.1.yr
mean.0.yr
var.2.yr
# Function to optimise means using optim#
# --------------------------------------#
MeanVarOptim <- function(pars) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  pars: Vector containing the parameters to optimise#
  #    k0:        Mean  k paramter for VB model#
  #    theta.1:   Seasonality parameter 1#
  #    theta.2:   Seasonality parameter 1#
  #    linf:      Asymptotic length#
  #    mu.yr.1:   First month's average length yr 1#
  #    mu.yr.2:   First month's average length yr 2T0,T1,LINF,M01,M02#
  #    var.pars.x The variance parameters#
  # Returns:#
  #  The negative of the log likelihood for use in the OPTIM function#
  # Declare each of the parameters to names unique to inside the fucntion#
  k0.fun        <- pars[1]#
  theta.1.fun   <- pars[2]#
  theta.2.fun   <- pars[3]#
  linf.fun      <- pars[4]#
  mu.yr.1.fun   <- pars[5]#
  mu.yr.2.fun   <- pars[6]#
  var.par.1.fun <- pars[7]#
  var.par.2.fun <- pars[8]#
  var.par.3.fun <- pars[9]#
  var.par.4.fun <- pars[10]#
#
  # It seems bad but we need to define the bottom bits as global variables#
  # so that LogLikelihood can see them#
  # Calculate the means given the current update of the parameters#
  mean.2.yr <<- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 2, str.mnth = 1)       #
  mean.1.yr <<- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 1, str.mnth = 1)#
  mean.0.yr <<- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 0, str.mnth = 1)#
  # Calculate the variances given the current update of the parameters#
  var.2.yr  <<- sapply(mean.2.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.par.4.fun)#
  var.1.yr  <<- sapply(mean.1.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 =  var.par.3.fun,#
                   var.par.4 =  var.par.4.fun)#
  var.0.yr  <<- sapply(mean.0.yr, BscVar, var.par.1 =  var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.par.4.fun)#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  print(-log.like.full)#
  print(pars)#
  return(-log.like.full)#
}
# Remove any objects to clear the slate#
#
rm(list = ls( ))#
#
# Source the function files needed#
# --------------------------------#
#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Code_New")#
source("bsc_seas_integral_func.R")#
source("bsc_mean_length_func.R")#
source("bsc_seas_root_func.R")#
source("bsc_variance_func.R")#
source("bsc_log_likelihood_func.R")#
source("bsc_pi_calc_func.R")#
source("bsc_mean_optim_func.R")#
# Data preliminaries#
# ------------------#
#
# Set the working directories#
#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_Code_Sim/")#
setwd("BSC_R_code_best/Diff_Variance_Function/")#
# Read in the data set on the asymptotic males that was gathered through pots#
#
lfd.big.males.females <- read.table("LFD_bigMalesFem", header = T)#
# Pull out the lengths and the dates from these data files#
#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
#
lfd.trawl.males.females <- read.table("LFD")#
# Pull out the lengths and the dates from these data files#
#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# Initialise the data for the model #
# ---------------------------------#
#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
months.lst       <- as.numeric(names(table(months)))	#
num.months.seq   <- seq(1, num.months)#
#
# Initialise the parameters of the model #
# --------------------------------------#
num.inds <- length(months)                    # Number of individuals we have#
pi.1     <- rep(1/3, num.months)              # Pi mixing prop group 1#
pi.2     <- rep(1/3, num.months)              # Pi mixing prop group 2#
pi.3     <- (1- (pi.1 + pi.2))                # Pi group 3. Diff from 1#
k0       <- 1                                 # K0 average K#
linf     <- 200                               # Asym length#
mu.yr.1  <- 40                                # First month's average length yr 1#
mu.yr.2  <- 60                                # First month's average length yr 2#
theta.1  <- 1.0                               # Seasonality parameter 1#
theta.2  <- 1.0                               # Seasonality parameter 2#
var.pars <- c(5, 1/100, 3, 1)                 # Variance fun parameter vector#
pars     <- c(k0, theta.1, theta.2, linf,     # Parameters in a vector#
              mu.yr.1, mu.yr.2, var.pars)
MeanVarOptim(pars)	#
log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
tol           <- 10e-6#
log.like.old  <- -10^6
while (log.like.full - log.like.old > tol) {#
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
  pi.all <- sapply(num.months.seq, PiCalc)#
  pi.1   <- pi.all[1, ]#
  pi.2   <- pi.all[2, ]#
  pi.3   <- pi.all[3, ]#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  pars            <- c(k0, theta.1, theta.2, linf, mu.yr.1, mu.yr.2, var.pars) #
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 10000))	#
  # Ask if optim converged#
  print("Did optim converge?")#
  print( optim.means$convergence)#
  # Re-define the global parameters#
  k0        <- optim.means.var$par[1]#
  theta.1   <- optim.means.var$par[2]#
  theta.2   <- optim.means.var$par[3]#
  linf      <- optim.means.var$par[4]#
  mu.yr.1   <- optim.means.var$par[5]#
  mu.yr.2   <- optim.means.var$par[6]#
  var.par.1 <- optim.means.var$par[7]#
  var.par.2 <- optim.means.var$par[8]#
  var.par.3 <- optim.means.var$par[9]#
  var.par.4 <- optim.means.var$par[10]#
  pars      <- optim.means$par#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  3#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full,log.like.full-log.like.old))#
  print(pars)#
  # Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full  #
#
}
# Function to optimise means using optim#
# --------------------------------------#
MeanVarOptim <- function(pars) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  pars: Vector containing the parameters to optimise#
  #    k0:        Mean  k paramter for VB model#
  #    theta.1:   Seasonality parameter 1#
  #    theta.2:   Seasonality parameter 1#
  #    linf:      Asymptotic length#
  #    mu.yr.1:   First month's average length yr 1#
  #    mu.yr.2:   First month's average length yr 2T0,T1,LINF,M01,M02#
  #    var.pars.x The variance parameters#
  # Returns:#
  #  The negative of the log likelihood for use in the OPTIM function#
  # Declare each of the parameters to names unique to inside the fucntion#
  k0.fun        <- pars[1]#
  theta.1.fun   <- pars[2]#
  theta.2.fun   <- pars[3]#
  linf.fun      <- pars[4]#
  mu.yr.1.fun   <- pars[5]#
  mu.yr.2.fun   <- pars[6]#
  var.par.1.fun <- pars[7]#
  var.par.2.fun <- pars[8]#
  var.par.3.fun <- pars[9]#
  var.par.4.fun <- pars[10]#
#
  # It seems bad but we need to define the bottom bits as global variables#
  # so that LogLikelihood can see them#
  # Calculate the means given the current update of the parameters#
  mean.2.yr <<- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 2, str.mnth = 1)       #
  mean.1.yr <<- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 1, str.mnth = 1)#
  mean.0.yr <<- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 0, str.mnth = 1)#
  # Calculate the variances given the current update of the parameters#
  var.2.yr  <<- sapply(mean.2.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.par.4.fun)#
  var.1.yr  <<- sapply(mean.1.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 =  var.par.3.fun,#
                   var.par.4 =  var.par.4.fun)#
  var.0.yr  <<- sapply(mean.0.yr, BscVar, var.par.1 =  var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.par.4.fun)#
  # Calculate the log likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
#
  # Return the negative of the log likelihood#
  return(-log.like.full)#
}
while (log.like.full - log.like.old > tol) {#
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
  pi.all <- sapply(num.months.seq, PiCalc)#
  pi.1   <- pi.all[1, ]#
  pi.2   <- pi.all[2, ]#
  pi.3   <- pi.all[3, ]#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  pars            <- c(k0, theta.1, theta.2, linf, mu.yr.1, mu.yr.2, var.pars) #
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 10000))	#
  # Ask if optim converged#
  print("Did optim converge?")#
  print( optim.means$convergence)#
  # Re-define the global parameters#
  k0        <- optim.means.var$par[1]#
  theta.1   <- optim.means.var$par[2]#
  theta.2   <- optim.means.var$par[3]#
  linf      <- optim.means.var$par[4]#
  mu.yr.1   <- optim.means.var$par[5]#
  mu.yr.2   <- optim.means.var$par[6]#
  var.par.1 <- optim.means.var$par[7]#
  var.par.2 <- optim.means.var$par[8]#
  var.par.3 <- optim.means.var$par[9]#
  var.par.4 <- optim.means.var$par[10]#
  pars      <- optim.means$par#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  3#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full,log.like.full-log.like.old))#
  print(pars)#
  # Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full  #
#
}
print(optim.means$convergence)
print(optim.means.var$convergence)
while (log.like.full - log.like.old > tol) {#
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
  pi.all <- sapply(num.months.seq, PiCalc)#
  pi.1   <- pi.all[1, ]#
  pi.2   <- pi.all[2, ]#
  pi.3   <- pi.all[3, ]#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  pars            <- c(k0, theta.1, theta.2, linf, mu.yr.1, mu.yr.2, var.pars) #
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 10000))	#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  k0        <- optim.means.var$par[1]#
  theta.1   <- optim.means.var$par[2]#
  theta.2   <- optim.means.var$par[3]#
  linf      <- optim.means.var$par[4]#
  mu.yr.1   <- optim.means.var$par[5]#
  mu.yr.2   <- optim.means.var$par[6]#
  var.par.1 <- optim.means.var$par[7]#
  var.par.2 <- optim.means.var$par[8]#
  var.par.3 <- optim.means.var$par[9]#
  var.par.4 <- optim.means.var$par[10]#
  pars      <- optim.means.var$par#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full,log.like.full-log.like.old))#
  print(pars)#
  # Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full  #
#
}
log.like.old
log.like.old  <- -10^6
log.like.old  <- -10^6
log.like.full - log.like.old
tol
log.like.full - log.like.old > tol
while (log.like.full - log.like.old > tol) {#
#
  # Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
  pi.all <- sapply(num.months.seq, PiCalc)#
  pi.1   <- pi.all[1, ]#
  pi.2   <- pi.all[2, ]#
  pi.3   <- pi.all[3, ]#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  pars            <- c(k0, theta.1, theta.2, linf, mu.yr.1, mu.yr.2, var.pars) #
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 10000))	#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  k0        <- optim.means.var$par[1]#
  theta.1   <- optim.means.var$par[2]#
  theta.2   <- optim.means.var$par[3]#
  linf      <- optim.means.var$par[4]#
  mu.yr.1   <- optim.means.var$par[5]#
  mu.yr.2   <- optim.means.var$par[6]#
  var.par.1 <- optim.means.var$par[7]#
  var.par.2 <- optim.means.var$par[8]#
  var.par.3 <- optim.means.var$par[9]#
  var.par.4 <- optim.means.var$par[10]#
  pars      <- optim.means.var$par#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full,log.like.full-log.like.old))#
  print(pars)#
}
MeanVarOptim(pars)	#
log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
tol           <- 10e-6#
log.like.old  <- -10^6	#
# Run while loop over procedure until convergence#
# -----------------------------------------------	#
#
while (log.like.full - log.like.old > tol) {#
#
  # Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
  pi.all <- sapply(num.months.seq, PiCalc)#
  pi.1   <- pi.all[1, ]#
  pi.2   <- pi.all[2, ]#
  pi.3   <- pi.all[3, ]#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  pars            <- c(k0, theta.1, theta.2, linf, mu.yr.1, mu.yr.2, var.pars) #
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 10000))	#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  k0        <- optim.means.var$par[1]#
  theta.1   <- optim.means.var$par[2]#
  theta.2   <- optim.means.var$par[3]#
  linf      <- optim.means.var$par[4]#
  mu.yr.1   <- optim.means.var$par[5]#
  mu.yr.2   <- optim.means.var$par[6]#
  var.par.1 <- optim.means.var$par[7]#
  var.par.2 <- optim.means.var$par[8]#
  var.par.3 <- optim.means.var$par[9]#
  var.par.4 <- optim.means.var$par[10]#
  pars      <- optim.means.var$par#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full,log.like.full-log.like.old))#
  print(pars)#
}
log.like.old
log.like.full
log.like.full - log.like.old
sum(sapply(num.months.seq, LogLikelihood))
log.like.full
log.like.old
log.like.full
################################################################################
################################################################################
################################################################################
###                                                                         ####
###     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     ####
###     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     ####
###     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     ####
###     TA SETS.                                                            ####
###                                                                         ###	#
################################################################################
################################################################################
################################################################################
#
# Remove any objects to clear the slate#
#
rm(list = ls( ))#
#
# Source the function files needed#
# --------------------------------#
#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Code_New")#
source("bsc_seas_integral_func.R")#
source("bsc_mean_var_length_func.R")#
source("bsc_seas_root_func.R")#
source("bsc_variance_func.R")#
source("bsc_log_likelihood_func.R")#
source("bsc_pi_calc_func.R")#
source("bsc_mean_optim_func.R")#
# Data preliminaries#
# ------------------#
#
# Set the working directories#
#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_Code_Sim/")#
setwd("BSC_R_code_best/Diff_Variance_Function/")#
# Read in the data set on the asymptotic males that was gathered through pots#
#
lfd.big.males.females <- read.table("LFD_bigMalesFem", header = T)#
# Pull out the lengths and the dates from these data files#
#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
#
lfd.trawl.males.females <- read.table("LFD")#
# Pull out the lengths and the dates from these data files#
#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# Initialise the data for the model #
# ---------------------------------#
#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
months.lst       <- as.numeric(names(table(months)))	#
num.months.seq   <- seq(1, num.months)#
#
# Initialise the parameters of the model #
# --------------------------------------#
num.inds <- length(months)                    # Number of individuals we have#
pi.1     <- rep(1/3, num.months)              # Pi mixing prop group 1#
pi.2     <- rep(1/3, num.months)              # Pi mixing prop group 2#
pi.3     <- (1- (pi.1 + pi.2))                # Pi group 3. Diff from 1#
k0       <- 1                                 # K0 average K#
linf     <- 200                               # Asym length#
mu.yr.1  <- 40                                # First month's average length yr 1#
mu.yr.2  <- 60                                # First month's average length yr 2#
theta.1  <- 1.0                               # Seasonality parameter 1#
theta.2  <- 1.0                               # Seasonality parameter 2#
var.pars <- c(5, 1/100, 3, 1)                 # Variance fun parameter vector#
pars     <- c(k0, theta.1, theta.2, linf,     # Parameters in a vector#
              mu.yr.1, mu.yr.2, var.pars) #
# Initialise the likelihood and set tolerence#
# -------------------------------------------#
#
#MeanVarOptim(pars)	#
#log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
tol           <- 10e-6#
log.like.old  <- -10^6	#
# Run while loop over procedure until convergence#
# -----------------------------------------------	#
#
while (log.like.full - log.like.old > tol) {#
#
  # Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
  pi.all <- sapply(num.months.seq, PiCalc)#
  pi.1   <- pi.all[1, ]#
  pi.2   <- pi.all[2, ]#
  pi.3   <- pi.all[3, ]#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  pars            <- c(k0, theta.1, theta.2, linf, mu.yr.1, mu.yr.2, var.pars) #
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 10000))	#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  k0        <- optim.means.var$par[1]#
  theta.1   <- optim.means.var$par[2]#
  theta.2   <- optim.means.var$par[3]#
  linf      <- optim.means.var$par[4]#
  mu.yr.1   <- optim.means.var$par[5]#
  mu.yr.2   <- optim.means.var$par[6]#
  var.par.1 <- optim.means.var$par[7]#
  var.par.2 <- optim.means.var$par[8]#
  var.par.3 <- optim.means.var$par[9]#
  var.par.4 <- optim.means.var$par[10]#
  pars      <- optim.means.var$par#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars)#
}
################################################################################
################################################################################
################################################################################
###                                                                         ####
###     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     ####
###     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     ####
###     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     ####
###     TA SETS.                                                            ####
###                                                                         ###	#
################################################################################
################################################################################
################################################################################
#
# Remove any objects to clear the slate#
#
rm(list = ls( ))#
#
# Source the function files needed#
# --------------------------------#
#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Code_New")#
source("bsc_seas_integral_func.R")#
source("bsc_mean_var_length_func.R")#
source("bsc_seas_root_func.R")#
source("bsc_variance_func.R")#
source("bsc_log_likelihood_func.R")#
source("bsc_pi_calc_func.R")#
source("bsc_mean_optim_func.R")#
# Data preliminaries#
# ------------------#
#
# Set the working directories#
#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_Code_Sim/")#
setwd("BSC_R_code_best/Diff_Variance_Function/")#
# Read in the data set on the asymptotic males that was gathered through pots#
#
lfd.big.males.females <- read.table("LFD_bigMalesFem", header = T)#
# Pull out the lengths and the dates from these data files#
#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
#
lfd.trawl.males.females <- read.table("LFD")#
# Pull out the lengths and the dates from these data files#
#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# Initialise the data for the model #
# ---------------------------------#
#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
months.lst       <- as.numeric(names(table(months)))	#
num.months.seq   <- seq(1, num.months)#
#
# Initialise the parameters of the model #
# --------------------------------------#
num.inds <- length(months)                    # Number of individuals we have#
pi.1     <- rep(1/3, num.months)              # Pi mixing prop group 1#
pi.2     <- rep(1/3, num.months)              # Pi mixing prop group 2#
pi.3     <- (1- (pi.1 + pi.2))                # Pi group 3. Diff from 1#
k0       <- 1                                 # K0 average K#
linf     <- 200                               # Asym length#
mu.yr.1  <- 40                                # First month's average length yr 1#
mu.yr.2  <- 60                                # First month's average length yr 2#
theta.1  <- 1.0                               # Seasonality parameter 1#
theta.2  <- 1.0                               # Seasonality parameter 2#
var.pars <- c(5, 1/100, 3, 1)                 # Variance fun parameter vector#
pars     <- c(k0, theta.1, theta.2, linf,     # Parameters in a vector#
              mu.yr.1, mu.yr.2, var.pars) #
# Initialise the likelihood and set tolerence#
# -------------------------------------------#
#
#MeanVarOptim(pars)	#
log.like.full <- 0#
tol           <- 10e-6#
log.like.old  <- -10^6	#
# Run while loop over procedure until convergence#
# -----------------------------------------------	#
#
while (log.like.full - log.like.old > tol) {#
#
  # Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
  pi.all <- sapply(num.months.seq, PiCalc)#
  pi.1   <- pi.all[1, ]#
  pi.2   <- pi.all[2, ]#
  pi.3   <- pi.all[3, ]#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  pars            <- c(k0, theta.1, theta.2, linf, mu.yr.1, mu.yr.2, var.pars) #
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 10000))	#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  k0        <- optim.means.var$par[1]#
  theta.1   <- optim.means.var$par[2]#
  theta.2   <- optim.means.var$par[3]#
  linf      <- optim.means.var$par[4]#
  mu.yr.1   <- optim.means.var$par[5]#
  mu.yr.2   <- optim.means.var$par[6]#
  var.par.1 <- optim.means.var$par[7]#
  var.par.2 <- optim.means.var$par[8]#
  var.par.3 <- optim.means.var$par[9]#
  var.par.4 <- optim.means.var$par[10]#
  pars      <- optim.means.var$par#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars)#
}
mean.2.yr
sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 2, str.mnth = 1)
pars
k0.fun        <- pars[1]#
  theta.1.fun   <- pars[2]#
  theta.2.fun   <- pars[3]#
  linf.fun      <- pars[4]#
  mu.yr.1.fun   <- pars[5]#
  mu.yr.2.fun   <- pars[6]#
  var.par.1.fun <- pars[7]#
  var.par.2.fun <- pars[8]#
  var.par.3.fun <- pars[9]#
  var.par.4.fun <- pars[10]
sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 2, str.mnth = 1)
optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 10000))
k0.fun
theta.1.fun
theta.2.fun
linf.fun
################################################################################
################################################################################
################################################################################
###                                                                         ####
###     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     ####
###     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     ####
###     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     ####
###     TA SETS.                                                            ####
###                                                                         ###	#
################################################################################
################################################################################
################################################################################
#
# Remove any objects to clear the slate#
#
rm(list = ls( ))#
#
# Source the function files needed#
# --------------------------------#
#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Code_New")#
source("bsc_seas_integral_func.R")#
source("bsc_mean_length_func.R")#
source("bsc_seas_root_func.R")#
source("bsc_variance_func.R")#
source("bsc_log_likelihood_func.R")#
source("bsc_pi_calc_func.R")#
source("bsc_mean_var_optim_func.R")#
# Data preliminaries#
# ------------------#
#
# Set the working directories#
#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_Code_Sim/")#
setwd("BSC_R_code_best/Diff_Variance_Function/")#
# Read in the data set on the asymptotic males that was gathered through pots#
#
lfd.big.males.females <- read.table("LFD_bigMalesFem", header = T)#
# Pull out the lengths and the dates from these data files#
#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
#
lfd.trawl.males.females <- read.table("LFD")#
# Pull out the lengths and the dates from these data files#
#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# Initialise the data for the model #
# ---------------------------------#
#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
months.lst       <- as.numeric(names(table(months)))	#
num.months.seq   <- seq(1, num.months)#
#
# Initialise the parameters of the model #
# --------------------------------------#
num.inds <- length(months)                    # Number of individuals we have#
pi.1     <- rep(1/3, num.months)              # Pi mixing prop group 1#
pi.2     <- rep(1/3, num.months)              # Pi mixing prop group 2#
pi.3     <- (1- (pi.1 + pi.2))                # Pi group 3. Diff from 1#
k0       <- 1                                 # K0 average K#
linf     <- 200                               # Asym length#
mu.yr.1  <- 40                                # First month's average length yr 1#
mu.yr.2  <- 60                                # First month's average length yr 2#
theta.1  <- 1.0                               # Seasonality parameter 1#
theta.2  <- 1.0                               # Seasonality parameter 2#
var.pars <- c(5, 1/100, 3, 1)                 # Variance fun parameter vector#
pars     <- c(k0, theta.1, theta.2, linf,     # Parameters in a vector#
              mu.yr.1, mu.yr.2, var.pars) #
# Initialise the likelihood and set tolerence#
# -------------------------------------------#
#
#MeanVarOptim(pars)	#
log.like.full <- 0#
tol           <- 10e-6#
log.like.old  <- -10^6	#
# Run while loop over procedure until convergence#
# -----------------------------------------------	#
#
while (log.like.full - log.like.old > tol) {#
#
  # Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
  pi.all <- sapply(num.months.seq, PiCalc)#
  pi.1   <- pi.all[1, ]#
  pi.2   <- pi.all[2, ]#
  pi.3   <- pi.all[3, ]#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  pars            <- c(k0, theta.1, theta.2, linf, mu.yr.1, mu.yr.2, var.pars) #
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 10000))	#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  k0        <- optim.means.var$par[1]#
  theta.1   <- optim.means.var$par[2]#
  theta.2   <- optim.means.var$par[3]#
  linf      <- optim.means.var$par[4]#
  mu.yr.1   <- optim.means.var$par[5]#
  mu.yr.2   <- optim.means.var$par[6]#
  var.par.1 <- optim.means.var$par[7]#
  var.par.2 <- optim.means.var$par[8]#
  var.par.3 <- optim.means.var$par[9]#
  var.par.4 <- optim.means.var$par[10]#
  pars      <- optim.means.var$par#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars)#
}
MeanVarOptim
MeanLength
sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 2, str.mnth = 1)
sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 1, str.mnth = 1)
sapply(mean.2.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.par.4.fun)
mean.2.yr
mean.1.yr
sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 2, str.mnth = 1)
SeasFunc
SeasFunc(k0, theta.1, theta.2, time)
time
SeasFunc(k0, theta.1, theta.2, time.var)
time.var      <- seq(0, 1, 0.01)
SeasFunc(k0, theta.1, theta.2, time.var)
# Mean function for calcuating the mean length for the current month#
# ------------------------------------------------------------------#
MeanLength <- function(month, k0, theta.1, theta.2 , linf, mu.yr.1, mu.yr.2, #
			  yrs.old, str.mnth) {#
  # Computes the mean length of the distribution for the current month#
  # based on an integration over the seasonal curve from a von Bertal#
  # anffy growth model.#
  ##
  # Args:#
  #  month:    Current month to calulate mean at. Numbered from Jan=0#
  #  k0:       Mean  k paramter for VB model#
  #  theta.1:  Seasonality parameter 1#
  #  theta.2:  Seasonality parameter 1#
  #  linf:     Asymptotic length#
  #  mu.yr.1:  First month's average length yr 1#
  #  mu.yr.2:  First month's average length yr 2#
  #  yrs.old:  How old the individuals in this group are#
  #  str.mnth: The month that we start calculating means for #
  ##
  # Returns:#
  #  Mean length for the month in the current iteration#
  # Test values #
  # month    = 1 #
  # k0       = 1#
  # theta.1  = 2 #
  # theta.2  = 2 #
  # linf     = 200#
  # mu.yr.1  = 40#
  # mu.yr.2  = 40#
  # yrs.old  = 1#
  # str.mnth = 1#
  # Set each of the months to be the middle of the month (1/24 to be used#
  # with the seasonal function.#
  mm.val  <- (month %% 12) / 12 + 1 / 24 + yrs.old#
  str.mid <- str.mnth / 12 + 1 / 24 + yrs.old#
  end.mid <- 1 + 1 / 24 + yrs.old#
  # Assess whether the parameters at this update cross the y=0 axis#
  # This will allow us to assess whether we need to calculate roots #
  # for the seasonal function or not#
  time.var  <- seq(0, 1, 0.01)#
  seas.func <- SeasFunc(k0, theta.1, theta.2, time.var)#
  is.neg.1  <- min(seas.func)#
  is.neg.2  <- max(seas.func)#
  if (is.neg.1 < 0 & is.neg.2 > 0) {#
	# Calculate the roots of the seasonal function #
    root.1 <- SeasRootCalc(k0, theta.1, theta.2, yrs.old)[1]#
    root.2 <- SeasRootCalc(k0, theta.1, theta.2, yrs.old)[2]#
	# Given the roots calculate the integral over the previous years#
	# This is equal to the integral up to the first root + the in#
	int.root.1   <- SeasIntegFunc(k0, theta.1, theta.2, str.mid, root.1)#
	int.root.2   <- SeasIntegFunc(k0, theta.1, theta.2, root.2,  end.mid)#
	int.yrs.prvs <- yrs.old * (int.root.1 + int.root.2)#
    # Integral for those months less than root 1#
    if (mm.val <= root.1) {#
      integral = int.yrs.prvs + #
                 SeasIntegFunc(k0, theta.1, theta.2, str.mid, mm.val)#
    }#
    # Integral for those months greater than root 1 but less than root 2#
#
    if (mm.val > root.1 & mm.val < root.2) {#
    	integral = int.yrs.prvs +#
                   SeasIntegFunc(k0, theta.1, theta.2, str.mid, root.1)#
    }#
    # Integral for those months less than root 1#
    if (mm.val >= root.2) {#
       int.root.1.1 <- SeasIntegFunc(k0, theta.1, theta.2, str.mid, root.1)#
       int.root.2.1 <- SeasIntegFunc(k0, theta.1, theta.2, root.2,  mm.val)#
	   integral     <- int.root.1.1 + int.root.2.1 + int.yrs.prvs#
	  }#
    } else {#
    # If the integral doesn't have a negative component#
    integral = SeasIntegFunc(k0, theta.1, theta.2, str.mid, mm.val)#
    }#
  #print(integral)#
  # If the months are for the first or second year make sure to#
  # assign the correct mean length for that year#
  if (month > 11) {#
    return(mu.yr.2 + (linf - mu.yr.2) * (1-exp(-integral)))#
  } else {#
 	# For the months in the first year #
    return(mu.yr.1 + (linf - mu.yr.1) * (1-exp(-integral)))#
  }#
}
sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 2, str.mnth = 1)
k0.fun
pars[1]
k0.fun        <- pars[1]
sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 2, str.mnth = 1)
k0.fun        <- pars[1]#
  theta.1.fun   <- pars[2]#
  theta.2.fun   <- pars[3]#
  linf.fun      <- pars[4]#
  mu.yr.1.fun   <- pars[5]#
  mu.yr.2.fun   <- pars[6]#
  var.par.1.fun <- pars[7]#
  var.par.2.fun <- pars[8]#
  var.par.3.fun <- pars[9]#
  var.par.4.fun <- pars[10]
sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 2, str.mnth = 1)
pars            <- c(k0, theta.1, theta.2, linf, mu.yr.1, mu.yr.2, var.pars)
optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 10000))
pars     <- c(k0, theta.1, theta.2, linf,     # Parameters in a vector#
              mu.yr.1, mu.yr.2, var.pars) #
# Initialise the likelihood and set tolerence#
# -------------------------------------------#
#
#MeanVarOptim(pars)	#
log.like.full <- 0#
tol           <- 10e-6#
log.like.old  <- -10^6	#
# Run while loop over procedure until convergence#
# -----------------------------------------------	#
#
while (log.like.full - log.like.old > tol) {#
#
  # Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
  pi.all <- sapply(num.months.seq, PiCalc)#
  pi.1   <- pi.all[1, ]#
  pi.2   <- pi.all[2, ]#
  pi.3   <- pi.all[3, ]#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  # pars            <- c(k0, theta.1, theta.2, linf, mu.yr.1, mu.yr.2, var.pars) #
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 10000))	#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  k0        <- optim.means.var$par[1]#
  theta.1   <- optim.means.var$par[2]#
  theta.2   <- optim.means.var$par[3]#
  linf      <- optim.means.var$par[4]#
  mu.yr.1   <- optim.means.var$par[5]#
  mu.yr.2   <- optim.means.var$par[6]#
  var.par.1 <- optim.means.var$par[7]#
  var.par.2 <- optim.means.var$par[8]#
  var.par.3 <- optim.means.var$par[9]#
  var.par.4 <- optim.means.var$par[10]#
  pars      <- optim.means.var$par#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars)#
}
log.like.full
log.like.old
log.like.full <- -10^7
log.like.old  <- -10^6
log.like.full - log.like.old
log.like.full <- -10^7#
tol           <- 10e-6#
log.like.old  <- -10^6
log.like.full - log.like.old
log.like.full
log.like.old
log.like.full <- -10^5
log.like.full - log.like.old
while (log.like.full - log.like.old > tol) {#
#
  # Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
  pi.all <- sapply(num.months.seq, PiCalc)#
  pi.1   <- pi.all[1, ]#
  pi.2   <- pi.all[2, ]#
  pi.3   <- pi.all[3, ]#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  # pars            <- c(k0, theta.1, theta.2, linf, mu.yr.1, mu.yr.2, var.pars) #
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 10000))	#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  k0        <- optim.means.var$par[1]#
  theta.1   <- optim.means.var$par[2]#
  theta.2   <- optim.means.var$par[3]#
  linf      <- optim.means.var$par[4]#
  mu.yr.1   <- optim.means.var$par[5]#
  mu.yr.2   <- optim.means.var$par[6]#
  var.par.1 <- optim.means.var$par[7]#
  var.par.2 <- optim.means.var$par[8]#
  var.par.3 <- optim.means.var$par[9]#
  var.par.4 <- optim.means.var$par[10]#
  pars      <- optim.means.var$par#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars)#
}
log.like.full
###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	#Set the necessary working directories#
	#setwd("/Users/uqllloyd/Dropbox/AAUni/APhD/Blueswimmer/CrabStuff2withMMAlg/RcodesData")#
	setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_Code_Sim/BSC_R_code_best/Diff_Variance_Function")#
	#Remove any old objects#
	rm(list = ls())#
	#DATA PRELIMINARIES#
	#Read in the data set on the asymptotic males that was gathered through pots#
	LFD_bigMalesFemales<-read.table("LFD_bigMalesFem",header=T)#
	#Pull out the lengths and the dates from these data files#
	Dates1<-as.Date(LFD_bigMalesFemales$Date,"%d/%m/%y")               #
	Lengths1<-LFD_bigMalesFemales$Carapacewidth#
	#Read in the trawl data on males that contains juvenile recruitment and adults#
	LFD<-read.table("LFD")#
	#which(LFD$Sex==1)#
	#Pull out the lengths and the dates from these data files#
	Dates2<-as.Date(LFD$Date,"%d/%m/%Y")#
	Lengths2<-LFD$Carapace.width#
	#Concatenate the necessary elements from each file into a common dates and lengths array#
	Dates <- c(Dates2,Dates1)#
	Lengths <- c(Lengths2,Lengths1)#
	#Pull out the year and month information from these dates#
	YEAR <- format(Dates,'%Y')#
	MONTHS <- format(Dates,'%m')#
	#Pull out the years and months that we a re interested in i.e., those that don't contain 	recruitment#
	WHICH85JO <- which((YEAR == '1985') & (as.numeric(MONTHS) %in% (2:8)))#
	WHICH86FM <- which((YEAR == '1986') & (as.numeric(MONTHS) %in% (2:5)))#
	#INITIALISE#
	MON <- 11													#Assign how many months we would like to model#
	LL <- Lengths[c(WHICH85JO,WHICH86FM)]						#Assign the number of individuals#
	MM1985 <- as.numeric(MONTHS[WHICH85JO])-1					#Assign January to be the 0th months#
	MM1986 <- as.numeric(MONTHS[WHICH86FM])+11					#Thus January of next year will be the 12 month. Plus we do this so that we don't have to estimate yr#
	MM<-c(MM1985,MM1986)										#Concatenate these months values together#
	MMLIST <- as.numeric(names(table(MM)))						#Make a list of the months from January first i.e., January 1986 is gets assigned a 12#
	#Parameter Initialise#
	NN <- length(MM)											#Initialise the number of individuals we have#
	PI1 <- rep(1/3,MON)											#Initialise the PIs#
	PI2 <- rep(1/3,MON)											#Initialise the PIs#
	K0 <- 1														#Initialise K0 average K#
	LINF <- 200													#Initialise asym length#
	M01<-40														#Initialise first month's average length#
	M02<-40														#Initialise second month's average length#
	T0 <- 0.2														#Initialise first seasonality parameter#
	T1 <- 0.1														#Initialise second seasonality parameter#
	VV <- c(5,1/100,3,1)											   #Initialise the starting values for the variance quadratic update#
	#Setting values for drawing plots #
	#K0=0.84062808;  LINF=159.65387413; M01=58.86155838; M02=81.29860313; T0=-0.07925965; T1=0.57794716; VV=c( -4.77584147,   6.19436755  ,-0.03489903)#
	#0.84062808  -0.07925965   0.57794716 159.65387413  58.86155838  81.29860313  -4.77584147   6.19436755  -0.03489903#
	#FUNCTIONS#
	#ASYMPTOTIC MEAN FUNCTION#
	MU2A <- function(mm,K0,T0,T1,LINF,M01,M02)#
	{#
	  #mm=1#
	  mmval <- MMLIST[mm]%%12#
	  yrsold<-2#
	  strmnth<-min(MM1985)#
	  strmid<-strmnth/12+1/24+yrsold#
	  endmid<-strmid+1#
	  mm2=(mmval/12)+1/24+yrsold#
	  t<-seq(0,1,0.01)#
	  g<-K0+T0*cos(2*pi*t)+T1*sin(2*pi*t)#
	  #plot(t,g)#
	  Isneg<-min(g)#
	  Isneg2<-max(g)#
	  if (Isneg<0&Isneg2>0)#
	  {#
	    a=T0^2+T1^2#
		b=2*K0*T0#
		c=-(T1^2)+K0^2#
		u1=(-b+sqrt(b^2-4*a*c))/(2*a)#
		u2=(-b-sqrt(b^2-4*a*c))/(2*a)#
		r11=1-acos(u1)/(2*pi)+yrsold#
		r12=acos(u1)/(2*pi)+yrsold#
		r21=1-acos(u2)/(2*pi)+yrsold#
		r22=acos(u2)/(2*pi)+yrsold#
		roots<-c(r11, r12, r21, r22)#
		groot<-K0+T0*cos(2*pi* roots)+T1*sin(2*pi* roots)#
		gmin<-round(groot)#
		r1<-min(roots[which(gmin==0)])#
		r2<-max(roots[which(gmin==0)])#
	    #Regime#
		zMid1=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    zEnd1=K0*(endmid-r2) + (T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*r2)) - (T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*r2))#
	    KKyr<-yrsold*(zEnd1+zMid1)#
	    #Those less than r1#
	    if (mm2<r1) {KK = KKyr + K0*(mm2-strmid) +   (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}#
	    #Those between r1 and r2#
	    if (mm2>r1&mm2<r2) {KK= KKyr + K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))}#
	    #Those after r2#
	    if (mm2>r2)#
	    {#
	    zMid=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    zEnd=K0*(mm2-r2)     + (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*r2))     - (T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*r2))#
	    KK<-zEnd+zMid+KKyr#
	    }#
	  } else {KK=K0*(mm2-strmid)+(T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid)) + yrsold*(K0*(endmid-strmid)+(T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*strmid)) )}#
	  if (MMLIST[mm]>max(MM1985)) {M02 + (LINF-M02)*(1-exp(-KK))} else (M01 + (LINF-M01)*(1-exp(-KK)))#
	}#
	#1 YEAR OLD ADULT's MEAN FUNCTION#
	MUA <- function(mm,K0,T0,T1,LINF,M01,M02)#
	{#
	  mmval <- MMLIST[mm]%%12#
	  yrsold<-1#
	  strmnth<-min(MM1985)#
	  strmid<-strmnth/12+1/24+yrsold#
	  endmid<-strmid+1#
	  mm2=(mmval/12)+1/24+yrsold#
	  t<-seq(0,1,0.01)#
	  g<-K0+T0*cos(2*pi*t)+T1*sin(2*pi*t)#
	  Isneg<-min(g)#
	  Isneg2<-max(g)#
	  if (Isneg<0&Isneg2>0)#
	  {#
	    a=T0^2+T1^2#
		b=2*K0*T0#
		c=-(T1^2)+K0^2#
		u1=(-b+sqrt(b^2-4*a*c))/(2*a)#
		u2=(-b-sqrt(b^2-4*a*c))/(2*a)#
		r11=1-acos(u1)/(2*pi)+yrsold#
		r12=acos(u1)/(2*pi)+yrsold#
		r21=1-acos(u2)/(2*pi)+yrsold#
		r22=acos(u2)/(2*pi)+yrsold#
		roots<-c(r11, r12, r21, r22)#
		groot<-K0+T0*cos(2*pi* roots)+T1*sin(2*pi* roots)#
		gmin<-round(groot)#
		r1<-min(roots[which(gmin==0)])#
		r2<-max(roots[which(gmin==0)])#
	    #Regime#
		zMid1=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    zEnd1=K0*(endmid-r2) + (T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*r2)) - (T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*r2))#
	    KKyr<-yrsold*(zEnd1+zMid1)#
	    	#Those less than r1#
	    	if (mm2<r1) {KK = KKyr + K0*(mm2-strmid) +   (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}#
	    	#Those between r1 and r2#
	    	if (mm2>r1&mm2<r2) {KK= KKyr + K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))}#
	    	#Those after r2#
	    	if (mm2>r2)#
	    		{#
	    		zMid=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    		zEnd=K0*(mm2-r2)     + (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*r2))     - (T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*r2))#
	    		KK<-zEnd+zMid+KKyr#
	    		}#
	  } else {KK=K0*(mm2-strmid)+(T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid)) + yrsold*(K0*(endmid-strmid)+(T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*strmid)) )}#
	  if (MMLIST[mm]>max(MM1985)) {M02 + (LINF-M02)*(1-exp(-KK))} else (M01 + (LINF-M01)*(1-exp(-KK)))#
	}#
	#THE JUVENUILES MEAN FUNCTION#
	MUJ <- function(mm,K0,T0,T1,LINF,M01,M02)#
	{#
		#mm=2#
		mmval <- MMLIST[mm]%%12#
	  	yrsold<-0#
	  	strmnth<-min(MM1985)#
	  	strmid<-strmnth/12+1/24+yrsold#
	  	endmid<-strmid+1#
	  	mm2=(mmval/12)+1/24+yrsold#
	  	t<-seq(0,1,0.01)#
		g<-K0+T0*cos(2*pi*t)+T1*sin(2*pi*t)#
		Isneg<-min(g)#
		Isneg2<-max(g)#
	 	if (Isneg<0&Isneg2>0)#
	  		{#
	    	a=T0^2+T1^2#
			b=2*K0*T0#
			c=-(T1^2)+K0^2#
			u1=(-b+sqrt(b^2-4*a*c))/(2*a)#
			u2=(-b-sqrt(b^2-4*a*c))/(2*a)#
			r11=1-acos(u1)/(2*pi)#
			r12=acos(u1)/(2*pi)#
			r21=1-acos(u2)/(2*pi)#
			r22=acos(u2)/(2*pi)#
			roots<-c(r11, r12, r21, r22)#
			groot<-K0+T0*cos(2*pi* roots)+T1*sin(2*pi* roots)#
			gmin<-round(groot)#
			r1<-min(roots[which(gmin==0)])#
			r2<-max(roots[which(gmin==0)])#
	    	#Regime#
	    	#Those less than r1#
	    		if (mm2<r1) {KK = K0*(mm2-strmid) +   (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}#
	    		#Those between r1 and r2#
	    		if (mm2>r1&mm2<r2) {KK=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))}#
	    		#Those after r2#
	    		if (mm2>r2)#
	    			{#
	    			zMid=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    			zEnd=K0*(mm2-r2)     + (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*r2))     - (T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*r2))#
	    			KK<-zEnd+zMid#
	    			}#
	  	} else {KK=K0*(mm2-strmid)+(T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}	#
	print(KK)#
	  if (MMLIST[mm]==min(MM1985))  {M01} else if (MMLIST[mm]==min(MM1986)) {M02} else if (MMLIST[mm]>min(MM1985)&MMLIST[mm]<min(MM1986)) {M01 + (LINF-M01)*(1-exp(-KK))} else {M02 + (LINF-M02)*(1-exp(-KK))}#
	}#
	#INITIALISE THE TAU's which are the inclusion probablities to all be a third#
	TAU <- list()#
	for (mm in 1:(MON))#
		{#
	  		TAU[[mm]] <- matrix(1/3,NN,3)#
		}#
	#INITIALISE THE AUXILLARY STORAGE ARRAYS FOR INSIDE LOOP ASSIGNMENT#
	MU2A_AUX <- c()#
	MUA_AUX <- c()#
	MUJ_AUX <- c()#
	for (mm in 1:MON)#
		{#
	 	MU2A_AUX[mm] <- MU2A(mm,K0,T0,T1,LINF,M01,M02)#
	  	MUA_AUX[mm] <- MUA(mm,K0,T0,T1,LINF,M01,M02)#
	 	MUJ_AUX[mm] <- MUJ(mm,K0,T0,T1,LINF,M01,M02)#
		}#
	#INITIALISE THE VARIANCE FUNCTIONS. THEY ARE ALL QUADRATIC FUNCTIONS OF THE MEAN FOR EACH COHORT#
	VARJ <- function(mm,VV,K0,T0,T1,LINF,M01,M02)#
		{#
			#max(exp(VV[1])+VV[2]*MUJ(mm,K0,T0,T1,LINF,M01,M02)+VV[3]*MUJ(mm,K0,T0,T1,LINF,M01,M02)^2,1)#
			#Try a heavy tailed function like the Weibull for more flexibility#
			mu=MUJ(mm,K0,T0,T1,LINF,M01,M02)#
			#max(exp(VV[1])*dlnorm(mu,VV[2],VV[3]),1)#
			max(VV[1]*mu*exp(-VV[2]*mu)+exp(VV[3]*(1-exp(-VV[4]*mu))),1)#
		}#
	VARA <- function(mm,VV,K0,T0,T1,LINF,M01,M02)#
		{#
			#max(exp(VV[1])+VV[2]*MUA(mm,K0,T0,T1,LINF,M01,M02)+VV[3]*MUA(mm,K0,T0,T1,LINF,M01,M02)^2,1)#
			#Try a heavy tailed function like the Weibull for more flexibility#
			mu=MUA(mm,K0,T0,T1,LINF,M01,M02)#
			#max(exp(VV[1])*dlnorm(mu,VV[2],VV[3]),1)#
			max(VV[1]*mu*exp(-VV[2]*mu)+exp(VV[3]*(1-exp(-VV[4]*mu))),1)#
		}#
	VAR2A <- function(mm,VV,K0,T0,T1,LINF,M01,M02)#
		{#
			#max(exp(VV[1])+VV[2]*MU2A(mm,K0,T0,T1,LINF,M01,M02)+VV[3]*MU2A(mm,K0,T0,T1,LINF,M01,M02)^2,1)#
			#Try a heavy tailed function like the Weibull for more flexibility#
			mu=MU2A(mm,K0,T0,T1,LINF,M01,M02)#
			#max(exp(VV[1])*dlnorm(mu,VV[2],VV[3]),1)#
			#max(VV[1]+(VV[2]/VV[3])*((mu/VV[3])^(VV[2]-1))*(exp(-(mu/VV[3])^VV[2])),10)#
			max(VV[1]*mu*exp(-VV[2]*mu)+exp(VV[3]*(1-exp(-VV[4]*mu))),1)#
		}#
	#INITIALISE THE LIKELIHOOD FUNCTION#
	LOGLIKE <- 0#
	for (mm in 1:MON)#
	  {#
		LL2<-LL[which(MM==MMLIST[mm])]#
		LikGrp1<-PI1[mm]*dnorm(LL2,MU2A_AUX[mm],sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp2<-PI2[mm]*dnorm(LL2,MUA_AUX[mm],sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  }#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	#THIS LOOP DOES ALL THE WORK AND INCLUDES TWO NELDER MEAD STEPS TO OPTIMISE THE NONLINEAR MEANS AND VARIANCES#
	TOL <- 10^-6#
	LOGOLD <- -Inf#
	while (LOGLIKE - LOGOLD > TOL)#
	{#
	  LOGOLD <- LOGLIKE                     #Assign the current likelihood value to the an old value so we can evaluate the update#
		#UPDATE THE TAU SCORES AND THEN CALCULATE THE PIs GIVEN THESE TAU SCORES#
		for (mm in 1:MON)#
	  	{#
	    	Top1<-PI1[mm]*dnorm(LL,MU2A_AUX[mm],sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02)))							#Calculate the inclusion probablities for group 1#
	    	Top2<-PI2[mm]*dnorm(LL,MUA_AUX[mm],sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02)))								#Calculate the inclusion probablities for group 2#
	    	Bot<- Top1 + Top2 +(1-(PI1[mm]+PI2[mm]))*dnorm(LL,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02)))  #Calculate the sum of each of the classes#
	    	TAU[[mm]][,1] <- Top1/Bot																				#Calculate the first group's tau scores#
	    	TAU[[mm]][,2] <- Top2/Bot																				#Calculate the second group's tau scores#
	   		TAU[[mm]][,3] <- 1-(TAU[[mm]][,1]+TAU[[mm]][,2])													  	#Calculate the third group's tau scores#
	    	PI1[mm] <- sum((MM==MMLIST[mm])*TAU[[mm]][,1])/sum(MM==MMLIST[mm])										#Work out the PIs for group 1#
	    	PI2[mm] <- sum((MM==MMLIST[mm])*TAU[[mm]][,2])/sum(MM==MMLIST[mm])										#Work out the PIs for group 2#
	  	}#
	  #DEFINE THE LIKELIHOOD FUNCTION OUTSIDE THE LOOP TO UPDATE THE MEANS#
	  PARA <- c(K0,T0,T1,LINF,M01,M02)#
	  OPTIFUN <- function(PARA)#
	  {#
	  	LOGLIKE <- 0#
	  		for (mm in 1:MON)#
	  			{#
				LL2<-LL[which(MM==MMLIST[mm])]#
				LikGrp1<-PI1[mm]*dnorm(LL2,MU2A(mm,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]),sqrt(VAR2A(mm,VV,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6])))#
				LikGrp2<-PI2[mm]*dnorm(LL2,MUA(mm,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]),sqrt(VARA(mm,VV,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]))) #
				LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ(mm,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]),sqrt(VARJ(mm,VV,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6])))#
				LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  			}#
		-LOGLIKE#
	  }#
	  OPTIM <- optim(PARA,OPTIFUN, control = list(maxit = 10000))														#RUN OPTIM to find the best parameters given the taus and Pis#
	  print("Did optim 1 converge?")#
	  print(OPTIM$convergence)#
	  #Assign the estimates from optim to the parameters#
	  K0 <- OPTIM$par[1]#
	  T0 <- OPTIM$par[2]#
	  T1 <- OPTIM$par[3]#
	  LINF <- OPTIM$par[4]#
	  M01 <- OPTIM$par[5]#
	  M02<-OPTIM$par[6]#
	  #Calculate the means for each group based on these new estimates#
	  MU2A_AUX <- c()#
	  MUA_AUX <- c()#
	  MUJ_AUX <- c()#
	  for (mm in 1:MON)#
	  {#
	  	#Compute the means for each month #
	    MU2A_AUX[mm] <- MU2A(mm,K0,T0,T1,LINF,M01,M02)#
	    MUA_AUX[mm] <- MUA(mm,K0,T0,T1,LINF,M01,M02)#
	    MUJ_AUX[mm] <- MUJ(mm,K0,T0,T1,LINF,M01,M02)#
	  }#
	  #OPTIMISE THE VARIANCES GIVEN THE NEW MEANS#
	  #DEFINE THE LIKELIHOOD FUNCTION OUTSIDE THE LOOP TO UPDATE THE VARIANCES #
	  PARA2 <- VV#
	  VAROPTIFUN <- function(PARA2)#
	  {#
	  LOGLIKE <- 0#
	  		for (mm in 1:MON)#
	  			{#
	  			#mm=1#
				LL2<-LL[which(MM==MMLIST[mm])]#
				LikGrp1<- PI1[mm]*dnorm(LL2,MU2A_AUX[mm],sqrt(VAR2A(mm,PARA2,K0,T0,T1,LINF,M01,M02)))#
				LikGrp2<- PI2[mm]*dnorm(LL2,MUA_AUX[mm],sqrt(VARA(mm,PARA2,K0,T0,T1,LINF,M01,M02)))#
				LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ_AUX[mm],sqrt(VARJ(mm,PARA2,K0,T0,T1,LINF,M01,M02)))#
				LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  			}#
		-LOGLIKE#
	  }#
	  OPTIM2 <- optim(PARA2,VAROPTIFUN,control = list(maxit = 10000))													#RUN OPTIM to find the best variances given the taus and Pis#
	  VV <- OPTIM2$par#
	  print("Did optim 2 converge?")#
	  print(OPTIM2$convergence)  #
	  #COMPUTE THE LIKELIHOOD GIVEN ALL THESE NICE NEW UPDATES#
	  LOGLIKE <- 0#
	  for (mm in 1:MON)#
	  {#
		LL2<-LL[which(MM==MMLIST[mm])]#
		LikGrp1<-PI1[mm]*dnorm(LL2,MU2A_AUX[mm],sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp2<-PI2[mm]*dnorm(LL2,MUA_AUX[mm],sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  }#
	  #PRINT OUT OUR NEW UPDATES FOR THE PARAMETERS AND THE LIKELIHOOD#
	  print(c(LOGLIKE,LOGLIKE-LOGOLD))#
	  print(c(PARA,PARA2))#
	  #DRAW SOME NICE REAL TIME PLOTS SO WE CAN MONITOR CONVERGENCE#
	  par(mfrow = c(3,5))#
	  XX <- 0:200#
	  xlabNam<-c("Feb., 1985","Mar., 1985","Apr., 1985","May, 1985","Jun., 1985","Jul, 1985","Aug., 1985","Feb., 1986","Mar., 1986","Apr., 1986","May, 1986")#
	  for (mm in 1:MON)#
	  {#
	    hist(LL[which(MM==MMLIST[mm])],breaks=30,prob=T,xlim=c(20,210),ylim=c(0,0.055),xlab=xlabNam[mm],ylab="",main='')#
	    lines(XX,PI1[mm]*dnorm(XX,MU2A(mm,K0,T0,T1,LINF,M01,M02),sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02))),col='red',lwd=2.5)#
	    lines(XX,PI2[mm]*dnorm(XX,MUA(mm,K0,T0,T1,LINF,M01,M02),sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02))),col='green',lwd=2.5)#
	    lines(XX,(1-(PI1[mm]+PI2[mm]))*dnorm(XX,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02))),col='blue',lwd=2.5)#
	  }#
	  XX2 <- seq(0,1,length.out=100)#
	  YY <- K0 + T0*cos(2*pi*XX2) + T1*sin(2*pi*XX2)#
	  plot(XX2,((YY+abs(YY))/2),type='l',xlab="Fraction of a year since Jan 1",ylab="k (per year)",lwd=2.5)#
	  #VV=c(3,150,100)#
	  BLAH <- 0:200#
	  var_linf= PARA2[1]*BLAH*exp(-PARA2[2]*BLAH)+exp(PARA2[3]*(1-exp(-PARA2[4]*BLAH)))#
	  plot(BLAH,var_linf,type='l',xlab="Mean length (mm)", ylab="Variance",lwd=2.5)#
	  plot(density(rnorm(1000000,PARA[4],sqrt(VV[1]*PARA[4]*exp(-VV[2]*PARA[4])+exp(VV[3]*(1-exp(-VV[4]*PARA[4])))))),xlab="Length (mm)",main="",lwd=2.5)#
	}#
PARA[4]=	179.48382782#
VV=c(29.51196695,   0.02469080, -16.11090706, 804.95058722)#
#
# Run results - 0.71423945   0.29964797   0.01721561 179.48382782  65.32154231 65.35731221  29.51196695   0.02469080 -16.11090706#
# [10] 804.95058722
###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	#Set the necessary working directories#
	#setwd("/Users/uqllloyd/Dropbox/AAUni/APhD/Blueswimmer/CrabStuff2withMMAlg/RcodesData")#
	setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_Code_Sim/BSC_R_code_best/Diff_Variance_Function")#
	#Remove any old objects#
	rm(list = ls())#
	#DATA PRELIMINARIES#
	#Read in the data set on the asymptotic males that was gathered through pots#
	LFD_bigMalesFemales<-read.table("LFD_bigMalesFem",header=T)#
	#Pull out the lengths and the dates from these data files#
	Dates1<-as.Date(LFD_bigMalesFemales$Date,"%d/%m/%y")               #
	Lengths1<-LFD_bigMalesFemales$Carapacewidth#
	#Read in the trawl data on males that contains juvenile recruitment and adults#
	LFD<-read.table("LFD")#
	#which(LFD$Sex==1)#
	#Pull out the lengths and the dates from these data files#
	Dates2<-as.Date(LFD$Date,"%d/%m/%Y")#
	Lengths2<-LFD$Carapace.width#
	#Concatenate the necessary elements from each file into a common dates and lengths array#
	Dates <- c(Dates2,Dates1)#
	Lengths <- c(Lengths2,Lengths1)#
	#Pull out the year and month information from these dates#
	YEAR <- format(Dates,'%Y')#
	MONTHS <- format(Dates,'%m')#
	#Pull out the years and months that we a re interested in i.e., those that don't contain 	recruitment#
	WHICH85JO <- which((YEAR == '1985') & (as.numeric(MONTHS) %in% (2:8)))#
	WHICH86FM <- which((YEAR == '1986') & (as.numeric(MONTHS) %in% (2:5)))#
	#INITIALISE#
	MON <- 11													#Assign how many months we would like to model#
	LL <- Lengths[c(WHICH85JO,WHICH86FM)]						#Assign the number of individuals#
	MM1985 <- as.numeric(MONTHS[WHICH85JO])-1					#Assign January to be the 0th months#
	MM1986 <- as.numeric(MONTHS[WHICH86FM])+11					#Thus January of next year will be the 12 month. Plus we do this so that we don't have to estimate yr#
	MM<-c(MM1985,MM1986)										#Concatenate these months values together#
	MMLIST <- as.numeric(names(table(MM)))						#Make a list of the months from January first i.e., January 1986 is gets assigned a 12#
	#Parameter Initialise#
	NN <- length(MM)											#Initialise the number of individuals we have#
	PI1 <- rep(1/3,MON)											#Initialise the PIs#
	PI2 <- rep(1/3,MON)											#Initialise the PIs#
	K0 <- 1														#Initialise K0 average K#
	LINF <- 200													#Initialise asym length#
	M01<-40														#Initialise first month's average length#
	M02<-40														#Initialise second month's average length#
	T0 <- 0.2														#Initialise first seasonality parameter#
	T1 <- 0.1														#Initialise second seasonality parameter#
	VV <- c(5,1/100,3,1)											   #Initialise the starting values for the variance quadratic update#
	#Setting values for drawing plots #
	#K0=0.84062808;  LINF=159.65387413; M01=58.86155838; M02=81.29860313; T0=-0.07925965; T1=0.57794716; VV=c( -4.77584147,   6.19436755  ,-0.03489903)#
	#0.84062808  -0.07925965   0.57794716 159.65387413  58.86155838  81.29860313  -4.77584147   6.19436755  -0.03489903#
	#FUNCTIONS#
	#ASYMPTOTIC MEAN FUNCTION#
	MU2A <- function(mm,K0,T0,T1,LINF,M01,M02)#
	{#
	  #mm=1#
	  mmval <- MMLIST[mm]%%12#
	  yrsold<-2#
	  strmnth<-min(MM1985)#
	  strmid<-strmnth/12+1/24+yrsold#
	  endmid<-strmid+1#
	  mm2=(mmval/12)+1/24+yrsold#
	  t<-seq(0,1,0.01)#
	  g<-K0+T0*cos(2*pi*t)+T1*sin(2*pi*t)#
	  #plot(t,g)#
	  Isneg<-min(g)#
	  Isneg2<-max(g)#
	  if (Isneg<0&Isneg2>0)#
	  {#
	    a=T0^2+T1^2#
		b=2*K0*T0#
		c=-(T1^2)+K0^2#
		u1=(-b+sqrt(b^2-4*a*c))/(2*a)#
		u2=(-b-sqrt(b^2-4*a*c))/(2*a)#
		r11=1-acos(u1)/(2*pi)+yrsold#
		r12=acos(u1)/(2*pi)+yrsold#
		r21=1-acos(u2)/(2*pi)+yrsold#
		r22=acos(u2)/(2*pi)+yrsold#
		roots<-c(r11, r12, r21, r22)#
		groot<-K0+T0*cos(2*pi* roots)+T1*sin(2*pi* roots)#
		gmin<-round(groot)#
		r1<-min(roots[which(gmin==0)])#
		r2<-max(roots[which(gmin==0)])#
	    #Regime#
		zMid1=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    zEnd1=K0*(endmid-r2) + (T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*r2)) - (T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*r2))#
	    KKyr<-yrsold*(zEnd1+zMid1)#
	    #Those less than r1#
	    if (mm2<r1) {KK = KKyr + K0*(mm2-strmid) +   (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}#
	    #Those between r1 and r2#
	    if (mm2>r1&mm2<r2) {KK= KKyr + K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))}#
	    #Those after r2#
	    if (mm2>r2)#
	    {#
	    zMid=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    zEnd=K0*(mm2-r2)     + (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*r2))     - (T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*r2))#
	    KK<-zEnd+zMid+KKyr#
	    }#
	  } else {KK=K0*(mm2-strmid)+(T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid)) + yrsold*(K0*(endmid-strmid)+(T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*strmid)) )}#
	  if (MMLIST[mm]>max(MM1985)) {M02 + (LINF-M02)*(1-exp(-KK))} else (M01 + (LINF-M01)*(1-exp(-KK)))#
	}#
	#1 YEAR OLD ADULT's MEAN FUNCTION#
	MUA <- function(mm,K0,T0,T1,LINF,M01,M02)#
	{#
	  mmval <- MMLIST[mm]%%12#
	  yrsold<-1#
	  strmnth<-min(MM1985)#
	  strmid<-strmnth/12+1/24+yrsold#
	  endmid<-strmid+1#
	  mm2=(mmval/12)+1/24+yrsold#
	  t<-seq(0,1,0.01)#
	  g<-K0+T0*cos(2*pi*t)+T1*sin(2*pi*t)#
	  Isneg<-min(g)#
	  Isneg2<-max(g)#
	  if (Isneg<0&Isneg2>0)#
	  {#
	    a=T0^2+T1^2#
		b=2*K0*T0#
		c=-(T1^2)+K0^2#
		u1=(-b+sqrt(b^2-4*a*c))/(2*a)#
		u2=(-b-sqrt(b^2-4*a*c))/(2*a)#
		r11=1-acos(u1)/(2*pi)+yrsold#
		r12=acos(u1)/(2*pi)+yrsold#
		r21=1-acos(u2)/(2*pi)+yrsold#
		r22=acos(u2)/(2*pi)+yrsold#
		roots<-c(r11, r12, r21, r22)#
		groot<-K0+T0*cos(2*pi* roots)+T1*sin(2*pi* roots)#
		gmin<-round(groot)#
		r1<-min(roots[which(gmin==0)])#
		r2<-max(roots[which(gmin==0)])#
	    #Regime#
		zMid1=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    zEnd1=K0*(endmid-r2) + (T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*r2)) - (T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*r2))#
	    KKyr<-yrsold*(zEnd1+zMid1)#
	    	#Those less than r1#
	    	if (mm2<r1) {KK = KKyr + K0*(mm2-strmid) +   (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}#
	    	#Those between r1 and r2#
	    	if (mm2>r1&mm2<r2) {KK= KKyr + K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))}#
	    	#Those after r2#
	    	if (mm2>r2)#
	    		{#
	    		zMid=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    		zEnd=K0*(mm2-r2)     + (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*r2))     - (T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*r2))#
	    		KK<-zEnd+zMid+KKyr#
	    		}#
	  } else {KK=K0*(mm2-strmid)+(T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid)) + yrsold*(K0*(endmid-strmid)+(T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*strmid)) )}#
	  if (MMLIST[mm]>max(MM1985)) {M02 + (LINF-M02)*(1-exp(-KK))} else (M01 + (LINF-M01)*(1-exp(-KK)))#
	}#
	#THE JUVENUILES MEAN FUNCTION#
	MUJ <- function(mm,K0,T0,T1,LINF,M01,M02)#
	{#
		#mm=2#
		mmval <- MMLIST[mm]%%12#
	  	yrsold<-0#
	  	strmnth<-min(MM1985)#
	  	strmid<-strmnth/12+1/24+yrsold#
	  	endmid<-strmid+1#
	  	mm2=(mmval/12)+1/24+yrsold#
	  	t<-seq(0,1,0.01)#
		g<-K0+T0*cos(2*pi*t)+T1*sin(2*pi*t)#
		Isneg<-min(g)#
		Isneg2<-max(g)#
	 	if (Isneg<0&Isneg2>0)#
	  		{#
	    	a=T0^2+T1^2#
			b=2*K0*T0#
			c=-(T1^2)+K0^2#
			u1=(-b+sqrt(b^2-4*a*c))/(2*a)#
			u2=(-b-sqrt(b^2-4*a*c))/(2*a)#
			r11=1-acos(u1)/(2*pi)#
			r12=acos(u1)/(2*pi)#
			r21=1-acos(u2)/(2*pi)#
			r22=acos(u2)/(2*pi)#
			roots<-c(r11, r12, r21, r22)#
			groot<-K0+T0*cos(2*pi* roots)+T1*sin(2*pi* roots)#
			gmin<-round(groot)#
			r1<-min(roots[which(gmin==0)])#
			r2<-max(roots[which(gmin==0)])#
	    	#Regime#
	    	#Those less than r1#
	    		if (mm2<r1) {KK = K0*(mm2-strmid) +   (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}#
	    		#Those between r1 and r2#
	    		if (mm2>r1&mm2<r2) {KK=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))}#
	    		#Those after r2#
	    		if (mm2>r2)#
	    			{#
	    			zMid=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    			zEnd=K0*(mm2-r2)     + (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*r2))     - (T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*r2))#
	    			KK<-zEnd+zMid#
	    			}#
	  	} else {KK=K0*(mm2-strmid)+(T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}	#
	// print(KK)#
	  if (MMLIST[mm]==min(MM1985))  {M01} else if (MMLIST[mm]==min(MM1986)) {M02} else if (MMLIST[mm]>min(MM1985)&MMLIST[mm]<min(MM1986)) {M01 + (LINF-M01)*(1-exp(-KK))} else {M02 + (LINF-M02)*(1-exp(-KK))}#
	}#
	#INITIALISE THE TAU's which are the inclusion probablities to all be a third#
	TAU <- list()#
	for (mm in 1:(MON))#
		{#
	  		TAU[[mm]] <- matrix(1/3,NN,3)#
		}#
	#INITIALISE THE AUXILLARY STORAGE ARRAYS FOR INSIDE LOOP ASSIGNMENT#
	MU2A_AUX <- c()#
	MUA_AUX <- c()#
	MUJ_AUX <- c()#
	for (mm in 1:MON)#
		{#
	 	MU2A_AUX[mm] <- MU2A(mm,K0,T0,T1,LINF,M01,M02)#
	  	MUA_AUX[mm] <- MUA(mm,K0,T0,T1,LINF,M01,M02)#
	 	MUJ_AUX[mm] <- MUJ(mm,K0,T0,T1,LINF,M01,M02)#
		}#
	#INITIALISE THE VARIANCE FUNCTIONS. THEY ARE ALL QUADRATIC FUNCTIONS OF THE MEAN FOR EACH COHORT#
	VARJ <- function(mm,VV,K0,T0,T1,LINF,M01,M02)#
		{#
			#max(exp(VV[1])+VV[2]*MUJ(mm,K0,T0,T1,LINF,M01,M02)+VV[3]*MUJ(mm,K0,T0,T1,LINF,M01,M02)^2,1)#
			#Try a heavy tailed function like the Weibull for more flexibility#
			mu=MUJ(mm,K0,T0,T1,LINF,M01,M02)#
			#max(exp(VV[1])*dlnorm(mu,VV[2],VV[3]),1)#
			max(VV[1]*mu*exp(-VV[2]*mu)+exp(VV[3]*(1-exp(-VV[4]*mu))),1)#
		}#
	VARA <- function(mm,VV,K0,T0,T1,LINF,M01,M02)#
		{#
			#max(exp(VV[1])+VV[2]*MUA(mm,K0,T0,T1,LINF,M01,M02)+VV[3]*MUA(mm,K0,T0,T1,LINF,M01,M02)^2,1)#
			#Try a heavy tailed function like the Weibull for more flexibility#
			mu=MUA(mm,K0,T0,T1,LINF,M01,M02)#
			#max(exp(VV[1])*dlnorm(mu,VV[2],VV[3]),1)#
			max(VV[1]*mu*exp(-VV[2]*mu)+exp(VV[3]*(1-exp(-VV[4]*mu))),1)#
		}#
	VAR2A <- function(mm,VV,K0,T0,T1,LINF,M01,M02)#
		{#
			#max(exp(VV[1])+VV[2]*MU2A(mm,K0,T0,T1,LINF,M01,M02)+VV[3]*MU2A(mm,K0,T0,T1,LINF,M01,M02)^2,1)#
			#Try a heavy tailed function like the Weibull for more flexibility#
			mu=MU2A(mm,K0,T0,T1,LINF,M01,M02)#
			#max(exp(VV[1])*dlnorm(mu,VV[2],VV[3]),1)#
			#max(VV[1]+(VV[2]/VV[3])*((mu/VV[3])^(VV[2]-1))*(exp(-(mu/VV[3])^VV[2])),10)#
			max(VV[1]*mu*exp(-VV[2]*mu)+exp(VV[3]*(1-exp(-VV[4]*mu))),1)#
		}#
	#INITIALISE THE LIKELIHOOD FUNCTION#
	LOGLIKE <- 0#
	for (mm in 1:MON)#
	  {#
		LL2<-LL[which(MM==MMLIST[mm])]#
		LikGrp1<-PI1[mm]*dnorm(LL2,MU2A_AUX[mm],sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp2<-PI2[mm]*dnorm(LL2,MUA_AUX[mm],sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  }#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	#THIS LOOP DOES ALL THE WORK AND INCLUDES TWO NELDER MEAD STEPS TO OPTIMISE THE NONLINEAR MEANS AND VARIANCES#
	TOL <- 10^-6#
	LOGOLD <- -Inf#
	while (LOGLIKE - LOGOLD > TOL)#
	{#
	  LOGOLD <- LOGLIKE                     #Assign the current likelihood value to the an old value so we can evaluate the update#
		#UPDATE THE TAU SCORES AND THEN CALCULATE THE PIs GIVEN THESE TAU SCORES#
		for (mm in 1:MON)#
	  	{#
	    	Top1<-PI1[mm]*dnorm(LL,MU2A_AUX[mm],sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02)))							#Calculate the inclusion probablities for group 1#
	    	Top2<-PI2[mm]*dnorm(LL,MUA_AUX[mm],sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02)))								#Calculate the inclusion probablities for group 2#
	    	Bot<- Top1 + Top2 +(1-(PI1[mm]+PI2[mm]))*dnorm(LL,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02)))  #Calculate the sum of each of the classes#
	    	TAU[[mm]][,1] <- Top1/Bot																				#Calculate the first group's tau scores#
	    	TAU[[mm]][,2] <- Top2/Bot																				#Calculate the second group's tau scores#
	   		TAU[[mm]][,3] <- 1-(TAU[[mm]][,1]+TAU[[mm]][,2])													  	#Calculate the third group's tau scores#
	    	PI1[mm] <- sum((MM==MMLIST[mm])*TAU[[mm]][,1])/sum(MM==MMLIST[mm])										#Work out the PIs for group 1#
	    	PI2[mm] <- sum((MM==MMLIST[mm])*TAU[[mm]][,2])/sum(MM==MMLIST[mm])										#Work out the PIs for group 2#
	  	}#
	  #DEFINE THE LIKELIHOOD FUNCTION OUTSIDE THE LOOP TO UPDATE THE MEANS#
	  PARA <- c(K0,T0,T1,LINF,M01,M02)#
	  OPTIFUN <- function(PARA)#
	  {#
	  	LOGLIKE <- 0#
	  		for (mm in 1:MON)#
	  			{#
				LL2<-LL[which(MM==MMLIST[mm])]#
				LikGrp1<-PI1[mm]*dnorm(LL2,MU2A(mm,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]),sqrt(VAR2A(mm,VV,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6])))#
				LikGrp2<-PI2[mm]*dnorm(LL2,MUA(mm,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]),sqrt(VARA(mm,VV,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]))) #
				LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ(mm,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]),sqrt(VARJ(mm,VV,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6])))#
				LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  			}#
		-LOGLIKE#
	  }#
	  OPTIM <- optim(PARA,OPTIFUN, control = list(maxit = 10000))														#RUN OPTIM to find the best parameters given the taus and Pis#
	  print("Did optim 1 converge?")#
	  print(OPTIM$convergence)#
	  #Assign the estimates from optim to the parameters#
	  K0 <- OPTIM$par[1]#
	  T0 <- OPTIM$par[2]#
	  T1 <- OPTIM$par[3]#
	  LINF <- OPTIM$par[4]#
	  M01 <- OPTIM$par[5]#
	  M02<-OPTIM$par[6]#
	  #Calculate the means for each group based on these new estimates#
	  MU2A_AUX <- c()#
	  MUA_AUX <- c()#
	  MUJ_AUX <- c()#
	  for (mm in 1:MON)#
	  {#
	  	#Compute the means for each month #
	    MU2A_AUX[mm] <- MU2A(mm,K0,T0,T1,LINF,M01,M02)#
	    MUA_AUX[mm] <- MUA(mm,K0,T0,T1,LINF,M01,M02)#
	    MUJ_AUX[mm] <- MUJ(mm,K0,T0,T1,LINF,M01,M02)#
	  }#
	  #OPTIMISE THE VARIANCES GIVEN THE NEW MEANS#
	  #DEFINE THE LIKELIHOOD FUNCTION OUTSIDE THE LOOP TO UPDATE THE VARIANCES #
	  PARA2 <- VV#
	  VAROPTIFUN <- function(PARA2)#
	  {#
	  LOGLIKE <- 0#
	  		for (mm in 1:MON)#
	  			{#
	  			#mm=1#
				LL2<-LL[which(MM==MMLIST[mm])]#
				LikGrp1<- PI1[mm]*dnorm(LL2,MU2A_AUX[mm],sqrt(VAR2A(mm,PARA2,K0,T0,T1,LINF,M01,M02)))#
				LikGrp2<- PI2[mm]*dnorm(LL2,MUA_AUX[mm],sqrt(VARA(mm,PARA2,K0,T0,T1,LINF,M01,M02)))#
				LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ_AUX[mm],sqrt(VARJ(mm,PARA2,K0,T0,T1,LINF,M01,M02)))#
				LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  			}#
		-LOGLIKE#
	  }#
	  OPTIM2 <- optim(PARA2,VAROPTIFUN,control = list(maxit = 10000))													#RUN OPTIM to find the best variances given the taus and Pis#
	  VV <- OPTIM2$par#
	  print("Did optim 2 converge?")#
	  print(OPTIM2$convergence)  #
	  #COMPUTE THE LIKELIHOOD GIVEN ALL THESE NICE NEW UPDATES#
	  LOGLIKE <- 0#
	  for (mm in 1:MON)#
	  {#
		LL2<-LL[which(MM==MMLIST[mm])]#
		LikGrp1<-PI1[mm]*dnorm(LL2,MU2A_AUX[mm],sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp2<-PI2[mm]*dnorm(LL2,MUA_AUX[mm],sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  }#
	  #PRINT OUT OUR NEW UPDATES FOR THE PARAMETERS AND THE LIKELIHOOD#
	  print(c(LOGLIKE,LOGLIKE-LOGOLD))#
	  print(c(PARA,PARA2))#
	  #DRAW SOME NICE REAL TIME PLOTS SO WE CAN MONITOR CONVERGENCE#
	  par(mfrow = c(3,5))#
	  XX <- 0:200#
	  xlabNam<-c("Feb., 1985","Mar., 1985","Apr., 1985","May, 1985","Jun., 1985","Jul, 1985","Aug., 1985","Feb., 1986","Mar., 1986","Apr., 1986","May, 1986")#
	  for (mm in 1:MON)#
	  {#
	    hist(LL[which(MM==MMLIST[mm])],breaks=30,prob=T,xlim=c(20,210),ylim=c(0,0.055),xlab=xlabNam[mm],ylab="",main='')#
	    lines(XX,PI1[mm]*dnorm(XX,MU2A(mm,K0,T0,T1,LINF,M01,M02),sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02))),col='red',lwd=2.5)#
	    lines(XX,PI2[mm]*dnorm(XX,MUA(mm,K0,T0,T1,LINF,M01,M02),sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02))),col='green',lwd=2.5)#
	    lines(XX,(1-(PI1[mm]+PI2[mm]))*dnorm(XX,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02))),col='blue',lwd=2.5)#
	  }#
	  XX2 <- seq(0,1,length.out=100)#
	  YY <- K0 + T0*cos(2*pi*XX2) + T1*sin(2*pi*XX2)#
	  plot(XX2,((YY+abs(YY))/2),type='l',xlab="Fraction of a year since Jan 1",ylab="k (per year)",lwd=2.5)#
	  #VV=c(3,150,100)#
	  BLAH <- 0:200#
	  var_linf= PARA2[1]*BLAH*exp(-PARA2[2]*BLAH)+exp(PARA2[3]*(1-exp(-PARA2[4]*BLAH)))#
	  plot(BLAH,var_linf,type='l',xlab="Mean length (mm)", ylab="Variance",lwd=2.5)#
	  plot(density(rnorm(1000000,PARA[4],sqrt(VV[1]*PARA[4]*exp(-VV[2]*PARA[4])+exp(VV[3]*(1-exp(-VV[4]*PARA[4])))))),xlab="Length (mm)",main="",lwd=2.5)#
	}#
PARA[4]=	179.48382782#
VV=c(29.51196695,   0.02469080, -16.11090706, 804.95058722)#
#
# Run results - 0.71423945   0.29964797   0.01721561 179.48382782  65.32154231 65.35731221  29.51196695   0.02469080 -16.11090706#
# [10] 804.95058722
###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	#Set the necessary working directories#
	#setwd("/Users/uqllloyd/Dropbox/AAUni/APhD/Blueswimmer/CrabStuff2withMMAlg/RcodesData")#
	setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_Code_Sim/BSC_R_code_best/Diff_Variance_Function")#
	#Remove any old objects#
	rm(list = ls())#
	#DATA PRELIMINARIES#
	#Read in the data set on the asymptotic males that was gathered through pots#
	LFD_bigMalesFemales<-read.table("LFD_bigMalesFem",header=T)#
	#Pull out the lengths and the dates from these data files#
	Dates1<-as.Date(LFD_bigMalesFemales$Date,"%d/%m/%y")               #
	Lengths1<-LFD_bigMalesFemales$Carapacewidth#
	#Read in the trawl data on males that contains juvenile recruitment and adults#
	LFD<-read.table("LFD")#
	#which(LFD$Sex==1)#
	#Pull out the lengths and the dates from these data files#
	Dates2<-as.Date(LFD$Date,"%d/%m/%Y")#
	Lengths2<-LFD$Carapace.width#
	#Concatenate the necessary elements from each file into a common dates and lengths array#
	Dates <- c(Dates2,Dates1)#
	Lengths <- c(Lengths2,Lengths1)#
	#Pull out the year and month information from these dates#
	YEAR <- format(Dates,'%Y')#
	MONTHS <- format(Dates,'%m')#
	#Pull out the years and months that we a re interested in i.e., those that don't contain 	recruitment#
	WHICH85JO <- which((YEAR == '1985') & (as.numeric(MONTHS) %in% (2:8)))#
	WHICH86FM <- which((YEAR == '1986') & (as.numeric(MONTHS) %in% (2:5)))#
	#INITIALISE#
	MON <- 11													#Assign how many months we would like to model#
	LL <- Lengths[c(WHICH85JO,WHICH86FM)]						#Assign the number of individuals#
	MM1985 <- as.numeric(MONTHS[WHICH85JO])-1					#Assign January to be the 0th months#
	MM1986 <- as.numeric(MONTHS[WHICH86FM])+11					#Thus January of next year will be the 12 month. Plus we do this so that we don't have to estimate yr#
	MM<-c(MM1985,MM1986)										#Concatenate these months values together#
	MMLIST <- as.numeric(names(table(MM)))						#Make a list of the months from January first i.e., January 1986 is gets assigned a 12#
	#Parameter Initialise#
	NN <- length(MM)											#Initialise the number of individuals we have#
	PI1 <- rep(1/3,MON)											#Initialise the PIs#
	PI2 <- rep(1/3,MON)											#Initialise the PIs#
	K0 <- 1														#Initialise K0 average K#
	LINF <- 200													#Initialise asym length#
	M01<-40														#Initialise first month's average length#
	M02<-40														#Initialise second month's average length#
	T0 <- 0.2														#Initialise first seasonality parameter#
	T1 <- 0.1														#Initialise second seasonality parameter#
	VV <- c(5,1/100,3,1)											   #Initialise the starting values for the variance quadratic update#
	#Setting values for drawing plots #
	#K0=0.84062808;  LINF=159.65387413; M01=58.86155838; M02=81.29860313; T0=-0.07925965; T1=0.57794716; VV=c( -4.77584147,   6.19436755  ,-0.03489903)#
	#0.84062808  -0.07925965   0.57794716 159.65387413  58.86155838  81.29860313  -4.77584147   6.19436755  -0.03489903#
	#FUNCTIONS#
	#ASYMPTOTIC MEAN FUNCTION#
	MU2A <- function(mm,K0,T0,T1,LINF,M01,M02)#
	{#
	  #mm=1#
	  mmval <- MMLIST[mm]%%12#
	  yrsold<-2#
	  strmnth<-min(MM1985)#
	  strmid<-strmnth/12+1/24+yrsold#
	  endmid<-strmid+1#
	  mm2=(mmval/12)+1/24+yrsold#
	  t<-seq(0,1,0.01)#
	  g<-K0+T0*cos(2*pi*t)+T1*sin(2*pi*t)#
	  #plot(t,g)#
	  Isneg<-min(g)#
	  Isneg2<-max(g)#
	  if (Isneg<0&Isneg2>0)#
	  {#
	    a=T0^2+T1^2#
		b=2*K0*T0#
		c=-(T1^2)+K0^2#
		u1=(-b+sqrt(b^2-4*a*c))/(2*a)#
		u2=(-b-sqrt(b^2-4*a*c))/(2*a)#
		r11=1-acos(u1)/(2*pi)+yrsold#
		r12=acos(u1)/(2*pi)+yrsold#
		r21=1-acos(u2)/(2*pi)+yrsold#
		r22=acos(u2)/(2*pi)+yrsold#
		roots<-c(r11, r12, r21, r22)#
		groot<-K0+T0*cos(2*pi* roots)+T1*sin(2*pi* roots)#
		gmin<-round(groot)#
		r1<-min(roots[which(gmin==0)])#
		r2<-max(roots[which(gmin==0)])#
	    #Regime#
		zMid1=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    zEnd1=K0*(endmid-r2) + (T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*r2)) - (T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*r2))#
	    KKyr<-yrsold*(zEnd1+zMid1)#
	    #Those less than r1#
	    if (mm2<r1) {KK = KKyr + K0*(mm2-strmid) +   (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}#
	    #Those between r1 and r2#
	    if (mm2>r1&mm2<r2) {KK= KKyr + K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))}#
	    #Those after r2#
	    if (mm2>r2)#
	    {#
	    zMid=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    zEnd=K0*(mm2-r2)     + (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*r2))     - (T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*r2))#
	    KK<-zEnd+zMid+KKyr#
	    }#
	  } else {KK=K0*(mm2-strmid)+(T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid)) + yrsold*(K0*(endmid-strmid)+(T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*strmid)) )}#
	  if (MMLIST[mm]>max(MM1985)) {M02 + (LINF-M02)*(1-exp(-KK))} else (M01 + (LINF-M01)*(1-exp(-KK)))#
	}#
	#1 YEAR OLD ADULT's MEAN FUNCTION#
	MUA <- function(mm,K0,T0,T1,LINF,M01,M02)#
	{#
	  mmval <- MMLIST[mm]%%12#
	  yrsold<-1#
	  strmnth<-min(MM1985)#
	  strmid<-strmnth/12+1/24+yrsold#
	  endmid<-strmid+1#
	  mm2=(mmval/12)+1/24+yrsold#
	  t<-seq(0,1,0.01)#
	  g<-K0+T0*cos(2*pi*t)+T1*sin(2*pi*t)#
	  Isneg<-min(g)#
	  Isneg2<-max(g)#
	  if (Isneg<0&Isneg2>0)#
	  {#
	    a=T0^2+T1^2#
		b=2*K0*T0#
		c=-(T1^2)+K0^2#
		u1=(-b+sqrt(b^2-4*a*c))/(2*a)#
		u2=(-b-sqrt(b^2-4*a*c))/(2*a)#
		r11=1-acos(u1)/(2*pi)+yrsold#
		r12=acos(u1)/(2*pi)+yrsold#
		r21=1-acos(u2)/(2*pi)+yrsold#
		r22=acos(u2)/(2*pi)+yrsold#
		roots<-c(r11, r12, r21, r22)#
		groot<-K0+T0*cos(2*pi* roots)+T1*sin(2*pi* roots)#
		gmin<-round(groot)#
		r1<-min(roots[which(gmin==0)])#
		r2<-max(roots[which(gmin==0)])#
	    #Regime#
		zMid1=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    zEnd1=K0*(endmid-r2) + (T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*r2)) - (T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*r2))#
	    KKyr<-yrsold*(zEnd1+zMid1)#
	    	#Those less than r1#
	    	if (mm2<r1) {KK = KKyr + K0*(mm2-strmid) +   (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}#
	    	#Those between r1 and r2#
	    	if (mm2>r1&mm2<r2) {KK= KKyr + K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))}#
	    	#Those after r2#
	    	if (mm2>r2)#
	    		{#
	    		zMid=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    		zEnd=K0*(mm2-r2)     + (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*r2))     - (T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*r2))#
	    		KK<-zEnd+zMid+KKyr#
	    		}#
	  } else {KK=K0*(mm2-strmid)+(T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid)) + yrsold*(K0*(endmid-strmid)+(T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*strmid)) )}#
	  if (MMLIST[mm]>max(MM1985)) {M02 + (LINF-M02)*(1-exp(-KK))} else (M01 + (LINF-M01)*(1-exp(-KK)))#
	}#
	#THE JUVENUILES MEAN FUNCTION#
	MUJ <- function(mm,K0,T0,T1,LINF,M01,M02)#
	{#
		#mm=2#
		mmval <- MMLIST[mm]%%12#
	  	yrsold<-0#
	  	strmnth<-min(MM1985)#
	  	strmid<-strmnth/12+1/24+yrsold#
	  	endmid<-strmid+1#
	  	mm2=(mmval/12)+1/24+yrsold#
	  	t<-seq(0,1,0.01)#
		g<-K0+T0*cos(2*pi*t)+T1*sin(2*pi*t)#
		Isneg<-min(g)#
		Isneg2<-max(g)#
	 	if (Isneg<0&Isneg2>0)#
	  		{#
	    	a=T0^2+T1^2#
			b=2*K0*T0#
			c=-(T1^2)+K0^2#
			u1=(-b+sqrt(b^2-4*a*c))/(2*a)#
			u2=(-b-sqrt(b^2-4*a*c))/(2*a)#
			r11=1-acos(u1)/(2*pi)#
			r12=acos(u1)/(2*pi)#
			r21=1-acos(u2)/(2*pi)#
			r22=acos(u2)/(2*pi)#
			roots<-c(r11, r12, r21, r22)#
			groot<-K0+T0*cos(2*pi* roots)+T1*sin(2*pi* roots)#
			gmin<-round(groot)#
			r1<-min(roots[which(gmin==0)])#
			r2<-max(roots[which(gmin==0)])#
	    	#Regime#
	    	#Those less than r1#
	    		if (mm2<r1) {KK = K0*(mm2-strmid) +   (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}#
	    		#Those between r1 and r2#
	    		if (mm2>r1&mm2<r2) {KK=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))}#
	    		#Those after r2#
	    		if (mm2>r2)#
	    			{#
	    			zMid=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    			zEnd=K0*(mm2-r2)     + (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*r2))     - (T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*r2))#
	    			KK<-zEnd+zMid#
	    			}#
	  	} else {KK=K0*(mm2-strmid)+(T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}	#
	# print(KK)#
	  if (MMLIST[mm]==min(MM1985))  {M01} else if (MMLIST[mm]==min(MM1986)) {M02} else if (MMLIST[mm]>min(MM1985)&MMLIST[mm]<min(MM1986)) {M01 + (LINF-M01)*(1-exp(-KK))} else {M02 + (LINF-M02)*(1-exp(-KK))}#
	}#
	#INITIALISE THE TAU's which are the inclusion probablities to all be a third#
	TAU <- list()#
	for (mm in 1:(MON))#
		{#
	  		TAU[[mm]] <- matrix(1/3,NN,3)#
		}#
	#INITIALISE THE AUXILLARY STORAGE ARRAYS FOR INSIDE LOOP ASSIGNMENT#
	MU2A_AUX <- c()#
	MUA_AUX <- c()#
	MUJ_AUX <- c()#
	for (mm in 1:MON)#
		{#
	 	MU2A_AUX[mm] <- MU2A(mm,K0,T0,T1,LINF,M01,M02)#
	  	MUA_AUX[mm] <- MUA(mm,K0,T0,T1,LINF,M01,M02)#
	 	MUJ_AUX[mm] <- MUJ(mm,K0,T0,T1,LINF,M01,M02)#
		}#
	#INITIALISE THE VARIANCE FUNCTIONS. THEY ARE ALL QUADRATIC FUNCTIONS OF THE MEAN FOR EACH COHORT#
	VARJ <- function(mm,VV,K0,T0,T1,LINF,M01,M02)#
		{#
			#max(exp(VV[1])+VV[2]*MUJ(mm,K0,T0,T1,LINF,M01,M02)+VV[3]*MUJ(mm,K0,T0,T1,LINF,M01,M02)^2,1)#
			#Try a heavy tailed function like the Weibull for more flexibility#
			mu=MUJ(mm,K0,T0,T1,LINF,M01,M02)#
			#max(exp(VV[1])*dlnorm(mu,VV[2],VV[3]),1)#
			max(VV[1]*mu*exp(-VV[2]*mu)+exp(VV[3]*(1-exp(-VV[4]*mu))),1)#
		}#
	VARA <- function(mm,VV,K0,T0,T1,LINF,M01,M02)#
		{#
			#max(exp(VV[1])+VV[2]*MUA(mm,K0,T0,T1,LINF,M01,M02)+VV[3]*MUA(mm,K0,T0,T1,LINF,M01,M02)^2,1)#
			#Try a heavy tailed function like the Weibull for more flexibility#
			mu=MUA(mm,K0,T0,T1,LINF,M01,M02)#
			#max(exp(VV[1])*dlnorm(mu,VV[2],VV[3]),1)#
			max(VV[1]*mu*exp(-VV[2]*mu)+exp(VV[3]*(1-exp(-VV[4]*mu))),1)#
		}#
	VAR2A <- function(mm,VV,K0,T0,T1,LINF,M01,M02)#
		{#
			#max(exp(VV[1])+VV[2]*MU2A(mm,K0,T0,T1,LINF,M01,M02)+VV[3]*MU2A(mm,K0,T0,T1,LINF,M01,M02)^2,1)#
			#Try a heavy tailed function like the Weibull for more flexibility#
			mu=MU2A(mm,K0,T0,T1,LINF,M01,M02)#
			#max(exp(VV[1])*dlnorm(mu,VV[2],VV[3]),1)#
			#max(VV[1]+(VV[2]/VV[3])*((mu/VV[3])^(VV[2]-1))*(exp(-(mu/VV[3])^VV[2])),10)#
			max(VV[1]*mu*exp(-VV[2]*mu)+exp(VV[3]*(1-exp(-VV[4]*mu))),1)#
		}#
	#INITIALISE THE LIKELIHOOD FUNCTION#
	LOGLIKE <- 0#
	for (mm in 1:MON)#
	  {#
		LL2<-LL[which(MM==MMLIST[mm])]#
		LikGrp1<-PI1[mm]*dnorm(LL2,MU2A_AUX[mm],sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp2<-PI2[mm]*dnorm(LL2,MUA_AUX[mm],sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  }#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	#THIS LOOP DOES ALL THE WORK AND INCLUDES TWO NELDER MEAD STEPS TO OPTIMISE THE NONLINEAR MEANS AND VARIANCES#
	TOL <- 10^-6#
	LOGOLD <- -Inf#
	while (LOGLIKE - LOGOLD > TOL)#
	{#
	  LOGOLD <- LOGLIKE                     #Assign the current likelihood value to the an old value so we can evaluate the update#
		#UPDATE THE TAU SCORES AND THEN CALCULATE THE PIs GIVEN THESE TAU SCORES#
		for (mm in 1:MON)#
	  	{#
	    	Top1<-PI1[mm]*dnorm(LL,MU2A_AUX[mm],sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02)))							#Calculate the inclusion probablities for group 1#
	    	Top2<-PI2[mm]*dnorm(LL,MUA_AUX[mm],sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02)))								#Calculate the inclusion probablities for group 2#
	    	Bot<- Top1 + Top2 +(1-(PI1[mm]+PI2[mm]))*dnorm(LL,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02)))  #Calculate the sum of each of the classes#
	    	TAU[[mm]][,1] <- Top1/Bot																				#Calculate the first group's tau scores#
	    	TAU[[mm]][,2] <- Top2/Bot																				#Calculate the second group's tau scores#
	   		TAU[[mm]][,3] <- 1-(TAU[[mm]][,1]+TAU[[mm]][,2])													  	#Calculate the third group's tau scores#
	    	PI1[mm] <- sum((MM==MMLIST[mm])*TAU[[mm]][,1])/sum(MM==MMLIST[mm])										#Work out the PIs for group 1#
	    	PI2[mm] <- sum((MM==MMLIST[mm])*TAU[[mm]][,2])/sum(MM==MMLIST[mm])										#Work out the PIs for group 2#
	  	}#
	  #DEFINE THE LIKELIHOOD FUNCTION OUTSIDE THE LOOP TO UPDATE THE MEANS#
	  PARA <- c(K0,T0,T1,LINF,M01,M02)#
	  OPTIFUN <- function(PARA)#
	  {#
	  	LOGLIKE <- 0#
	  		for (mm in 1:MON)#
	  			{#
				LL2<-LL[which(MM==MMLIST[mm])]#
				LikGrp1<-PI1[mm]*dnorm(LL2,MU2A(mm,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]),sqrt(VAR2A(mm,VV,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6])))#
				LikGrp2<-PI2[mm]*dnorm(LL2,MUA(mm,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]),sqrt(VARA(mm,VV,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]))) #
				LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ(mm,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]),sqrt(VARJ(mm,VV,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6])))#
				LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  			}#
		-LOGLIKE#
	  }#
	  OPTIM <- optim(PARA,OPTIFUN, control = list(maxit = 10000))														#RUN OPTIM to find the best parameters given the taus and Pis#
	  print("Did optim 1 converge?")#
	  print(OPTIM$convergence)#
	  #Assign the estimates from optim to the parameters#
	  K0 <- OPTIM$par[1]#
	  T0 <- OPTIM$par[2]#
	  T1 <- OPTIM$par[3]#
	  LINF <- OPTIM$par[4]#
	  M01 <- OPTIM$par[5]#
	  M02<-OPTIM$par[6]#
	  #Calculate the means for each group based on these new estimates#
	  MU2A_AUX <- c()#
	  MUA_AUX <- c()#
	  MUJ_AUX <- c()#
	  for (mm in 1:MON)#
	  {#
	  	#Compute the means for each month #
	    MU2A_AUX[mm] <- MU2A(mm,K0,T0,T1,LINF,M01,M02)#
	    MUA_AUX[mm] <- MUA(mm,K0,T0,T1,LINF,M01,M02)#
	    MUJ_AUX[mm] <- MUJ(mm,K0,T0,T1,LINF,M01,M02)#
	  }#
	  #OPTIMISE THE VARIANCES GIVEN THE NEW MEANS#
	  #DEFINE THE LIKELIHOOD FUNCTION OUTSIDE THE LOOP TO UPDATE THE VARIANCES #
	  PARA2 <- VV#
	  VAROPTIFUN <- function(PARA2)#
	  {#
	  LOGLIKE <- 0#
	  		for (mm in 1:MON)#
	  			{#
	  			#mm=1#
				LL2<-LL[which(MM==MMLIST[mm])]#
				LikGrp1<- PI1[mm]*dnorm(LL2,MU2A_AUX[mm],sqrt(VAR2A(mm,PARA2,K0,T0,T1,LINF,M01,M02)))#
				LikGrp2<- PI2[mm]*dnorm(LL2,MUA_AUX[mm],sqrt(VARA(mm,PARA2,K0,T0,T1,LINF,M01,M02)))#
				LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ_AUX[mm],sqrt(VARJ(mm,PARA2,K0,T0,T1,LINF,M01,M02)))#
				LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  			}#
		-LOGLIKE#
	  }#
	  OPTIM2 <- optim(PARA2,VAROPTIFUN,control = list(maxit = 10000))													#RUN OPTIM to find the best variances given the taus and Pis#
	  VV <- OPTIM2$par#
	  print("Did optim 2 converge?")#
	  print(OPTIM2$convergence)  #
	  #COMPUTE THE LIKELIHOOD GIVEN ALL THESE NICE NEW UPDATES#
	  LOGLIKE <- 0#
	  for (mm in 1:MON)#
	  {#
		LL2<-LL[which(MM==MMLIST[mm])]#
		LikGrp1<-PI1[mm]*dnorm(LL2,MU2A_AUX[mm],sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp2<-PI2[mm]*dnorm(LL2,MUA_AUX[mm],sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  }#
	  #PRINT OUT OUR NEW UPDATES FOR THE PARAMETERS AND THE LIKELIHOOD#
	  print(c(LOGLIKE,LOGLIKE-LOGOLD))#
	  print(c(PARA,PARA2))#
	  #DRAW SOME NICE REAL TIME PLOTS SO WE CAN MONITOR CONVERGENCE#
	  par(mfrow = c(3,5))#
	  XX <- 0:200#
	  xlabNam<-c("Feb., 1985","Mar., 1985","Apr., 1985","May, 1985","Jun., 1985","Jul, 1985","Aug., 1985","Feb., 1986","Mar., 1986","Apr., 1986","May, 1986")#
	  for (mm in 1:MON)#
	  {#
	    hist(LL[which(MM==MMLIST[mm])],breaks=30,prob=T,xlim=c(20,210),ylim=c(0,0.055),xlab=xlabNam[mm],ylab="",main='')#
	    lines(XX,PI1[mm]*dnorm(XX,MU2A(mm,K0,T0,T1,LINF,M01,M02),sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02))),col='red',lwd=2.5)#
	    lines(XX,PI2[mm]*dnorm(XX,MUA(mm,K0,T0,T1,LINF,M01,M02),sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02))),col='green',lwd=2.5)#
	    lines(XX,(1-(PI1[mm]+PI2[mm]))*dnorm(XX,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02))),col='blue',lwd=2.5)#
	  }#
	  XX2 <- seq(0,1,length.out=100)#
	  YY <- K0 + T0*cos(2*pi*XX2) + T1*sin(2*pi*XX2)#
	  plot(XX2,((YY+abs(YY))/2),type='l',xlab="Fraction of a year since Jan 1",ylab="k (per year)",lwd=2.5)#
	  #VV=c(3,150,100)#
	  BLAH <- 0:200#
	  var_linf= PARA2[1]*BLAH*exp(-PARA2[2]*BLAH)+exp(PARA2[3]*(1-exp(-PARA2[4]*BLAH)))#
	  plot(BLAH,var_linf,type='l',xlab="Mean length (mm)", ylab="Variance",lwd=2.5)#
	  plot(density(rnorm(1000000,PARA[4],sqrt(VV[1]*PARA[4]*exp(-VV[2]*PARA[4])+exp(VV[3]*(1-exp(-VV[4]*PARA[4])))))),xlab="Length (mm)",main="",lwd=2.5)#
	}#
PARA[4]=	179.48382782#
VV=c(29.51196695,   0.02469080, -16.11090706, 804.95058722)#
#
# Run results - 0.71423945   0.29964797   0.01721561 179.48382782  65.32154231 65.35731221  29.51196695   0.02469080 -16.11090706#
# [10] 804.95058722
# Function to optimise means using optim#
# --------------------------------------#
MeanVarOptim <- function(pars) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  pars: Vector containing the parameters to optimise#
  #    k0:        Mean  k paramter for VB model#
  #    theta.1:   Seasonality parameter 1#
  #    theta.2:   Seasonality parameter 1#
  #    linf:      Asymptotic length#
  #    mu.yr.1:   First month's average length yr 1#
  #    mu.yr.2:   First month's average length yr 2T0,T1,LINF,M01,M02#
  #    var.pars.x The variance parameters#
  # Returns:#
  #  The negative of the log likelihood for use in the OPTIM function#
  # Declare each of the parameters to names unique to inside the fucntion#
  k0.fun        <- pars[1]#
  theta.1.fun   <- pars[2]#
  theta.2.fun   <- pars[3]#
  linf.fun      <- pars[4]#
  mu.yr.1.fun   <- pars[5]#
  mu.yr.2.fun   <- pars[6]#
  var.par.1.fun <- pars[7]#
  var.par.2.fun <- pars[8]#
  var.par.3.fun <- pars[9]#
  var.par.4.fun <- pars[10]#
#
  # It seems bad but we need to define the bottom bits as global variables#
  # so that LogLikelihood can see them#
  # Calculate the means given the current update of the parameters#
  mean.2.yr <<- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 2, str.mnth = 1)       #
  mean.1.yr <<- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 1, str.mnth = 1)#
  mean.0.yr <<- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 0, str.mnth = 1)#
  # Calculate the variances given the current update of the parameters#
  var.2.yr  <<- sapply(mean.2.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.par.4.fun)#
  var.1.yr  <<- sapply(mean.1.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 =  var.par.3.fun,#
                   var.par.4 =  var.par.4.fun)#
  var.0.yr  <<- sapply(mean.0.yr, BscVar, var.par.1 =  var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.par.4.fun)#
  # Calculate the log likelihood#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
#
  print(log.like.full)#
  # Return the negative of the log likelihood#
  return(-log.like.full)#
}
optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 10000))
pars      <- optim.means.var$par
optim.means.var
pars     <- c(k0, theta.1, theta.2, linf,     # Parameters in a vector
pi.all <- sapply(num.months.seq, PiCalc)#
  pi.1   <- pi.all[1, ]#
  pi.2   <- pi.all[2, ]#
  pi.3   <- pi.all[3, ]#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  # pars            <- c(k0, theta.1, theta.2, linf, mu.yr.1, mu.yr.2, var.pars) #
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 10000))	#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  k0        <- optim.means.var$par[1]#
  theta.1   <- optim.means.var$par[2]#
  theta.2   <- optim.means.var$par[3]#
  linf      <- optim.means.var$par[4]#
  mu.yr.1   <- optim.means.var$par[5]#
  mu.yr.2   <- optim.means.var$par[6]#
  var.par.1 <- optim.means.var$par[7]#
  var.par.2 <- optim.means.var$par[8]#
  var.par.3 <- optim.means.var$par[9]#
  var.par.4 <- optim.means.var$par[10]#
  pars      <- optim.means.var$par#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Code_New")#
source("bsc_seas_integral_func.R")#
source("bsc_mean_length_func.R")#
source("bsc_seas_root_func.R")#
source("bsc_variance_func.R")#
source("bsc_log_likelihood_func.R")#
source("bsc_pi_calc_func.R")#
source("bsc_mean_var_optim_func.R")#
# Data preliminaries#
# ------------------#
#
# Set the working directories#
#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_Code_Sim/")#
setwd("BSC_R_code_best/Diff_Variance_Function/")#
# Read in the data set on the asymptotic males that was gathered through pots#
#
lfd.big.males.females <- read.table("LFD_bigMalesFem", header = T)#
# Pull out the lengths and the dates from these data files#
#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
#
lfd.trawl.males.females <- read.table("LFD")#
# Pull out the lengths and the dates from these data files#
#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# Initialise the data for the model #
# ---------------------------------#
#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
months.lst       <- as.numeric(names(table(months)))	#
num.months.seq   <- seq(1, num.months)#
#
# Initialise the parameters of the model #
# --------------------------------------#
num.inds <- length(months)                    # Number of individuals we have#
pi.1     <- rep(1/3, num.months)              # Pi mixing prop group 1#
pi.2     <- rep(1/3, num.months)              # Pi mixing prop group 2#
pi.3     <- (1- (pi.1 + pi.2))                # Pi group 3. Diff from 1#
k0       <- 1                                 # K0 average K#
linf     <- 200                               # Asym length#
mu.yr.1  <- 40                                # First month's average length yr 1#
mu.yr.2  <- 60                                # First month's average length yr 2#
theta.1  <- 1.0                               # Seasonality parameter 1#
theta.2  <- 1.0                               # Seasonality parameter 2#
var.pars <- c(5, 1/100, 3, 1)                 # Variance fun parameter vector#
pars     <- c(k0, theta.1, theta.2, linf,     # Parameters in a vector#
              mu.yr.1, mu.yr.2, var.pars) #
# Initialise the likelihood and set tolerence#
# -------------------------------------------#
#
#MeanVarOptim(pars)	#
log.like.full <- -10^5#
tol           <- 10e-6#
log.like.old  <- -10^6
log.like.old
log.like.full
log.like.full - log.like.old > tol
pi.all <- sapply(num.months.seq, PiCalc)#
  pi.1   <- pi.all[1, ]#
  pi.2   <- pi.all[2, ]#
  pi.3   <- pi.all[3, ]
PiCalc
MeanVarOptim(pars)
log.like.full <- -10^5#
tol           <- 10e-6#
log.like.old  <- -10^6
# Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
  pi.all <- sapply(num.months.seq, PiCalc)#
  pi.1   <- pi.all[1, ]#
  pi.2   <- pi.all[2, ]#
  pi.3   <- pi.all[3, ]#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  # pars            <- c(k0, theta.1, theta.2, linf, mu.yr.1, mu.yr.2, var.pars) #
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 10000))	#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  k0        <- optim.means.var$par[1]#
  theta.1   <- optim.means.var$par[2]#
  theta.2   <- optim.means.var$par[3]#
  linf      <- optim.means.var$par[4]#
  mu.yr.1   <- optim.means.var$par[5]#
  mu.yr.2   <- optim.means.var$par[6]#
  var.par.1 <- optim.means.var$par[7]#
  var.par.2 <- optim.means.var$par[8]#
  var.par.3 <- optim.means.var$par[9]#
  var.par.4 <- optim.means.var$par[10]#
  pars      <- optim.means.var$par
mean.2.yr <<- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                    theta.2 = theta.2, linf = linf , mu.yr.1 = mu.yr.1, #
                    mu.yr.2 = mu.yr.2, yrs.old = 2, str.mnth = 1)       #
  mean.1.yr <<- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                    theta.2 = theta.2, linf = linf , mu.yr.1 = mu.yr.1, #
                    mu.yr.2 = mu.yr.2, yrs.old = 1, str.mnth = 1)#
  mean.0.yr <<- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                    theta.2 = theta.2, linf = linf , mu.yr.1 = mu.yr.1, #
                    mu.yr.2 = mu.yr.2, yrs.old = 0, str.mnth = 1)
mean.2.yr <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                    theta.2 = theta.2, linf = linf , mu.yr.1 = mu.yr.1, #
                    mu.yr.2 = mu.yr.2, yrs.old = 2, str.mnth = 1)       #
  mean.1.yr <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                    theta.2 = theta.2, linf = linf , mu.yr.1 = mu.yr.1, #
                    mu.yr.2 = mu.yr.2, yrs.old = 1, str.mnth = 1)#
  mean.0.yr <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                    theta.2 = theta.2, linf = linf , mu.yr.1 = mu.yr.1, #
                    mu.yr.2 = mu.yr.2, yrs.old = 0, str.mnth = 1)#
  # Calculate the variances given the current update of the parameters#
  var.2.yr  <- sapply(mean.2.yr, BscVar, var.par.1 = var.par.1,#
                   var.par.2 = var.par.2, var.par.3 = var.par.3,#
                   var.par.4 = var.par.4)#
  var.1.yr  <- sapply(mean.1.yr, BscVar, var.par.1 = var.par.1,#
                   var.par.2 = var.par.2, var.par.3 =  var.par.3,#
                   var.par.4 =  var.par.4)#
  var.0.yr  <- sapply(mean.0.yr, BscVar, var.par.1 =  var.par.1,#
                   var.par.2 = var.par.2, var.par.3 = var.par.3,#
                   var.par.4 = var.par.4)
log.like.full <- sum(sapply(num.months.seq, LogLikelihood))
log.like.full
print(c(log.like.full, log.like.full - log.like.old))
MeanVarOptim(pars)	#
log.like.full <- -10^5#
tol           <- 10e-6#
log.like.old  <- -10^6	#
# Run while loop over procedure until convergence#
# -----------------------------------------------	#
#
while (log.like.full - log.like.old > tol) {#
#
  # Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
  pi.all <- sapply(num.months.seq, PiCalc)#
  pi.1   <- pi.all[1, ]#
  pi.2   <- pi.all[2, ]#
  pi.3   <- pi.all[3, ]#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  # pars            <- c(k0, theta.1, theta.2, linf, mu.yr.1, mu.yr.2, var.pars) #
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 10000))	#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  k0        <- optim.means.var$par[1]#
  theta.1   <- optim.means.var$par[2]#
  theta.2   <- optim.means.var$par[3]#
  linf      <- optim.means.var$par[4]#
  mu.yr.1   <- optim.means.var$par[5]#
  mu.yr.2   <- optim.means.var$par[6]#
  var.par.1 <- optim.means.var$par[7]#
  var.par.2 <- optim.means.var$par[8]#
  var.par.3 <- optim.means.var$par[9]#
  var.par.4 <- optim.means.var$par[10]#
  pars      <- optim.means.var$par#
  # Calculate the means and variances again#
  mean.2.yr <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                    theta.2 = theta.2, linf = linf , mu.yr.1 = mu.yr.1, #
                    mu.yr.2 = mu.yr.2, yrs.old = 2, str.mnth = 1)       #
  mean.1.yr <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                    theta.2 = theta.2, linf = linf , mu.yr.1 = mu.yr.1, #
                    mu.yr.2 = mu.yr.2, yrs.old = 1, str.mnth = 1)#
  mean.0.yr <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                    theta.2 = theta.2, linf = linf , mu.yr.1 = mu.yr.1, #
                    mu.yr.2 = mu.yr.2, yrs.old = 0, str.mnth = 1)#
  # Calculate the variances given the current update of the parameters#
  var.2.yr  <- sapply(mean.2.yr, BscVar, var.par.1 = var.par.1,#
                   var.par.2 = var.par.2, var.par.3 = var.par.3,#
                   var.par.4 = var.par.4)#
  var.1.yr  <- sapply(mean.1.yr, BscVar, var.par.1 = var.par.1,#
                   var.par.2 = var.par.2, var.par.3 =  var.par.3,#
                   var.par.4 =  var.par.4)#
  var.0.yr  <- sapply(mean.0.yr, BscVar, var.par.1 =  var.par.1,#
                   var.par.2 = var.par.2, var.par.3 = var.par.3,#
                   var.par.4 = var.par.4)#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars)#
}
PiCalc
################################################################################
################################################################################
################################################################################
###                                                                         ####
###     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     ####
###     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     ####
###     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     ####
###     TA SETS.                                                            ####
###                                                                         ###	#
################################################################################
################################################################################
################################################################################
#
# Remove any objects to clear the slate#
#
rm(list = ls( ))#
#
# Source the function files needed#
# --------------------------------#
#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Code_New")#
source("bsc_seas_integral_func.R")#
source("bsc_mean_length_func.R")#
source("bsc_seas_root_func.R")#
source("bsc_variance_func.R")#
source("bsc_log_likelihood_func.R")#
source("bsc_pi_calc_func.R")#
source("bsc_mean_var_optim_func.R")#
# Data preliminaries#
# ------------------#
#
# Set the working directories#
#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_Code_Sim/")#
setwd("BSC_R_code_best/Diff_Variance_Function/")#
# Read in the data set on the asymptotic males that was gathered through pots#
#
lfd.big.males.females <- read.table("LFD_bigMalesFem", header = T)#
# Pull out the lengths and the dates from these data files#
#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
#
lfd.trawl.males.females <- read.table("LFD")#
# Pull out the lengths and the dates from these data files#
#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# Initialise the data for the model #
# ---------------------------------#
#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
months.lst       <- as.numeric(names(table(months)))	#
num.months.seq   <- seq(1, num.months)#
#
# Initialise the parameters of the model #
# --------------------------------------#
num.inds <- length(months)                    # Number of individuals we have#
pi.1     <- rep(1/3, num.months)              # Pi mixing prop group 1#
pi.2     <- rep(1/3, num.months)              # Pi mixing prop group 2#
pi.3     <- (1- (pi.1 + pi.2))                # Pi group 3. Diff from 1#
k0       <- 1                                 # K0 average K#
linf     <- 200                               # Asym length#
mu.yr.1  <- 40                                # First month's average length yr 1#
mu.yr.2  <- 60                                # First month's average length yr 2#
theta.1  <- 1.0                               # Seasonality parameter 1#
theta.2  <- 1.0                               # Seasonality parameter 2#
var.pars <- c(5, 1/100, 3, 1)                 # Variance fun parameter vector#
pars     <- c(k0, theta.1, theta.2, linf,     # Parameters in a vector#
              mu.yr.1, mu.yr.2, var.pars) #
# Initialise the likelihood and set tolerence#
# -------------------------------------------#
#
MeanVarOptim(pars)	#
log.like.full <- -10^5#
tol           <- 10e-6#
log.like.old  <- -10^6	#
# Run while loop over procedure until convergence#
# -----------------------------------------------	#
#
while (log.like.full - log.like.old > tol) {#
#
  # Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
  pi.all <- sapply(num.months.seq, PiCalc)#
  pi.1   <- pi.all[1, ]#
  pi.2   <- pi.all[2, ]#
  pi.3   <- pi.all[3, ]#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  # pars            <- c(k0, theta.1, theta.2, linf, mu.yr.1, mu.yr.2, var.pars) #
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 10000))	#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  k0        <- optim.means.var$par[1]#
  theta.1   <- optim.means.var$par[2]#
  theta.2   <- optim.means.var$par[3]#
  linf      <- optim.means.var$par[4]#
  mu.yr.1   <- optim.means.var$par[5]#
  mu.yr.2   <- optim.means.var$par[6]#
  var.par.1 <- optim.means.var$par[7]#
  var.par.2 <- optim.means.var$par[8]#
  var.par.3 <- optim.means.var$par[9]#
  var.par.4 <- optim.means.var$par[10]#
  pars      <- optim.means.var$par#
  # Calculate the means and variances again#
  mean.2.yr <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                    theta.2 = theta.2, linf = linf , mu.yr.1 = mu.yr.1, #
                    mu.yr.2 = mu.yr.2, yrs.old = 2, str.mnth = 1)       #
  mean.1.yr <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                    theta.2 = theta.2, linf = linf , mu.yr.1 = mu.yr.1, #
                    mu.yr.2 = mu.yr.2, yrs.old = 1, str.mnth = 1)#
  mean.0.yr <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                    theta.2 = theta.2, linf = linf , mu.yr.1 = mu.yr.1, #
                    mu.yr.2 = mu.yr.2, yrs.old = 0, str.mnth = 1)#
  # Calculate the variances given the current update of the parameters#
  var.2.yr  <- sapply(mean.2.yr, BscVar, var.par.1 = var.par.1,#
                   var.par.2 = var.par.2, var.par.3 = var.par.3,#
                   var.par.4 = var.par.4)#
  var.1.yr  <- sapply(mean.1.yr, BscVar, var.par.1 = var.par.1,#
                   var.par.2 = var.par.2, var.par.3 =  var.par.3,#
                   var.par.4 =  var.par.4)#
  var.0.yr  <- sapply(mean.0.yr, BscVar, var.par.1 =  var.par.1,#
                   var.par.2 = var.par.2, var.par.3 = var.par.3,#
                   var.par.4 = var.par.4)#
  log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars)#
}
log.like.full
log.like.old
# Initialise the likelihood and set tolerence#
# -------------------------------------------#
#
MeanVarOptim(pars)	#
log.like.full <- -10^5#
tol           <- 10e-6#
log.like.old  <- -10^6	#
# Run while loop over procedure until convergence#
# -----------------------------------------------	#
#
while (log.like.full - log.like.old > tol) {#
#
  # Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
  pi.all <- sapply(num.months.seq, PiCalc)#
  pi.1   <- pi.all[1, ]#
  pi.2   <- pi.all[2, ]#
  pi.3   <- pi.all[3, ]#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  # pars            <- c(k0, theta.1, theta.2, linf, mu.yr.1, mu.yr.2, var.pars) #
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 10000))	#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  k0        <- optim.means.var$par[1]#
  theta.1   <- optim.means.var$par[2]#
  theta.2   <- optim.means.var$par[3]#
  linf      <- optim.means.var$par[4]#
  mu.yr.1   <- optim.means.var$par[5]#
  mu.yr.2   <- optim.means.var$par[6]#
  var.par.1 <- optim.means.var$par[7]#
  var.par.2 <- optim.means.var$par[8]#
  var.par.3 <- optim.means.var$par[9]#
  var.par.4 <- optim.means.var$par[10]#
  pars      <- optim.means.var$par#
  # # Calculate the means and variances again#
  # mean.2.yr <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                    # theta.2 = theta.2, linf = linf , mu.yr.1 = mu.yr.1, #
                    # mu.yr.2 = mu.yr.2, yrs.old = 2, str.mnth = 1)       #
  # mean.1.yr <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                    # theta.2 = theta.2, linf = linf , mu.yr.1 = mu.yr.1, #
                    # mu.yr.2 = mu.yr.2, yrs.old = 1, str.mnth = 1)#
  # mean.0.yr <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                    # theta.2 = theta.2, linf = linf , mu.yr.1 = mu.yr.1, #
                    # mu.yr.2 = mu.yr.2, yrs.old = 0, str.mnth = 1)#
  # # Calculate the variances given the current update of the parameters#
  # var.2.yr  <- sapply(mean.2.yr, BscVar, var.par.1 = var.par.1,#
                   # var.par.2 = var.par.2, var.par.3 = var.par.3,#
                   # var.par.4 = var.par.4)#
  # var.1.yr  <- sapply(mean.1.yr, BscVar, var.par.1 = var.par.1,#
                   # var.par.2 = var.par.2, var.par.3 =  var.par.3,#
                   # var.par.4 =  var.par.4)#
  # var.0.yr  <- sapply(mean.0.yr, BscVar, var.par.1 =  var.par.1,#
                   # var.par.2 = var.par.2, var.par.3 = var.par.3,#
                   # var.par.4 = var.par.4)#
  # log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars)#
}
log.like.full
# Function to optimise means using optim#
# --------------------------------------#
MeanVarOptim <- function(pars) {#
  # Calculates the log likelihood #
  ##
  # Args:#
  #  pars: Vector containing the parameters to optimise#
  #    k0:        Mean  k paramter for VB model#
  #    theta.1:   Seasonality parameter 1#
  #    theta.2:   Seasonality parameter 1#
  #    linf:      Asymptotic length#
  #    mu.yr.1:   First month's average length yr 1#
  #    mu.yr.2:   First month's average length yr 2T0,T1,LINF,M01,M02#
  #    var.pars.x The variance parameters#
  # Returns:#
  #  The negative of the log likelihood for use in the OPTIM function#
  # Declare each of the parameters to names unique to inside the fucntion#
  k0.fun        <- pars[1]#
  theta.1.fun   <- pars[2]#
  theta.2.fun   <- pars[3]#
  linf.fun      <- pars[4]#
  mu.yr.1.fun   <- pars[5]#
  mu.yr.2.fun   <- pars[6]#
  var.par.1.fun <- pars[7]#
  var.par.2.fun <- pars[8]#
  var.par.3.fun <- pars[9]#
  var.par.4.fun <- pars[10]#
#
  # It seems bad but we need to define the bottom bits as global variables#
  # so that LogLikelihood can see them#
  # Calculate the means given the current update of the parameters#
  mean.2.yr <<- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 2, str.mnth = 1)       #
  mean.1.yr <<- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 1, str.mnth = 1)#
  mean.0.yr <<- sapply(months.lst, MeanLength, k0 = k0.fun, theta.1 = theta.1.fun, #
                    theta.2 = theta.2.fun, linf = linf.fun , mu.yr.1 = mu.yr.1.fun, #
                    mu.yr.2 = mu.yr.2.fun, yrs.old = 0, str.mnth = 1)#
  # Calculate the variances given the current update of the parameters#
  var.2.yr  <<- sapply(mean.2.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.par.4.fun)#
  var.1.yr  <<- sapply(mean.1.yr, BscVar, var.par.1 = var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 =  var.par.3.fun,#
                   var.par.4 =  var.par.4.fun)#
  var.0.yr  <<- sapply(mean.0.yr, BscVar, var.par.1 =  var.par.1.fun,#
                   var.par.2 = var.par.2.fun, var.par.3 = var.par.3.fun,#
                   var.par.4 = var.par.4.fun)#
  # Calculate the log likelihood#
  log.like.full <<- sum(sapply(num.months.seq, LogLikelihood))#
#
  print(log.like.full)#
  # Return the negative of the log likelihood#
  return(-log.like.full)#
}
MeanVarOptim(pars)	#
log.like.full <- -10^5#
tol           <- 10e-6#
log.like.old  <- -10^6	#
# Run while loop over procedure until convergence#
# -----------------------------------------------	#
#
while (log.like.full - log.like.old > tol) {#
#
  # Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
  pi.all <- sapply(num.months.seq, PiCalc)#
  pi.1   <- pi.all[1, ]#
  pi.2   <- pi.all[2, ]#
  pi.3   <- pi.all[3, ]#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  # pars            <- c(k0, theta.1, theta.2, linf, mu.yr.1, mu.yr.2, var.pars) #
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 10000))	#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  k0        <- optim.means.var$par[1]#
  theta.1   <- optim.means.var$par[2]#
  theta.2   <- optim.means.var$par[3]#
  linf      <- optim.means.var$par[4]#
  mu.yr.1   <- optim.means.var$par[5]#
  mu.yr.2   <- optim.means.var$par[6]#
  var.par.1 <- optim.means.var$par[7]#
  var.par.2 <- optim.means.var$par[8]#
  var.par.3 <- optim.means.var$par[9]#
  var.par.4 <- optim.means.var$par[10]#
  pars      <- optim.means.var$par#
  # # Calculate the means and variances again#
  # mean.2.yr <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                    # theta.2 = theta.2, linf = linf , mu.yr.1 = mu.yr.1, #
                    # mu.yr.2 = mu.yr.2, yrs.old = 2, str.mnth = 1)       #
  # mean.1.yr <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                    # theta.2 = theta.2, linf = linf , mu.yr.1 = mu.yr.1, #
                    # mu.yr.2 = mu.yr.2, yrs.old = 1, str.mnth = 1)#
  # mean.0.yr <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                    # theta.2 = theta.2, linf = linf , mu.yr.1 = mu.yr.1, #
                    # mu.yr.2 = mu.yr.2, yrs.old = 0, str.mnth = 1)#
  # # Calculate the variances given the current update of the parameters#
  # var.2.yr  <- sapply(mean.2.yr, BscVar, var.par.1 = var.par.1,#
                   # var.par.2 = var.par.2, var.par.3 = var.par.3,#
                   # var.par.4 = var.par.4)#
  # var.1.yr  <- sapply(mean.1.yr, BscVar, var.par.1 = var.par.1,#
                   # var.par.2 = var.par.2, var.par.3 =  var.par.3,#
                   # var.par.4 =  var.par.4)#
  # var.0.yr  <- sapply(mean.0.yr, BscVar, var.par.1 =  var.par.1,#
                   # var.par.2 = var.par.2, var.par.3 = var.par.3,#
                   # var.par.4 = var.par.4)#
  # log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars)#
}
################################################################################
################################################################################
################################################################################
###                                                                         ####
###     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     ####
###     VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     ####
###     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     ####
###     TA SETS.                                                            ####
###                                                                         ###	#
################################################################################
################################################################################
################################################################################
#
# Remove any objects to clear the slate#
#
rm(list = ls( ))#
#
# Source the function files needed#
# --------------------------------#
#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Code_New")#
source("bsc_seas_integral_func.R")#
source("bsc_mean_length_func.R")#
source("bsc_seas_root_func.R")#
source("bsc_variance_func.R")#
source("bsc_log_likelihood_func.R")#
source("bsc_pi_calc_func.R")#
source("bsc_mean_var_optim_func.R")#
# Data preliminaries#
# ------------------#
#
# Set the working directories#
#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_Code_Sim/")#
setwd("BSC_R_code_best/Diff_Variance_Function/")#
# Read in the data set on the asymptotic males that was gathered through pots#
#
lfd.big.males.females <- read.table("LFD_bigMalesFem", header = T)#
# Pull out the lengths and the dates from these data files#
#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
#
lfd.trawl.males.females <- read.table("LFD")#
# Pull out the lengths and the dates from these data files#
#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
#
str.month.yr.1 <- 2#
end.month.yr.1 <- 8#
#
str.month.yr.2 <- 2#
end.month.yr.2 <- 5#
#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# Initialise the data for the model #
# ---------------------------------#
#
num.months       <- 11													#
lengths          <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85        <- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Jan = 0th month#
months.86        <- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months           <- c(months.85, months.86)#
months.lst       <- as.numeric(names(table(months)))	#
num.months.seq   <- seq(1, num.months)#
#
# Initialise the parameters of the model #
# --------------------------------------#
num.inds <- length(months)                    # Number of individuals we have#
pi.1     <- rep(1/3, num.months)              # Pi mixing prop group 1#
pi.2     <- rep(1/3, num.months)              # Pi mixing prop group 2#
pi.3     <- (1- (pi.1 + pi.2))                # Pi group 3. Diff from 1#
k0       <- 1                                 # K0 average K#
linf     <- 200                               # Asym length#
mu.yr.1  <- 40                                # First month's average length yr 1#
mu.yr.2  <- 60                                # First month's average length yr 2#
theta.1  <- 1.0                               # Seasonality parameter 1#
theta.2  <- 1.0                               # Seasonality parameter 2#
var.pars <- c(5, 1/100, 3, 1)                 # Variance fun parameter vector#
pars     <- c(k0, theta.1, theta.2, linf,     # Parameters in a vector#
              mu.yr.1, mu.yr.2, var.pars) #
# Initialise the likelihood and set tolerence#
# -------------------------------------------#
#
MeanVarOptim(pars)	#
log.like.full <- -10^5#
tol           <- 10e-6#
log.like.old  <- -10^6	#
# Run while loop over procedure until convergence#
# -----------------------------------------------	#
#
while (log.like.full - log.like.old > tol) {#
#
  # Shift the current likelihood to the old likelihood#
  log.like.old <- log.like.full #
  # Calculate the pi for each group in each month#
  # ---------------------------------------------#
#
  # Returns a vector of pi with each column representing a month#
  # and wach row the groups. Row 1 the largest. Row 2 the yr olds#
  # and row 3 the juveniles#
  pi.all <- sapply(num.months.seq, PiCalc)#
  pi.1   <- pi.all[1, ]#
  pi.2   <- pi.all[2, ]#
  pi.3   <- pi.all[3, ]#
  # Optimise the parameters for the means#
  # -------------------------------------#
  # Initialise and optimise#
  # pars            <- c(k0, theta.1, theta.2, linf, mu.yr.1, mu.yr.2, var.pars) #
  optim.means.var <- optim(pars, MeanVarOptim, control = list(maxit = 10000))	#
  # Ask if optim converged#
  print("Did optim converge?")#
  print(optim.means.var$convergence)#
  # Re-define the global parameters#
  k0        <- optim.means.var$par[1]#
  theta.1   <- optim.means.var$par[2]#
  theta.2   <- optim.means.var$par[3]#
  linf      <- optim.means.var$par[4]#
  mu.yr.1   <- optim.means.var$par[5]#
  mu.yr.2   <- optim.means.var$par[6]#
  var.par.1 <- optim.means.var$par[7]#
  var.par.2 <- optim.means.var$par[8]#
  var.par.3 <- optim.means.var$par[9]#
  var.par.4 <- optim.means.var$par[10]#
  pars      <- optim.means.var$par#
  # # Calculate the means and variances again#
  # mean.2.yr <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                    # theta.2 = theta.2, linf = linf , mu.yr.1 = mu.yr.1, #
                    # mu.yr.2 = mu.yr.2, yrs.old = 2, str.mnth = 1)       #
  # mean.1.yr <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                    # theta.2 = theta.2, linf = linf , mu.yr.1 = mu.yr.1, #
                    # mu.yr.2 = mu.yr.2, yrs.old = 1, str.mnth = 1)#
  # mean.0.yr <- sapply(months.lst, MeanLength, k0 = k0, theta.1 = theta.1, #
                    # theta.2 = theta.2, linf = linf , mu.yr.1 = mu.yr.1, #
                    # mu.yr.2 = mu.yr.2, yrs.old = 0, str.mnth = 1)#
  # # Calculate the variances given the current update of the parameters#
  # var.2.yr  <- sapply(mean.2.yr, BscVar, var.par.1 = var.par.1,#
                   # var.par.2 = var.par.2, var.par.3 = var.par.3,#
                   # var.par.4 = var.par.4)#
  # var.1.yr  <- sapply(mean.1.yr, BscVar, var.par.1 = var.par.1,#
                   # var.par.2 = var.par.2, var.par.3 =  var.par.3,#
                   # var.par.4 =  var.par.4)#
  # var.0.yr  <- sapply(mean.0.yr, BscVar, var.par.1 =  var.par.1,#
                   # var.par.2 = var.par.2, var.par.3 = var.par.3,#
                   # var.par.4 = var.par.4)#
  # log.like.full <- sum(sapply(num.months.seq, LogLikelihood))#
  # Print out the loglikelihood, tolerance, and parameters#
  print(c(log.like.full, log.like.full - log.like.old))#
  print(pars)#
}
