################################################################################
################################################################################
################################################################################
###                                                                         ####
###     SCRIPT TO IMPLEMENT ALGORITHM FOR SOLVING FOR GROWTH PARAMETERS     ####
###	    VIA THE METHOD OUTLINED IN LLOYD-JONES ET AL. USES AN MM ALGORI     ####
###     THM AND THE OPTIM FUNCTION TO OPTIMISE OVER LENGTH FREQUENCY DA     ####
###     TA SETS.                                                            ####
###                                                                         ###	#
################################################################################
################################################################################
################################################################################
# Remove any objects to clear the slate#
#
rm(list = ls( ))#
# Data preliminaries#
# ------------------#
# Set the working directories#
#
setwd("~/Dropbox/Git_Repos/Fisheries_R_Scripts/Blue_Swimmer_Crab_Code_Sim/")#
setwd("BSC_R_code_best/Diff_Variance_Function/")#
# Read in the data set on the asymptotic males that was gathered through pots#
#
lfd.big.males.females <- read.table("LFD_bigMalesFem", header = T)#
# Pull out the lengths and the dates from these data files#
#
lfd.big.males.females.dates   <- as.Date(lfd.big.males.females$Date, "%d/%m/%y")#
lfd.big.males.females.lengths <- lfd.big.males.females$Carapacewidth#
# Pull out the year and month information from these dates#
#
lfd.big.males.females.dates.year   <- format(lfd.big.males.females.dates, '%Y')#
lfd.big.males.females.dates.months <- format(lfd.big.males.females.dates, '%m')#
# Read in the trawl data on males that contains juvenile recruitment and adults#
#
lfd.trawl.males.females <- read.table("LFD")#
# Pull out the lengths and the dates from these data files#
#
lfd.trawl.males.females.dates   <- as.Date(lfd.trawl.males.females $Date, #
									"%d/%m/%Y")#
lfd.trawl.males.females.lengths <- lfd.trawl.males.females$Carapace.width#
# Concatenate the necessary elements from each file into a common #
# dates and lengths array#
#
lfd.dates   <- c(lfd.trawl.males.females.dates,   lfd.big.males.females.dates)#
lfd.lengths <- c(lfd.trawl.males.females.lengths, lfd.big.males.females.lengths)#
# Pull out the year and month information from these dates#
lfd.year   <- format(lfd.dates, '%Y')#
lfd.months <- format(lfd.dates, '%m')#
# Pull out the years and months that we are interested in #
# i.e., those that don't contain recruitment#
#
str.month.yr.1 <- 2#
end.month.yr.1 <- 2#
#
str.month.yr.2 <- 8#
end.month.yr.2 <- 5#
#
lfd.85.feb.aug <- which((lfd.year == '1985') & #
				  (as.numeric(lfd.months) %in% (str.month.yr.1:end.month.yr.1)))#
lfd.86.feb.may <- which((lfd.year == '1986') &#
				  (as.numeric(lfd.months) %in% (str.month.yr.2:end.month.yr.2)))#
# Initialise the data for the model #
# ---------------------------------#
#
num.months      <- 11													#
lfd.lengths.sub <- lfd.lengths[c(lfd.85.feb.aug, lfd.86.feb.may)]		#
months.85		<- as.numeric(lfd.months[lfd.85.feb.aug]) - 1 # Set January to be 0 th month#
months.86 		<- as.numeric(lfd.months[lfd.86.feb.may]) + 11#
months 			<- c(months.85, months.86)#
months.lst      <- as.numeric(names(table(months)))	#
# Initialise the parameters of the model #
# --------------------------------------#
num.inds <- length(months)					# Number of individuals we have#
pi.1     <- rep(1/3, num.months)			# Pi mixing prop group 1#
pi.2     <- rep(1/3, num.months)			# Pi mixing prop group 2#
k0       <- 1		 						# K0 average K#
linf     <- 200								# Asym length#
mu.yr.1  <- 40								# First month's average length yr 1#
mu.yr.2  <- 40								# First month's average length yr 2#
theta.1  <- 0.2								# Seasonality parameter 1#
theta.2  <- 0.1								# Seasonality parameter 2#
var.pars <- c(5, 1/100, 3, 1)				# Variance function parameter vector
SeasFunc <- function(k0, theta.1, theta.2, time.var) {#
  # Calculates the canonical seasonal function for the VB model#
  ##
  # Args:#
  #  k0:       Mean  k paramter for VB model#
  #  theta.1:  Seasonality parameter 1#
  #  theta.2:  Seasonality parameter 1#
  #  time.var  time variable#
  ##
  # Returns:#
  #  The resultant value of the seasonal function#
  return(k0 + theta.1 * cos(2 * pi * time.var) + theta.2 * sin(2 * pi * time.var))#
}
SeasRootCalc <- function(k0, theta.1, theta.2, yrs.old) {#
  # Computes the roots of the seasonal function used #
  # in VB growth models. This allows for easy integration#
  # of the #
  ##
  # Args:#
  #  k0:       Mean  k paramter for VB model#
  #  theta.1:  Seasonality parameter 1#
  #  theta.2:  Seasonality parameter 1#
  #  yrs.old:  How old the individuals in this group are#
  ##
  # Returns:#
  #  The two roots between 0 and 1 #
  # Define a set of aux variables#
  a = theta.1^2 + theta.2^2#
  b = 2 * k0 * theta.1#
  c = -theta.2^2 + k0^2#
  # Find the set of aux variables solutions#
  u1 = (-b + sqrt(b^2 -4 * a * c)) / (2 * a)#
  u2 = (-b - sqrt(b^2 -4 * a * c)) / (2 * a)#
  # Map them back via arc cos#
  r11 = 1 - acos(u1) / (2 * pi) + yrsold#
  r12 =     acos(u1) / (2 * pi) + yrsold#
  r21 = 1 - acos(u2) / (2 * pi) + yrsold#
  r22 =     acos(u2) / (2 * pi) + yrsold#
  # Find those that satisfy the roots of our function#
  roots  = c(r11, r12, r21, r22)#
  g.root = SeasFunc(k0, theta.1, theta.2, roots)#
  g.min  = round(groot)#
  r1     = min(roots[which(gmin==0)])#
  r2     = max(roots[which(gmin==0)])#
  # Return the roots#
  return(c(r1,r2))#
  }
SeasRootCalc(1,2,2,1)
SeasRootCalc <- function(k0, theta.1, theta.2, yrs.old) {#
  # Computes the roots of the seasonal function used #
  # in VB growth models. This allows for easy integration#
  # of the #
  ##
  # Args:#
  #  k0:       Mean  k paramter for VB model#
  #  theta.1:  Seasonality parameter 1#
  #  theta.2:  Seasonality parameter 1#
  #  yrs.old:  How old the individuals in this group are#
  ##
  # Returns:#
  #  The two roots between 0 and 1 #
  # Define a set of aux variables#
  a = theta.1^2 + theta.2^2#
  b = 2 * k0 * theta.1#
  c = -theta.2^2 + k0^2#
  # Find the set of aux variables solutions#
  u1 = (-b + sqrt(b^2 -4 * a * c)) / (2 * a)#
  u2 = (-b - sqrt(b^2 -4 * a * c)) / (2 * a)#
  # Map them back via arc cos#
  r11 = 1 - acos(u1) / (2 * pi) + yrs.old#
  r12 =     acos(u1) / (2 * pi) + yrs.old#
  r21 = 1 - acos(u2) / (2 * pi) + yrs.old#
  r22 =     acos(u2) / (2 * pi) + yrs.old#
  # Find those that satisfy the roots of our function#
  roots  = c(r11, r12, r21, r22)#
  g.root = SeasFunc(k0, theta.1, theta.2, roots)#
  g.min  = round(groot)#
  r1     = min(roots[which(gmin==0)])#
  r2     = max(roots[which(gmin==0)])#
  # Return the roots#
  return(c(r1,r2))#
  }
SeasRootCalc(1,2,2,1)
SeasRootCalc <- function(k0, theta.1, theta.2, yrs.old) {#
  # Computes the roots of the seasonal function used #
  # in VB growth models. This allows for easy integration#
  # of the #
  ##
  # Args:#
  #  k0:       Mean  k paramter for VB model#
  #  theta.1:  Seasonality parameter 1#
  #  theta.2:  Seasonality parameter 1#
  #  yrs.old:  How old the individuals in this group are#
  ##
  # Returns:#
  #  The two roots between 0 and 1 #
  # Define a set of aux variables#
  a = theta.1^2 + theta.2^2#
  b = 2 * k0 * theta.1#
  c = -theta.2^2 + k0^2#
  # Find the set of aux variables solutions#
  u1 = (-b + sqrt(b^2 -4 * a * c)) / (2 * a)#
  u2 = (-b - sqrt(b^2 -4 * a * c)) / (2 * a)#
  # Map them back via arc cos#
  r11 = 1 - acos(u1) / (2 * pi) + yrs.old#
  r12 =     acos(u1) / (2 * pi) + yrs.old#
  r21 = 1 - acos(u2) / (2 * pi) + yrs.old#
  r22 =     acos(u2) / (2 * pi) + yrs.old#
  # Find those that satisfy the roots of our function#
  roots  = c(r11, r12, r21, r22)#
  g.root = SeasFunc(k0, theta.1, theta.2, roots)#
  g.min  = round(g.root)#
  r1     = min(roots[which(g.min == 0)])#
  r2     = max(roots[which(g.min == 0)])#
  # Return the roots#
  return(c(r1, r2))#
  }
SeasRootCalc(1,2,2,1)
SeasRootCalc(1,2,2,1)[1]
r1 <- SeasRootCalc(k0, theta.1, theta.2, yrs.old)[1]
r2 <- SeasRootCalc(k0, theta.1, theta.2, yrs.old)[2]
k0
.
theta.1
theta.2
yrs.old
yrs.old <- 1
r1 <- SeasRootCalc(k0, theta.1, theta.2, yrs.old)[1]
r2 <- SeasRootCalc(k0, theta.1, theta.2, yrs.old)[2]
r1
theta.1<-2
theta.1<-2
theta.2<-2
r1 <- SeasRootCalc(k0, theta.1, theta.2, yrs.old)[1]
r2 <- SeasRootCalc(k0, theta.1, theta.2, yrs.old)[2]
r1
r2
SeasIntegFunc <- function(k0, theta.1, theta.2, str.time, end.time) {#
  # Calculates the canonical seasonal function for the VB model#
  ##
  # Args:#
  #  k0:       Mean  k paramter for VB model#
  #  theta.1:  Seasonality parameter 1#
  #  theta.2:  Seasonality parameter 1#
  #  str.time  start time for integral#
  #  end.time  end time for integral#
  ##
  # Returns:#
  #  The resultant value of the seasonal function#
  integral <- k0 * (end.time - str.time) #
              + (theta.1 / (2 * pi)) * (sin(2 * pi * end.time) - sin(2 * pi * str.time)) #
              - (theta.2 / (2 * pi)) * (cos(2 * pi * end.time) - cos(2 * pi * str.time))#
  return(integral)#
}
mm.val  <- (mm %% 12) / 12 + 1 / 24 + yrs.old#
  str.mid <- str.mnth / 12 + 1 / 24 + yrs.old#
  end.mid <- str.mid + 1
mm=1
(mm %% 12)
mm.val  <- (mm %% 12) / 12 + 1 / 24 + yrs.old#
  str.mid <- str.mnth / 12 + 1 / 24 + yrs.old#
  end.mid <- str.mid + 1
str.mnth = 0
mm.val  <- (mm %% 12) / 12 + 1 / 24 + yrs.old#
  str.mid <- str.mnth / 12 + 1 / 24 + yrs.old#
  end.mid <- str.mid + 1
time      <- seq(0, 1, 0.01)#
  seas.func <- SeasFunc(k0, theta.1, theta.2, time)#
  is.neg.1  <- min(seas.func)#
  is.neg.2  <- max(seas.func)
root.1 <- SeasRootCalc(k0, theta.1, theta.2, yrs.old)[1]#
    root.2 <- SeasRootCalc(k0, theta.1, theta.2, yrs.old)[2]
int.root.1   <- SeasIntegFunc(k0, theta.1, theta.2, str.mid, root.1)#
	int.root.2   <- SeasIntegFunc(k0, theta.1, theta.2, root.2,  end.mid)#
	int.yrs.prvs <- yrs.old * (int.root.1 + int.root.2)
int.yrs.prvs
yrs.old
int.root.1
int.root.2
theta.2
theta.1
k0
k0 * (end.time - str.time)
yrs.old
int.yrs.prvs <- yrs.old * (int.root.1 + int.root.2)
int.yrs.prvs
zMid1=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	zEnd1=K0*(endmid-r2) + (T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*r2)) - (T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*r2))#
	KKyr<-yrsold*(zEnd1+zMid1)
yrsold<-yrs.old
K0=1
T0=2
T1=2
zMid1=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	zEnd1=K0*(endmid-r2) + (T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*r2)) - (T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*r2))#
	KKyr<-yrsold*(zEnd1+zMid1)
strmid<-str.mid
endmid<-end.mid
zMid1=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	zEnd1=K0*(endmid-r2) + (T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*r2)) - (T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*r2))#
	KKyr<-yrsold*(zEnd1+zMid1)
KKyr
root.2
end.mid
str.mid
root.1
r1
strmid
K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))
SeasIntegFunc(k0, theta.1, theta.2, str.mid, root.1)
SeasIntegFunc(k0, theta.1, theta.2, root.2,  end.mid)
end.time= str.mid
str.time = str.mid
end.time = root.1
k0 * (end.time - str.time)
+ (theta.1 / (2 * pi)) * (sin(2 * pi * end.time) - sin(2 * pi * str.time))
- (theta.2 / (2 * pi)) * (cos(2 * pi * end.time) - cos(2 * pi * str.time))
# ---------------------------------------------------------------------#
#
SeasIntegFunc <- function(k0, theta.1, theta.2, str.time, end.time) {#
  # Calculates the canonical seasonal function for the VB model#
  ##
  # Args:#
  #  k0:       Mean  k paramter for VB model#
  #  theta.1:  Seasonality parameter 1#
  #  theta.2:  Seasonality parameter 1#
  #  str.time  start time for integral#
  #  end.time  end time for integral#
  ##
  # Returns:#
  #  The resultant value of the seasonal function#
  integral <- k0 * (end.time - str.time) + #
              (theta.1 / (2 * pi)) * (sin(2 * pi * end.time) - sin(2 * pi * str.time)) - #
              (theta.2 / (2 * pi)) * (cos(2 * pi * end.time) - cos(2 * pi * str.time))#
  return(integral)#
}
int.root.1   <- SeasIntegFunc(k0, theta.1, theta.2, str.mid, root.1)#
	int.root.2   <- SeasIntegFunc(k0, theta.1, theta.2, root.2,  end.mid)#
	int.yrs.prvs <- yrs.old * (int.root.1 + int.root.2)
int.yrs.prvs
zMid1=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	zEnd1=K0*(endmid-r2) + (T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*r2)) - (T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*r2))#
	KKyr<-yrsold*(zEnd1+zMid1)
KKyr
11 %% 12
mu.yr.1 =50
mu.yr.2 =60
linf = 190
mm.val  <- (month %% 12) / 12 + 1 / 24 + yrs.old#
  str.mid <- str.mnth / 12 + 1 / 24 + yrs.old#
  end.mid <- str.mid + 1#
  # Assess whether the parameters at this update cross the y=0 axis#
  # This will allow us to assess whether we need to calculate roots #
  # for the seasonal function or not#
  time      <- seq(0, 1, 0.01)#
  seas.func <- SeasFunc(k0, theta.1, theta.2, time)#
  is.neg.1  <- min(seas.func)#
  is.neg.2  <- max(seas.func)#
  if (is.neg.1 < 0 & is.neg.2 > 0) {#
	# Calculate the roots of the seasonal function #
    root.1 <- SeasRootCalc(k0, theta.1, theta.2, yrs.old)[1]#
    root.2 <- SeasRootCalc(k0, theta.1, theta.2, yrs.old)[2]#
	# Given the roots calculate the integral over the previous years#
	# This is equal to the integral up to the first root + the in#
	int.root.1   <- SeasIntegFunc(k0, theta.1, theta.2, str.mid, root.1)#
	int.root.2   <- SeasIntegFunc(k0, theta.1, theta.2, root.2,  end.mid)#
	int.yrs.prvs <- yrs.old * (int.root.1 + int.root.2)#
    # Integral for those months less than root 1#
    if (mm.val <= root.1) {#
      integral = int.yrs.prvs #
                 + SeasIntegFunc(k0, theta.1, theta.2, str.mid, mm.val)#
    }#
    # Integral for those months greater than root 1 but less than root 2#
#
    if (mm.val > root.1 & mm.val < root.2) {#
    	integral = int.yrs.prvs #
                   + SeasIntegFunc(k0, theta.1, theta.2, str.mid, root.1)#
    }#
    # Integral for those months less than root 1#
    if (mm.val >= root.2) {#
       int.root.1.1 <- SeasIntegFunc(k0, theta.1, theta.2, str.mid, root.1)#
       int.root.2.1 <- SeasIntegFunc(k0, theta.1, theta.2, root.2,  mm.val)#
	   integral     <- int.root.1.1 + int.root.2.1 + int.yrs.prvs#
	  }#
    } else {#
    # If the integral doesn't have a negative component#
    integral = SeasIntegFunc(k0, theta.1, theta.2, str.mid, mm.val)#
    }#
  if (month > 11) {#
    mu.yr.2 + (linf - mu.yr.2)*(1-exp(-integral))#
  } else {#
 	# For the months in the first year #
    mu.yr.1 + (linf - mu.yr.1)*(1-exp(-integral))#
  }
month = 3
mm.val  <- (month %% 12) / 12 + 1 / 24 + yrs.old#
  str.mid <- str.mnth / 12 + 1 / 24 + yrs.old#
  end.mid <- str.mid + 1#
  # Assess whether the parameters at this update cross the y=0 axis#
  # This will allow us to assess whether we need to calculate roots #
  # for the seasonal function or not#
  time      <- seq(0, 1, 0.01)#
  seas.func <- SeasFunc(k0, theta.1, theta.2, time)#
  is.neg.1  <- min(seas.func)#
  is.neg.2  <- max(seas.func)#
  if (is.neg.1 < 0 & is.neg.2 > 0) {#
	# Calculate the roots of the seasonal function #
    root.1 <- SeasRootCalc(k0, theta.1, theta.2, yrs.old)[1]#
    root.2 <- SeasRootCalc(k0, theta.1, theta.2, yrs.old)[2]#
	# Given the roots calculate the integral over the previous years#
	# This is equal to the integral up to the first root + the in#
	int.root.1   <- SeasIntegFunc(k0, theta.1, theta.2, str.mid, root.1)#
	int.root.2   <- SeasIntegFunc(k0, theta.1, theta.2, root.2,  end.mid)#
	int.yrs.prvs <- yrs.old * (int.root.1 + int.root.2)#
    # Integral for those months less than root 1#
    if (mm.val <= root.1) {#
      integral = int.yrs.prvs #
                 + SeasIntegFunc(k0, theta.1, theta.2, str.mid, mm.val)#
    }#
    # Integral for those months greater than root 1 but less than root 2#
#
    if (mm.val > root.1 & mm.val < root.2) {#
    	integral = int.yrs.prvs #
                   + SeasIntegFunc(k0, theta.1, theta.2, str.mid, root.1)#
    }#
    # Integral for those months less than root 1#
    if (mm.val >= root.2) {#
       int.root.1.1 <- SeasIntegFunc(k0, theta.1, theta.2, str.mid, root.1)#
       int.root.2.1 <- SeasIntegFunc(k0, theta.1, theta.2, root.2,  mm.val)#
	   integral     <- int.root.1.1 + int.root.2.1 + int.yrs.prvs#
	  }#
    } else {#
    # If the integral doesn't have a negative component#
    integral = SeasIntegFunc(k0, theta.1, theta.2, str.mid, mm.val)#
    }#
  if (month > 11) {#
    mu.yr.2 + (linf - mu.yr.2)*(1-exp(-integral))#
  } else {#
 	# For the months in the first year #
    mu.yr.1 + (linf - mu.yr.1)*(1-exp(-integral))#
  }
# Mean function for calcuating the mean length for the current month#
# ------------------------------------------------------------------#
MeanLength <- function(month, k0, theta.1, theta.2 , linf, mu.yr.1, mu.yr.2, #
			  yrs.old, str.mnth) {#
  # Computes the mean length of the distribution for the current month#
  # based on an integration over the seasonal curve from a von Bertal#
  # anffy growth model.#
  ##
  # Args:#
  #  month:    Current month to calulate mean at. Numbered from Jan=0#
  #  k0:       Mean  k paramter for VB model#
  #  theta.1:  Seasonality parameter 1#
  #  theta.2:  Seasonality parameter 1#
  #  linf:     Asymptotic length#
  #  mu.yr.1:  First month's average length yr 1#
  #  mu.yr.2:  First month's average length yr 2#
  #  yrs.old:  How old the individuals in this group are#
  #  str.mnth: The month that we start calculating means for #
  ##
  # Returns:#
  #  Mean length for the month in the current iteration#
  # Set each of the months to be the middle of the month (1/24 to be used#
  # with the seasonal function.#
  mm.val  <- (month %% 12) / 12 + 1 / 24 + yrs.old#
  str.mid <- str.mnth / 12 + 1 / 24 + yrs.old#
  end.mid <- str.mid + 1#
  # Assess whether the parameters at this update cross the y=0 axis#
  # This will allow us to assess whether we need to calculate roots #
  # for the seasonal function or not#
  time      <- seq(0, 1, 0.01)#
  seas.func <- SeasFunc(k0, theta.1, theta.2, time)#
  is.neg.1  <- min(seas.func)#
  is.neg.2  <- max(seas.func)#
  if (is.neg.1 < 0 & is.neg.2 > 0) {#
	# Calculate the roots of the seasonal function #
    root.1 <- SeasRootCalc(k0, theta.1, theta.2, yrs.old)[1]#
    root.2 <- SeasRootCalc(k0, theta.1, theta.2, yrs.old)[2]#
	# Given the roots calculate the integral over the previous years#
	# This is equal to the integral up to the first root + the in#
	int.root.1   <- SeasIntegFunc(k0, theta.1, theta.2, str.mid, root.1)#
	int.root.2   <- SeasIntegFunc(k0, theta.1, theta.2, root.2,  end.mid)#
	int.yrs.prvs <- yrs.old * (int.root.1 + int.root.2)#
    # Integral for those months less than root 1#
    if (mm.val <= root.1) {#
      integral = int.yrs.prvs #
                 + SeasIntegFunc(k0, theta.1, theta.2, str.mid, mm.val)#
    }#
    # Integral for those months greater than root 1 but less than root 2#
#
    if (mm.val > root.1 & mm.val < root.2) {#
    	integral = int.yrs.prvs #
                   + SeasIntegFunc(k0, theta.1, theta.2, str.mid, root.1)#
    }#
    # Integral for those months less than root 1#
    if (mm.val >= root.2) {#
       int.root.1.1 <- SeasIntegFunc(k0, theta.1, theta.2, str.mid, root.1)#
       int.root.2.1 <- SeasIntegFunc(k0, theta.1, theta.2, root.2,  mm.val)#
	   integral     <- int.root.1.1 + int.root.2.1 + int.yrs.prvs#
	  }#
    } else {#
    # If the integral doesn't have a negative component#
    integral = SeasIntegFunc(k0, theta.1, theta.2, str.mid, mm.val)#
    }#
  if (month > 11) {#
    mu.yr.2 + (linf - mu.yr.2)*(1-exp(-integral))#
  } else {#
 	# For the months in the first year #
    mu.yr.1 + (linf - mu.yr.1)*(1-exp(-integral))#
  }#
}
MeanLength(3, 1, 2, 2, 190, 50, 60, 0, 0)
MeanLength(12, 1, 2, 2, 190, 50, 60, 0, 0)
