0.33/0.55
862+98+185+188+2356
BayesR<-read.table(pipe("pbpaste"), header=T)
hist(BayesR)
BayesR
BayesR$x
BayesR<-read.table(pipe("pbpaste"), header=F)
hist(BayesR)
BayesR
class(BayesR)
BayesR[,1]
GCTA<-read.table(pipe("pbpaste"), header=F)
par(mfrow=c(1,2))
hist(BayesR[,1],xlab="h2 from Bayes R"
hist(BayesR[,1],xlab="h2 from Bayes R")
hist(GCTA[,1],xlab="h2 from Bayes R")
BayesR<-read.table(pipe("pbpaste"), header=F)#
GCTA<-read.table(pipe("pbpaste"), header=F)#
#
par(mfrow=c(1,2))#
hist(BayesR[,1],xlab="h2 from Bayes R")#
hist(GCTA[,1],xlab="h2 from constrained GCTA")
GCTA
BayesR
BayesR<-read.table(pipe("pbpaste"), header=F)
GCTA<-read.table(pipe("pbpaste"), header=F)
par(mfrow=c(1,2))
hist(BayesR[,1],xlab="h2 from Bayes R")
hist(GCTA[,1],xlab="h2 from constrained GCTA")
par(mfrow=c(1,2))#
hist(BayesR[,1],xlab="h2 from Bayes R",main="")#
hist(GCTA[,1],xlab="h2 from constrained GCTA",main="")
BayesR<-read.table(pipe("pbpaste"), header=F)#
GCTA<-read.table(pipe("pbpaste"), header=F)#
#
par(mfrow=c(1,2))#
hist(BayesR[,1],xlab="h2 from Bayes R",main="")#
hist(GCTA[,1],xlab="h2 from constrained GCTA",main="")
1/(1-0.8)
484/(484+542)
0.003028/(0.003028+0.003379)
0.002893/(0.002893+0.004337]\)
0.002893/(0.002893+0.004337)
2.4%1
2.4%%1
2%%1
read.table(pipe("pbpaste"))
xread.table(pipe("pbpaste"))
x=read.table(pipe("pbpaste"))
plot(x[,1],x[,2])
lines(x[,1],exp(-x[,1]))
read.plink <- function (root)#
{#
    bed.file = paste(root, ".bed", sep = "")#
    bed.file.size = file.info(bed.file)$size#
    sample.size = dim(read.table(paste(root, ".fam", sep = "")))[1]#
    snp.size = ceiling(sample.size/4)#
    n.snps = round((bed.file.size - 3)/snp.size)#
    bin.connection = file(bed.file, "rb")#
    test.bytes = readBin(bin.connection, what = "raw", n = 3)#
    if (!identical(as.character(test.bytes), c("6c", "1b", "01"))) {#
        stop("BED file not a v0.99 SNP-major BED file, please re-encode the data as v0.99 SNP-major file")#
    }#
    genotypes = matrix(ncol = n.snps, nrow = sample.size)#
    for (i in 1:n.snps) {#
        r.bin.snp = readBin(bin.connection, what = "raw", n = snp.size)#
        bin.snp = matrix(as.numeric(rawToBits(r.bin.snp)), ncol = 2,#
            byrow = TRUE)[1:sample.size, ]#
        genotypes[, i] = bin.snp[, 1] + bin.snp[, 2] - 10 * ((bin.snp[,#
            1] == 1) & (bin.snp[, 2] == 0))#
    }#
    genotypes[genotypes == -9] = NA#
    #snp.names = read.table(paste(root, ".bim", sep = ""))[, 2]#
    #colnames(genotypes) = snp.names#
    close(bin.connection)#
    return(genotypes)#
}
nsnp <- 100000#
nind <- 10000#
#
snp.mat <- matrix(NA,ncol=nsnp,nrow=nind)#
gen.freq <- runif(nsnp,0.05,0.5)#
#
for(i in 1:nsnp) {#
  p <- gen.freq[i]#
  snp.mat[,i] <- rbinom(nind,2,p)#
}
dim(snp.mat)
snp.mat[1:10,1:10]
ids <- 1:nind
gem <- data.frame(ids,ids,0,0,1,1,snp.mat)
write.table(gem,paste(path,"gemma2.ped",sep=""),col.names=FALSE,row.names=FALSE,quote=FALSE)
path <- "/Users/uqllloyd/Desktop/BayesR_Sim/BayesRsimulation_Data_Gen_R_1.0/"
write.table(gem,paste(path,"gemma2.ped",sep=""),col.names=FALSE,row.names=FALSE,quote=FALSE)
gen.freq <- array(0,length=nsnsp)#
for(i in 1:nsnp)  gen.freq[i] <- sum(snp.mat[,i])/(2*nind)#
write.table(gen.freq,paste(path,"geno2.freq",sep=""),col.names=FALSE,row.names=FALSE,quote=FALSE)
gen.freq <- array(0,length=nsnp)#
for(i in 1:nsnp)  gen.freq[i] <- sum(snp.mat[,i])/(2*nind)#
write.table(gen.freq,paste(path,"geno2.freq",sep=""),col.names=FALSE,row.names=FALSE,quote=FALSE)
gen.freq <- array(0,length=nsnp)
nsnp
gen.freq <- array(0,nsnp)
for(i in 1:nsnp)  gen.freq[i] <- sum(snp.mat[,i])/(2*nind)
write.table(gen.freq,paste(path,"geno2.freq",sep=""),col.names=FALSE,row.names=FALSE,quote=FALSE)
pos <- 1:nsnp#
snps <- paste("snp",1:nsnp,sep="")#
map <- data.frame(chro=1,snp=snps,d=0,pos=pos)#
write.table(map,paste(path,"gemma2.map",sep=""),col.names=FALSE,row.names=FALSE,quote=FALSE)
path <- "/Users/uqllloyd/Desktop/BayesR_Sim/BayesRsimulation_Data_Gen_R_1.0/"#
#
nsnp <- 1000#
nind <- 1000#
#
snp.mat <- matrix(NA,ncol=nsnp,nrow=nind)#
gen.freq <- runif(nsnp,0.05,0.5)#
#
for(i in 1:nsnp) {#
  p <- gen.freq[i]#
  snp.mat[,i] <- rbinom(nind,2,p)#
}#
#
# change codes to plink compound genotypes#
snp.mat[snp.mat==2] <- 22#
snp.mat[snp.mat==1] <- 12#
snp.mat[snp.mat==0] <- 11#
#
ids <- 1:nind#
gem <- data.frame(ids,ids,0,0,1,1,snp.mat)#
write.table(gem,paste(path,"gemma2.ped",sep=""),col.names=FALSE,row.names=FALSE,quote=FALSE)#
#
gen.freq <- array(0,nsnp)#
for(i in 1:nsnp)  gen.freq[i] <- sum(snp.mat[,i])/(2*nind)#
write.table(gen.freq,paste(path,"geno2.freq",sep=""),col.names=FALSE,row.names=FALSE,quote=FALSE)#
pos <- 1:nsnp#
snps <- paste("snp",1:nsnp,sep="")#
map <- data.frame(chro=1,snp=snps,d=0,pos=pos)#
write.table(map,paste(path,"gemma2.map",sep=""),col.names=FALSE,row.names=FALSE,quote=FALSE)
list=ls()
nsnp <- 100000#
nind <- 10000#
#
snp.mat <- matrix(NA,ncol=nsnp,nrow=nind)#
gen.freq <- runif(nsnp,0.05,0.5)#
#
for(i in 1:nsnp) {#
  p <- gen.freq[i]#
  snp.mat[,i] <- rbinom(nind,2,p)#
}#
#
# change codes to plink compound genotypes#
snp.mat[snp.mat==2] <- 22#
snp.mat[snp.mat==1] <- 12#
snp.mat[snp.mat==0] <- 11#
#
ids <- 1:nind#
gem <- data.frame(ids,ids,0,0,1,1,snp.mat)#
write.table(gem,paste(path,"gemma2.ped",sep=""),col.names=FALSE,row.names=FALSE,quote=FALSE)#
#
gen.freq <- array(0,nsnp)#
for(i in 1:nsnp)  gen.freq[i] <- sum(snp.mat[,i])/(2*nind)#
write.table(gen.freq,paste(path,"geno2.freq",sep=""),col.names=FALSE,row.names=FALSE,quote=FALSE)#
pos <- 1:nsnp#
snps <- paste("snp",1:nsnp,sep="")#
map <- data.frame(chro=1,snp=snps,d=0,pos=pos)#
write.table(map,paste(path,"gemma2.map",sep=""),col.names=FALSE,row.names=FALSE,quote=FALSE)
list=rm()
ls
read.table(~/Desktop/BayesRsim_Phen_4_Test/TrueBetaVars.txt,header=F)
read.table("~/Desktop/BayesRsim_Phen_4_Test/TrueBetaVars.txt",header=F)
X=read.table("~/Desktop/BayesRsim_Phen_4_Test/TrueBetaVars.txt",header=F)
hist(X[1,])
X[1,]
as.numeric(X[1,])
X=read.table("~/Desktop/BayesRsim_Phen_4_Test/TrueBeta.txt",header=F)
X=read.table("~/Desktop/BayesRsim_Phen_4_Test/TrueBetas.txt",header=F)
hist(as.numeric(X[1,]))
hist(as.numeric(X[1,]^2))
plot(density(as.numeric(X[1,]^2)))
X
X[1,]
length(which(X[1,]>0))
X=read.table("~/Desktop/BayesRsim_Phen_4_Test/M1000_N1000/out/M1000_N1000_2.eff",header=F)
plot(density(as.numeric(X[1,]^2)))
plot(density(as.numeric(X[,5]^2)))
X
X=read.table("~/Desktop/BayesRsim_Phen_4_Test/M1000_N1000/out/M1000_N1000_2.eff",header=T)
plot(density(as.numeric(X[,5]^2)))
X[,5]
Y=read.table("~/Desktop/BayesRsim_Phen_4_Test/TrueBetas.txt",header=F)
plot(density(as.numeric(X[,5])))
plot(density(as.numeric(X[,5]^2)))
lines(density(Y[1,]))
lines(density(as.numeric(Y[1,]^2))
lines(density(as.numeric(Y[1,]^2)))
plot(density(as.numeric(Y[1,]^2)))
X[,5]
Y[1,]
plot(density(as.numeric(X[1:200,5]^2)))
plot(density(as.numeric(Y[1,1:200]^2)))
X[1:200,5]
Y[1,1:200]
as.numeric(Y[1,1:200])
which(as.numeric(Y[1,1:200])>0)
X[which(as.numeric(Y[1,1:200])>0),5]
Y[1,which(as.numeric(Y[1,1:200])>0)]
X[which(as.numeric(Y[1,])!=0),5]
Y[1,which(as.numeric(Y[1,])!=0)]
cbind(X[which(as.numeric(Y[1,])!=0),5],Y[1,which(as.numeric(Y[1,])!=0)])
X[which(as.numeric(Y[1,])!=0),5]
Y[1,which(as.numeric(Y[1,])!=0)]
cbind(as.numeric(X[which(as.numeric(Y[1,])!=0),5]),as.numeric(Y[1,which(as.numeric(Y[1,])!=0)]))
source('~/Dropbox/AAUni/APhD/Blueswimmer/NRalg/HessianFunc.R', chdir = TRUE)
source('~/Dropbox/AAUni/APhD/Blueswimmer/NRalg/ScoreFunc.R', chdir = TRUE)
a=1; b=1; c=1; Linf=170; mu01=60; mu02=70; k=2; theta1=1; theta2=1; tau1=0.333; tau2=0.333; tau3=0.333; Tlib1=0.5; Tlib2=1.5; Tlib3=2.5; SIN1=0.5; COS1=0.5; SIN2=0.5; COS2=0.5; SIN3=0.5; COS3=0.5; l=80;#
#
theta=c(a,b,c, Linf, mu01, mu02, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3 )
HESS(theta)
theta=c(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3 )
HESS(theta)
theta=c(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l )
HESS(theta)
theta
length(theta)
a=1; b=1; c=1; Linf=170; mu01=60; mu02=70; k=2; theta1=1; theta2=1; tau1=0.333; tau2=0.333; tau3=0.333; Tlib1=0.5; Tlib2=1.5; Tlib3=2.5; SIN1=0.5; COS1=0.5; SIN2=0.5; COS2=0.5; SIN3=0.5; COS3=0.5; l=80;
theta=c(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l )
HESS(theta)
tau1
SCORE(theta)
(2*tau1*(l - mu01 + (Linf - mu01)*(exp((COS1*theta2)/(2*pi) - Tlib1*k - (SIN1*theta1)/(2*pi)) - 1))^2)/(2*a + 2*b*(mu01 - (Linf - mu01)*(exp(- Tlib1*k + (COS1*theta2)/(2*pi) - (SIN1*theta1)/(2*pi)) - 1)) + 2*c*(mu01 - (Linf - mu01)*(exp(- Tlib1*k + (COS1*theta2)/(2*pi) - (SIN1*theta1)/(2*pi)) - 1))^2)^2 - tau2/(2*(a + b*(mu01 - (Linf - mu01)*(exp((COS2*theta2)/(2*pi) - Tlib2*k - (SIN2*theta1)/(2*pi)) - 1)) + c*(mu01 - (Linf - mu01)*(exp((COS2*theta2)/(2*pi) - Tlib2*k - (SIN2*theta1)/(2*pi)) - 1))^2)) - tau3/(2*(a + b*(mu01 - (Linf - mu01)*(exp((COS3*theta2)/(2*pi) - Tlib3*k - (SIN3*theta1)/(2*pi)) - 1)) + c*(mu01 - (Linf - mu01)*(exp((COS3*theta2)/(2*pi) - Tlib3*k - (SIN3*theta1)/(2*pi)) - 1))^2)) - tau1/(2*(a + b*(mu01 - (Linf - mu01)*(exp((COS1*theta2)/(2*pi) - Tlib1*k - (SIN1*theta1)/(2*pi)) - 1)) + c*(mu01 - (Linf - mu01)*(exp((COS1*theta2)/(2*pi) - Tlib1*k - (SIN1*theta1)/(2*pi)) - 1))^2)) + (2*tau2*(l - mu01 + (Linf - mu01)*(exp((COS2*theta2)/(2*pi) - Tlib2*k - (SIN2*theta1)/(2*pi)) - 1))^2)/(2*a + 2*
b*(mu01 - (Linf - mu01)*(exp(- Tlib2*k + (COS2*theta2)/(2*pi) - (SIN2*theta1)/(2*pi)) - 1)) + 2*c*(mu01 - (Linf - mu01)*(exp(- Tlib2*k + (COS2*theta2)/(2*pi) - (SIN2*theta1)/(2*pi)) - 1))^2)^2 + (2*tau3*(l - mu01 + (Linf - mu01)*(exp((COS3*theta2)/(2*pi) - Tlib3*k - (SIN3*theta1)/(2*pi)) - 1))^2)/(2*a + 2*b*(mu01 - (Linf - mu01)*(exp(- Tlib3*k + (COS3*theta2)/(2*pi) - (SIN3*theta1)/(2*pi)) - 1)) + 2*c*(mu01 - (Linf - mu01)*(exp(- Tlib3*k + (COS3*theta2)/(2*pi) - (SIN3*theta1)/(2*pi)) - 1))^2)^2
tau1/(2*(a + b*(mu01 - (Linf - mu01)*(exp(- Tlib1*k + (COS1*theta2)/(2*pi) - (SIN1*theta1)/(2*pi)) - 1)) + c*(mu01 - (Linf - mu01)*(exp(- Tlib1*k + (COS1*theta2)/(2*pi) - (SIN1*theta1)/(2*pi)) - 1))^2)^2) + tau2/(2*(a + b*(mu01 - (Linf - mu01)*(exp(- Tlib2*k + (COS2*theta2)/(2*pi) - (SIN2*theta1)/(2*pi)) - 1)) + c*(mu01 - (Linf - mu01)*(exp(- Tlib2*k + (COS2*theta2)/(2*pi) - (SIN2*theta1)/(2*pi)) - 1))^2)^2) + tau3/(2*(a + b*(mu01 - (Linf - mu01)*(exp(- Tlib3*k + (COS3*theta2)/(2*pi) - (SIN3*theta1)/(2*pi)) - 1)) + c*(mu01 - (Linf - mu01)*(exp(- Tlib3*k + (COS3*theta2)/(2*pi) - (SIN3*theta1)/(2*pi)) - 1))^2)^2) - (8*tau1*(l - mu01 + (Linf - mu01)*(exp((COS1*theta2)/(2*pi) - Tlib1*k - (SIN1*theta1)/(2*pi)) - 1))^2)/(2*a + 2*b*(mu01 - (Linf - mu01)*(exp(- Tlib1*k + (COS1*theta2)/(2*pi) - (SIN1*theta1)/(2*pi)) - 1)) + 2*c*(mu01 - (Linf - mu01)*(exp(- Tlib1*k + (COS1*theta2)/(2*pi) - (SIN1*theta1)/(2*pi)) - 1))^2)^3 - (8*tau2*(l - mu01 + (Linf - mu01)*(exp((COS2*theta2)/(2*pi) - Tlib2*k - (SIN2*theta1)/(2*pi))
- 1))^2)/(2*a + 2*b*(mu01 - (Linf - mu01)*(exp(- Tlib2*k + (COS2*theta2)/(2*pi) - (SIN2*theta1)/(2*pi)) - 1)) + 2*c*(mu01 - (Linf - mu01)*(exp(- Tlib2*k + (COS2*theta2)/(2*pi) - (SIN2*theta1)/(2*pi)) - 1))^2)^3 - (8*tau3*(l - mu01 + (Linf - mu01)*(exp((COS3*theta2)/(2*pi) - Tlib3*k - (SIN3*theta1)/(2*pi)) - 1))^2)/(2*a + 2*b*(mu01 - (Linf - mu01)*(exp(- Tlib3*k + (COS3*theta2)/(2*pi) - (SIN3*theta1)/(2*pi)) - 1)) + 2*c*(mu01 - (Linf - mu01)*(exp(- Tlib3*k + (COS3*theta2)/(2*pi) - (SIN3*theta1)/(2*pi)) - 1))^2)^3
HESS(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)
SCORE(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)
J=HESS(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)
S=SCORE(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)
solve(J)
det(J)
a=1; b=1; c=1; Linf=150; mu01=60; mu02=70; k=2; theta1=1; theta2=1; tau1=0.333; tau2=0.333; tau3=0.333; Tlib1=0.5; Tlib2=1.5; Tlib3=2.5; SIN1=0.5; COS1=0.5; SIN2=0.5; COS2=0.5; SIN3=0.5; COS3=0.5; l=80;#
J=HESS(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
S=SCORE(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
#
det(J)
a=0; b=1; c=1; Linf=150; mu01=60; mu02=70; k=2; theta1=1; theta2=1; tau1=0.333; tau2=0.333; tau3=0.333; Tlib1=0.5; Tlib2=1.5; Tlib3=2.5; SIN1=0.5; COS1=0.5; SIN2=0.5; COS2=0.5; SIN3=0.5; COS3=0.5; l=80;
J=HESS(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)
S=SCORE(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)
det(J)
a=100; b=1; c=1; Linf=150; mu01=60; mu02=70; k=2; theta1=1; theta2=1; tau1=0.333; tau2=0.333; tau3=0.333; Tlib1=0.5; Tlib2=1.5; Tlib3=2.5; SIN1=0.5; COS1=0.5; SIN2=0.5; COS2=0.5; SIN3=0.5; COS3=0.5; l=80;
J=HESS(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)
S=SCORE(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)
det(J)
a=100; b=1; c=-0.05; Linf=150; mu01=60; mu02=70; k=2; theta1=1; theta2=1; tau1=0.333; tau2=0.333; tau3=0.333; Tlib1=0.5; Tlib2=1.5; Tlib3=2.5; SIN1=0.5; COS1=0.5; SIN2=0.5; COS2=0.5; SIN3=0.5; COS3=0.5; l=80;
J=HESS(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)
S=SCORE(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)
det(J)
a=100; b=10; c=-0.05; Linf=150; mu01=60; mu02=70; k=2; theta1=1; theta2=1; tau1=0.333; tau2=0.333; tau3=0.333; Tlib1=0.5; Tlib2=1.5; Tlib3=2.5; SIN1=0.5; COS1=0.5; SIN2=0.5; COS2=0.5; SIN3=0.5; COS3=0.5; l=80;
J=HESS(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)
S=SCORE(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)
det(J)
a=100; b=1; c=-0.05; Linf=150; mu01=60; mu02=70; k=1; theta1=1; theta2=1; tau1=0.333; tau2=0.333; tau3=0.333; Tlib1=0.5; Tlib2=1.5; Tlib3=2.5; SIN1=0.5; COS1=0.5; SIN2=0.5; COS2=0.5; SIN3=0.5; COS3=0.5; l=80;#
J=HESS(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
S=SCORE(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
#
det(J)
solve(J)
a=100; b=1; c=-0.05; Linf=150; mu01=60; mu02=70; k=1; theta1=1; theta2=1; tau1=0.333; tau2=0.333; tau3=0.333; Tlib1=0.5; Tlib2=1.5; Tlib3=2.5; SIN1=0.05; COS1=0.05; SIN2=0.05; COS2=0.05; SIN3=0.05; COS3=0.05; l=80;#
J=HESS(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
S=SCORE(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
#
solve(J)#
det(J)
a=10; b=1; c=-0.05; Linf=150; mu01=60; mu02=70; k=1; theta1=1; theta2=1; tau1=0.333; tau2=0.333; tau3=0.333; Tlib1=0.5; Tlib2=1.5; Tlib3=2.5; SIN1=0.05; COS1=0.05; SIN2=0.05; COS2=0.05; SIN3=0.05; COS3=0.05; l=80;#
J=HESS(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
S=SCORE(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
#
det(J)
a=10; b=1; c=-0.05; Linf=150; mu01=60; mu02=70; k=1; theta1=-1; theta2=1; tau1=0.333; tau2=0.333; tau3=0.333; Tlib1=0.5; Tlib2=1.5; Tlib3=2.5; SIN1=0.05; COS1=0.05; SIN2=0.05; COS2=0.05; SIN3=0.05; COS3=0.05; l=80;#
J=HESS(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
S=SCORE(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
#
det(J)
solve(J)
J%*%S
J2=matrix(0,nrow=8,ncol=8)
for (d in seq(80,150,05))#
{#
	l=d#
	J=HESS(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
	J2=J2+J#
}
seq(80,150,05)
J2=matrix(0,nrow=8,ncol=8)#
for (d in seq(80,150,0.5))#
{#
	l=d#
	J=HESS(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
	J2=J2+J#
}#
#
J2/length(seq(80,150,0.5))
MNJ2=J2/length(seq(80,150,0.5))
det(MNJ2)
STRVAL=function(a,b,c,Linf, mu01,k,theta1,theta2,tau1,tau2, tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3, l)#
{#
	J=HESS(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
	det(J)#
}
?optim
a=10; b=1; c=-0.05; Linf=150; mu01=60; mu02=70; k=1; theta1=-1; theta2=1; tau1=0.333; tau2=0.333; tau3=0.333; Tlib1=0.5; Tlib2=1.5; Tlib3=2.5; SIN1=0.05; COS1=0.05; SIN2=0.05; COS2=0.05; SIN3=0.05; COS3=0.05; l=80;#
theta=c(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)
optim(theta,STRVAL)
STRVAL=function(theta)#
{#
	a=theta[1]; b=theta[2]; c=theta[3]; Linf=theta[4]; mu01=theta[5]; mu02=theta[6]; k=theta[7]; theta1=theta[8]; theta2=theta[9]; tau1=theta[10];tau2=theta[11]; tau3=theta[12]; Tlib1=theta[13]; Tlib2=theta[14]; Tlib3=theta[15]; SIN1=theta[16]; COS1=theta[17]; SIN2=theta[18]; COS2=theta[19]; SIN3=theta[20]; COS3=theta[21]; l=theta[22];#
	J=HESS(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
	det(J)#
}#
optim(theta,STRVAL)
theta
a=theta[1]; b=theta[2]; c=theta[3]; Linf=theta[4]; mu01=theta[5]; k=theta[6]; theta1=theta[7]; theta2=theta[8]; tau1=theta[9];tau2=theta[10]; tau3=theta[11]; Tlib1=theta[12]; Tlib2=theta[13]; Tlib3=theta[14]; SIN1=theta[15]; COS1=theta[16]; SIN2=theta[17]; COS2=theta[18]; SIN3=theta[19]; COS3=theta[20]; l=theta[21];#
	J=HESS(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
	det(J)
STRVAL=function(theta)#
{#
	a=theta[1]; b=theta[2]; c=theta[3]; Linf=theta[4]; mu01=theta[5]; k=theta[6]; theta1=theta[7]; theta2=theta[8]; tau1=theta[9];tau2=theta[10]; tau3=theta[11]; Tlib1=theta[12]; Tlib2=theta[13]; Tlib3=theta[14]; SIN1=theta[15]; COS1=theta[16]; SIN2=theta[17]; COS2=theta[18]; SIN3=theta[19]; COS3=theta[20]; l=theta[21];#
	J=HESS(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
	det(J)#
}#
optim(theta,STRVAL)
STRVAL=function(theta)#
{#
	a=theta[1]; b=theta[2]; c=theta[3]; Linf=theta[4]; mu01=theta[5]; k=theta[6]; theta1=theta[7]; theta2=theta[8]; tau1=theta[9];tau2=theta[10]; tau3=theta[11]; Tlib1=theta[12]; Tlib2=theta[13]; Tlib3=theta[14]; SIN1=theta[15]; COS1=theta[16]; SIN2=theta[17]; COS2=theta[18]; SIN3=theta[19]; COS3=theta[20]; l=theta[21];#
	J=HESS(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
	print(det(J))#
	det(J)#
}#
optim(theta,STRVAL)
a=10; b=1; c=-0.05; Linf=150; mu01=60; mu02=70; k=1; theta1=-1; theta2=1; tau1=0.333; tau2=0.333; tau3=0.333; Tlib1=0.5; Tlib2=1.5; Tlib3=2.5; SIN1=0.05; COS1=0.05; SIN2=0.05; COS2=0.05; SIN3=0.05; COS3=0.05; l=80;#
theta=c(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
#
STRVAL=function(theta)#
{#
	a=theta[1]; b=theta[2]; c=theta[3]; Linf=theta[4]; mu01=theta[5]; k=theta[6]; theta1=theta[7]; theta2=theta[8]; tau1=theta[9];tau2=theta[10]; tau3=theta[11]; Tlib1=theta[12]; Tlib2=theta[13]; Tlib3=theta[14]; SIN1=theta[15]; COS1=theta[16]; SIN2=theta[17]; COS2=theta[18]; SIN3=theta[19]; COS3=theta[20]; l=theta[21];#
	J=HESS(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
	print(det(J))#
	det(J)#
}#
optim(theta,STRVAL,control=list(maxit=1000))
STRVAL=function(theta)#
{#
	a=theta[1]; b=theta[2]; c=theta[3]; Linf=theta[4]; mu01=theta[5]; k=theta[6]; theta1=theta[7]; theta2=theta[8]; tau1=theta[9];tau2=theta[10]; tau3=theta[11]; Tlib1=theta[12]; Tlib2=theta[13]; Tlib3=theta[14]; SIN1=theta[15]; COS1=theta[16]; SIN2=theta[17]; COS2=theta[18]; SIN3=theta[19]; COS3=theta[20]; l=theta[21];#
	J=HESS(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
	print(theta)#
	print(det(J))#
	det(J)#
}#
optim(theta,STRVAL,control=list(maxit=1000))
theta=c(10.13424359,  1.42879083,  -0.01515581, 150.30959820,  59.65823292,   1.34175619  ,-0.55150142,   1.24539542, 0.26473121 ,  0.62044137 ,  0.63596122 ,  0.52967109 ,  1.37157817,   2.49614933 , -0.06740899 , -0.12224056, 13.55505483 ,  0.26066829  ,-0.17698405 , -0.24614825 , 80.09952504)
a=theta[1]; b=theta[2]; c=theta[3]; Linf=theta[4]; mu01=theta[5]; k=theta[6]; theta1=theta[7]; theta2=theta[8]; tau1=theta[9];tau2=theta[10]; tau3=theta[11]; Tlib1=theta[12]; Tlib2=theta[13]; Tlib3=theta[14]; SIN1=theta[15]; COS1=theta[16]; SIN2=theta[17]; COS2=theta[18]; SIN3=theta[19]; COS3=theta[20]; l=theta[21];
J=HESS(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)
det(J)
solve(J)
J=HESS(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
S=SCORE(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)
J%*%S
JIN=solve(J)
JIN%*%S
JIN=solve(J)
JIN%*%S
theta
thetanew=theta-JIN%*%S
theta
S
thetaold=theta[1:8]
thetanew=thetaold-JIN%*%S
thetanew
JIN%*%S
theta[1:8]=thetanew
J=HESS(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
S=SCORE(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)
JIN=solve(J)
thetaold=theta[1:8]
thetanew=thetaold-JIN%*%S
thetanew
theta[1:8]=thetanew
theta=c(10.13424359,  1.42879083,  -0.01515581, 150.30959820,  59.65823292,   1.34175619  ,-0.55150142,   1.24539542, 0.26473121 ,  0.62044137 ,  0.63596122 ,  0.52967109 ,  1.37157817,   2.49614933 , -0.06740899 , -0.12224056, 13.55505483 ,  0.26066829  ,-0.17698405 , -0.24614825 , 80.09952504)#
a=theta[1]; b=theta[2]; c=theta[3]; Linf=theta[4]; mu01=theta[5]; k=theta[6]; theta1=theta[7]; theta2=theta[8]; tau1=theta[9];tau2=theta[10]; tau3=theta[11]; Tlib1=theta[12]; Tlib2=theta[13]; Tlib3=theta[14]; SIN1=theta[15]; COS1=theta[16]; SIN2=theta[17]; COS2=theta[18]; SIN3=theta[19]; COS3=theta[20]; l=theta[21];
J=HESS(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
S=SCORE(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
JIN=solve(J)#
thetaold=theta[1:8]#
thetanew=thetaold-JIN%*%S#
#
theta[1:8]=thetanew
theta
thetaold
a=theta[1]; b=theta[2]; c=theta[3]; Linf=theta[4]; mu01=theta[5]; k=theta[6]; theta1=theta[7]; theta2=theta[8]; tau1=theta[9];tau2=theta[10]; tau3=theta[11]; Tlib1=theta[12]; Tlib2=theta[13]; Tlib3=theta[14]; SIN1=theta[15]; COS1=theta[16]; SIN2=theta[17]; COS2=theta[18]; SIN3=theta[19]; COS3=theta[20]; l=theta[21];#
J=HESS(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
S=SCORE(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
JIN=solve(J)#
thetaold=theta[1:8]#
thetanew=thetaold-JIN%*%S#
#
theta[1:8]=thetanew#
theta[1:8]
theta=c(10.13424359,  1.42879083,  -0.01515581, 150.30959820,  59.65823292,   1.34175619  ,-0.55150142,   1.24539542, 0.26473121 ,  0.62044137 ,  0.63596122 ,  0.52967109 ,  1.37157817,   2.49614933 , -0.06740899 , -0.12224056, 13.55505483 ,  0.26066829  ,-0.17698405 , -0.24614825 , 80.09952504)#
a=theta[1]; b=theta[2]; c=theta[3]; Linf=theta[4]; mu01=theta[5]; k=theta[6]; theta1=theta[7]; theta2=theta[8]; tau1=theta[9];tau2=theta[10]; tau3=theta[11]; Tlib1=theta[12]; Tlib2=theta[13]; Tlib3=theta[14]; SIN1=theta[15]; COS1=theta[16]; SIN2=theta[17]; COS2=theta[18]; SIN3=theta[19]; COS3=theta[20]; l=theta[21];#
J=HESS(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
S=SCORE(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)
JIN=solve(J)
thetaold=theta[1:8]
thetaold
JIN
S
JIN%*%S
JIN=solve(J)#
thetaold=theta[1:8]#
thetanew=thetaold-JIN%*%S#
#
theta[1:8]=thetanew#
theta[1:8]
theta
a=theta[1]; b=theta[2]; c=theta[3]; Linf=theta[4]; mu01=theta[5]; k=theta[6]; theta1=theta[7]; theta2=theta[8]; tau1=theta[9];tau2=theta[10]; tau3=theta[11]; Tlib1=theta[12]; Tlib2=theta[13]; Tlib3=theta[14]; SIN1=theta[15]; COS1=theta[16]; SIN2=theta[17]; COS2=theta[18]; SIN3=theta[19]; COS3=theta[20]; l=theta[21];
J=HESS(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
S=SCORE(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)
JIN=solve(J)#
thetaold=theta[1:8]#
thetanew=thetaold-JIN%*%S
thetanew
JIN=solve(J)#
thetaold=theta[1:8]#
thetanew=thetaold-JIN%*%S#
#
theta[1:8]=thetanew#
theta[1:8]
a=theta[1]; b=theta[2]; c=theta[3]; Linf=theta[4]; mu01=theta[5]; k=theta[6]; theta1=theta[7]; theta2=theta[8]; tau1=theta[9];tau2=theta[10]; tau3=theta[11]; Tlib1=theta[12]; Tlib2=theta[13]; Tlib3=theta[14]; SIN1=theta[15]; COS1=theta[16]; SIN2=theta[17]; COS2=theta[18]; SIN3=theta[19]; COS3=theta[20]; l=theta[21];#
J=HESS(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
S=SCORE(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
JIN=solve(J)#
thetaold=theta[1:8]#
thetanew=thetaold-JIN%*%S#
#
theta[1:8]=thetanew#
theta[1:8]
a=10; b=1; c=-0.05; Linf=150; mu01=60; k=1; theta1=-1; theta2=1; tau1=0.333; tau2=0.333; tau3=0.333; Tlib1=0.5; Tlib2=1.5; Tlib3=2.5; SIN1=0.05; COS1=0.05; SIN2=0.05; COS2=0.05; SIN3=0.05; COS3=0.05; l=80;#
theta=c(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
#
STRVAL=function(theta)#
{#
	a=theta[1]; b=theta[2]; c=theta[3]; Linf=theta[4]; mu01=theta[5]; k=theta[6]; theta1=theta[7]; theta2=theta[8]; tau1=theta[9];tau2=theta[10]; tau3=theta[11]; Tlib1=theta[12]; Tlib2=theta[13]; Tlib3=theta[14]; SIN1=theta[15]; COS1=theta[16]; SIN2=theta[17]; COS2=theta[18]; SIN3=theta[19]; COS3=theta[20]; l=theta[21];#
	J=HESS(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
	print(theta)#
	print(det(J))#
	det(J)#
}#
optim(theta,STRVAL,control=list(maxit=1000))
res=optim(theta,STRVAL,control=list(maxit=1000))
res$par
theta=res$par
=theta[1]; b=theta[2]; c=theta[3]; Linf=theta[4]; mu01=theta[5]; k=theta[6]; theta1=theta[7]; theta2=theta[8]; tau1=theta[9];tau2=theta[10]; tau3=theta[11]; Tlib1=theta[12]; Tlib2=theta[13]; Tlib3=theta[14]; SIN1=theta[15]; COS1=theta[16]; SIN2=theta[17]; COS2=theta[18]; SIN3=theta[19]; COS3=theta[20]; l=theta[21];#
J=HESS(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
S=SCORE(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)
a=theta[1]; b=theta[2]; c=theta[3]; Linf=theta[4]; mu01=theta[5]; k=theta[6]; theta1=theta[7]; theta2=theta[8]; tau1=theta[9];tau2=theta[10]; tau3=theta[11]; Tlib1=theta[12]; Tlib2=theta[13]; Tlib3=theta[14]; SIN1=theta[15]; COS1=theta[16]; SIN2=theta[17]; COS2=theta[18]; SIN3=theta[19]; COS3=theta[20]; l=theta[21];#
J=HESS(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)#
S=SCORE(a,b,c, Linf, mu01, k, theta1, theta2, tau1, tau2,tau3, Tlib1, Tlib2, Tlib3, SIN1, COS1, SIN2, COS2, SIN3, COS3,l)
JIN=solve(J)
theta
det(J)
c( 1.373796e+00,  2.407969e-01,  9.703210e-01,  1.465966e+02,  5.934738e+01, 8.475229e+01, -2.093749e+04,  1.125339e+01, -6.980212e-02)
x=c( 1.373796e+00,  2.407969e-01,  9.703210e-01,  1.465966e+02,  5.934738e+01, 8.475229e+01, -2.093749e+04,  1.125339e+01, -6.980212e-02)
round(x,3)
c(3,9.7,4.5,7.2,9.23)
xc(3,9.7,4.5,7.2,9.23)
x=c(3,9.7,4.5,7.2,9.23)
mean(x)
std(x)
sd(x)
x-mean(x)
###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	#Set the necessary working directories#
	#setwd("/Users/uqllloyd/Dropbox/AAUni/APhD/Blueswimmer/CrabStuff2withMMAlg/RcodesData")#
	setwd("~/Dropbox/AAUni/APhD/Blueswimmer/RcodeData_03:10:2014/")#
	#Remove any old objects#
	rm(list = ls())#
	#DATA PRELIMINARIES#
	#Read in the data set on the asymptotic males that was gathered through pots#
	LFD_bigMalesFemales<-read.table("LFD_bigMalesFem",header=T)#
	#Pull out the lengths and the dates from these data files#
	Dates1<-as.Date(LFD_bigMalesFemales$Date,"%d/%m/%y")               #
	Lengths1<-LFD_bigMalesFemales$Carapacewidth#
	#Read in the trawl data on males that contains juvenile recruitment and adults#
	LFD<-read.table("LFD")#
	#which(LFD$Sex==1)#
	#Pull out the lengths and the dates from these data files#
	Dates2<-as.Date(LFD$Date,"%d/%m/%Y")#
	Lengths2<-LFD$Carapace.width#
	#Concatenate the necessary elements from each file into a common dates and lengths array#
	Dates <- c(Dates2,Dates1)#
	Lengths <- c(Lengths2,Lengths1)#
	#Pull out the year and month information from these dates#
	YEAR <- format(Dates,'%Y')#
	MONTHS <- format(Dates,'%m')#
	#Pull out the years and months that we a re interested in i.e., those that don't contain 	recruitment#
	WHICH85JO <- which((YEAR == '1985') & (as.numeric(MONTHS) %in% (2:8)))#
	WHICH86FM <- which((YEAR == '1986') & (as.numeric(MONTHS) %in% (2:5)))#
	#INITIALISE#
	MON <- 11													#Assign how many months we would like to model#
	LL <- Lengths[c(WHICH85JO,WHICH86FM)]						#Assign the number of individuals#
	MM1985 <- as.numeric(MONTHS[WHICH85JO])-1					#Assign January to be the 0th months#
	MM1986 <- as.numeric(MONTHS[WHICH86FM])+11					#Thus January of next year will be the 12 month. Plus we do this so that we don't have to estimate yr#
	MM<-c(MM1985,MM1986)										#Concatenate these months values together#
	MMLIST <- as.numeric(names(table(MM)))						#Make a list of the months from January first i.e., January 1986 is gets assigned a 12#
	#Parameter Initialise#
	NN <- length(MM)											#Initialise the number of individuals we have#
	PI1 <- rep(1/3,MON)											#Initialise the PIs#
	PI2 <- rep(1/3,MON)											#Initialise the PIs#
	K0 <- 1														#Initialise K0 average K#
	LINF <- 200													#Initialise asym length#
	M01<-40														#Initialise first month's average length#
	M02<-40														#Initialise second month's average length#
	T0 <- 0.1														#Initialise first seasonality parameter#
	T1 <- 0.1														#Initialise second seasonality parameter#
	VV <- c(100,0,0)										   #Initialise the starting values for the variance quadratic update#
	#Setting values for drawing plots #
	#K0=0.84062808;  LINF=159.65387413; M01=58.86155838; M02=81.29860313; T0=-0.07925965; T1=0.57794716; VV=c( -4.77584147,   6.19436755  ,-0.03489903)#
	#0.84062808  -0.07925965   0.57794716 159.65387413  58.86155838  81.29860313  -4.77584147   6.19436755  -0.03489903#
	#FUNCTIONS#
	#ASYMPTOTIC MEAN FUNCTION#
	MU2A <- function(mm,K0,T0,T1,LINF,M01,M02)#
	{#
	  #mm=1#
	  mmval <- MMLIST[mm]%%12#
	  yrsold<-2#
	  strmnth<-min(MM1985)#
	  strmid<-strmnth/12+1/24+yrsold#
	  endmid<-strmid+1#
	  mm2=(mmval/12)+1/24+yrsold#
	  t<-seq(0,1,0.01)#
	  g<-K0+T0*cos(2*pi*t)+T1*sin(2*pi*t)#
	  #plot(t,g)#
	  Isneg<-min(g)#
	  Isneg2<-max(g)#
	  if (Isneg<0&Isneg2>0)#
	  {#
	    a=T0^2+T1^2#
		b=2*K0*T0#
		c=-(T1^2)+K0^2#
		u1=(-b+sqrt(b^2-4*a*c))/(2*a)#
		u2=(-b-sqrt(b^2-4*a*c))/(2*a)#
		r11=1-acos(u1)/(2*pi)+yrsold#
		r12=acos(u1)/(2*pi)+yrsold#
		r21=1-acos(u2)/(2*pi)+yrsold#
		r22=acos(u2)/(2*pi)+yrsold#
		roots<-c(r11, r12, r21, r22)#
		groot<-K0+T0*cos(2*pi* roots)+T1*sin(2*pi* roots)#
		gmin<-round(groot)#
		r1<-min(roots[which(gmin==0)])#
		r2<-max(roots[which(gmin==0)])#
	    #Regime#
		zMid1=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    zEnd1=K0*(endmid-r2) + (T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*r2)) - (T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*r2))#
	    KKyr<-yrsold*(zEnd1+zMid1)#
	    #Those less than r1#
	    if (mm2<r1) {KK = KKyr + K0*(mm2-strmid) +   (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}#
	    #Those between r1 and r2#
	    if (mm2>r1&mm2<r2) {KK= KKyr + K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))}#
	    #Those after r2#
	    if (mm2>r2)#
	    {#
	    zMid=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    zEnd=K0*(mm2-r2)     + (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*r2))     - (T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*r2))#
	    KK<-zEnd+zMid+KKyr#
	    }#
	  } else {KK=K0*(mm2-strmid)+(T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid)) + yrsold*(K0*(endmid-strmid)+(T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*strmid)) )}#
	  if (MMLIST[mm]>max(MM1985)) {M02 + (LINF-M02)*(1-exp(-KK))} else (M01 + (LINF-M01)*(1-exp(-KK)))#
	}#
	#1 YEAR OLD ADULT's MEAN FUNCTION#
	MUA <- function(mm,K0,T0,T1,LINF,M01,M02)#
	{#
	  mmval <- MMLIST[mm]%%12#
	  yrsold<-1#
	  strmnth<-min(MM1985)#
	  strmid<-strmnth/12+1/24+yrsold#
	  endmid<-strmid+1#
	  mm2=(mmval/12)+1/24+yrsold#
	  t<-seq(0,1,0.01)#
	  g<-K0+T0*cos(2*pi*t)+T1*sin(2*pi*t)#
	  Isneg<-min(g)#
	  Isneg2<-max(g)#
	  if (Isneg<0&Isneg2>0)#
	  {#
	    a=T0^2+T1^2#
		b=2*K0*T0#
		c=-(T1^2)+K0^2#
		u1=(-b+sqrt(b^2-4*a*c))/(2*a)#
		u2=(-b-sqrt(b^2-4*a*c))/(2*a)#
		r11=1-acos(u1)/(2*pi)+yrsold#
		r12=acos(u1)/(2*pi)+yrsold#
		r21=1-acos(u2)/(2*pi)+yrsold#
		r22=acos(u2)/(2*pi)+yrsold#
		roots<-c(r11, r12, r21, r22)#
		groot<-K0+T0*cos(2*pi* roots)+T1*sin(2*pi* roots)#
		gmin<-round(groot)#
		r1<-min(roots[which(gmin==0)])#
		r2<-max(roots[which(gmin==0)])#
	    #Regime#
		zMid1=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    zEnd1=K0*(endmid-r2) + (T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*r2)) - (T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*r2))#
	    KKyr<-yrsold*(zEnd1+zMid1)#
	    	#Those less than r1#
	    	if (mm2<r1) {KK = KKyr + K0*(mm2-strmid) +   (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}#
	    	#Those between r1 and r2#
	    	if (mm2>r1&mm2<r2) {KK= KKyr + K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))}#
	    	#Those after r2#
	    	if (mm2>r2)#
	    		{#
	    		zMid=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    		zEnd=K0*(mm2-r2)     + (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*r2))     - (T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*r2))#
	    		KK<-zEnd+zMid+KKyr#
	    		}#
	  } else {KK=K0*(mm2-strmid)+(T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid)) + yrsold*(K0*(endmid-strmid)+(T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*strmid)) )}#
	  if (MMLIST[mm]>max(MM1985)) {M02 + (LINF-M02)*(1-exp(-KK))} else (M01 + (LINF-M01)*(1-exp(-KK)))#
	}#
	#THE JUVENUILES MEAN FUNCTION#
	MUJ <- function(mm,K0,T0,T1,LINF,M01,M02)#
	{#
		#mm=2#
		mmval <- MMLIST[mm]%%12#
	  	yrsold<-0#
	  	strmnth<-min(MM1985)#
	  	strmid<-strmnth/12+1/24+yrsold#
	  	endmid<-strmid+1#
	  	mm2=(mmval/12)+1/24+yrsold#
	  	t<-seq(0,1,0.01)#
		g<-K0+T0*cos(2*pi*t)+T1*sin(2*pi*t)#
		Isneg<-min(g)#
		Isneg2<-max(g)#
	 	if (Isneg<0&Isneg2>0)#
	  		{#
	    	a=T0^2+T1^2#
			b=2*K0*T0#
			c=-(T1^2)+K0^2#
			u1=(-b+sqrt(b^2-4*a*c))/(2*a)#
			u2=(-b-sqrt(b^2-4*a*c))/(2*a)#
			r11=1-acos(u1)/(2*pi)#
			r12=acos(u1)/(2*pi)#
			r21=1-acos(u2)/(2*pi)#
			r22=acos(u2)/(2*pi)#
			roots<-c(r11, r12, r21, r22)#
			groot<-K0+T0*cos(2*pi* roots)+T1*sin(2*pi* roots)#
			gmin<-round(groot)#
			r1<-min(roots[which(gmin==0)])#
			r2<-max(roots[which(gmin==0)])#
	    	#Regime#
	    	#Those less than r1#
	    		if (mm2<r1) {KK = K0*(mm2-strmid) +   (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}#
	    		#Those between r1 and r2#
	    		if (mm2>r1&mm2<r2) {KK=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))}#
	    		#Those after r2#
	    		if (mm2>r2)#
	    			{#
	    			zMid=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    			zEnd=K0*(mm2-r2)     + (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*r2))     - (T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*r2))#
	    			KK<-zEnd+zMid#
	    			}#
	  	} else {KK=K0*(mm2-strmid)+(T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}	#
	  if (MMLIST[mm]==min(MM1985))  {M01} else if (MMLIST[mm]==min(MM1986)) {M02} else if (MMLIST[mm]>min(MM1985)&MMLIST[mm]<min(MM1986)) {M01 + (LINF-M01)*(1-exp(-KK))} else {M02 + (LINF-M02)*(1-exp(-KK))}#
	}#
	#INITIALISE THE TAU's which are the inclusion probablities to all be a third#
	TAU <- list()#
	for (mm in 1:(MON))#
		{#
	  		TAU[[mm]] <- matrix(1/3,NN,3)#
		}#
	#INITIALISE THE AUXILLARY STORAGE ARRAYS FOR INSIDE LOOP ASSIGNMENT#
	MU2A_AUX <- c()#
	MUA_AUX <- c()#
	MUJ_AUX <- c()#
	for (mm in 1:MON)#
		{#
	 	MU2A_AUX[mm] <- MU2A(mm,K0,T0,T1,LINF,M01,M02)#
	  	MUA_AUX[mm] <- MUA(mm,K0,T0,T1,LINF,M01,M02)#
	 	MUJ_AUX[mm] <- MUJ(mm,K0,T0,T1,LINF,M01,M02)#
		}#
	#INITIALISE THE VARIANCE FUNCTIONS. THEY ARE ALL QUADRATIC FUNCTIONS OF THE MEAN FOR EACH COHORT#
	VARJ <- function(mm,VV,K0,T0,T1,LINF,M01,M02)#
		{#
			max(exp(VV[1])+VV[2]*MUJ(mm,K0,T0,T1,LINF,M01,M02)+VV[3]*MUJ(mm,K0,T0,T1,LINF,M01,M02)^2,1)#
		}#
	VARA <- function(mm,VV,K0,T0,T1,LINF,M01,M02)#
		{#
			max(exp(VV[1])+VV[2]*MUA(mm,K0,T0,T1,LINF,M01,M02)+VV[3]*MUA(mm,K0,T0,T1,LINF,M01,M02)^2,1)#
		}#
	VAR2A <- function(mm,VV,K0,T0,T1,LINF,M01,M02)#
		{#
			max(exp(VV[1])+VV[2]*MU2A(mm,K0,T0,T1,LINF,M01,M02)+VV[3]*MU2A(mm,K0,T0,T1,LINF,M01,M02)^2,1)#
		}#
	#INITIALISE THE LIKELIHOOD FUNCTION#
	LOGLIKE <- 0#
	for (mm in 1:MON)#
	  {#
		LL2<-LL[which(MM==MMLIST[mm])]#
		LikGrp1<-PI1[mm]*dnorm(LL2,MU2A_AUX[mm],sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp2<-PI2[mm]*dnorm(LL2,MUA_AUX[mm],sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  }#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	#THIS LOOP DOES ALL THE WORK AND INCLUDES TWO NELDER MEAD STEPS TO OPTIMISE THE NONLINEAR MEANS AND VARIANCES#
	TOL <- 10^-6#
	LOGOLD <- -Inf#
	while (LOGLIKE - LOGOLD > TOL)#
	{#
	  LOGOLD <- LOGLIKE                     #Assign the current likelihood value to the an old value so we can evaluate the update#
		#UPDATE THE TAU SCORES AND THEN CALCULATE THE PIs GIVEN THESE TAU SCORES#
		for (mm in 1:MON)#
	  	{#
	    	Top1<-PI1[mm]*dnorm(LL,MU2A_AUX[mm],sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02)))							#Calculate the inclusion probablities for group 1#
	    	Top2<-PI2[mm]*dnorm(LL,MUA_AUX[mm],sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02)))								#Calculate the inclusion probablities for group 2#
	    	Bot<- Top1 + Top2 +(1-(PI1[mm]+PI2[mm]))*dnorm(LL,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02)))  #Calculate the sum of each of the classes#
	    	TAU[[mm]][,1] <- Top1/Bot																				#Calculate the first group's tau scores#
	    	TAU[[mm]][,2] <- Top2/Bot																				#Calculate the second group's tau scores#
	   		TAU[[mm]][,3] <- 1-(TAU[[mm]][,1]+TAU[[mm]][,2])													  	#Calculate the third group's tau scores#
	    	PI1[mm] <- sum((MM==MMLIST[mm])*TAU[[mm]][,1])/sum(MM==MMLIST[mm])										#Work out the PIs for group 1#
	    	PI2[mm] <- sum((MM==MMLIST[mm])*TAU[[mm]][,2])/sum(MM==MMLIST[mm])										#Work out the PIs for group 2#
	  	}#
	  #DEFINE THE LIKELIHOOD FUNCTION OUTSIDE THE LOOP TO UPDATE THE MEANS#
	  PARA <- c(K0,T0,T1,LINF,M01,M02)#
	  OPTIFUN <- function(PARA)#
	  {#
	  	LOGLIKE <- 0#
	  		for (mm in 1:MON)#
	  			{#
				LL2<-LL[which(MM==MMLIST[mm])]#
				LikGrp1<-PI1[mm]*dnorm(LL2,MU2A(mm,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]),sqrt(VAR2A(mm,VV,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6])))#
				LikGrp2<-PI2[mm]*dnorm(LL2,MUA(mm,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]),sqrt(VARA(mm,VV,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]))) #
				LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ(mm,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]),sqrt(VARJ(mm,VV,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6])))#
				LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  			}#
		-LOGLIKE#
	  }#
	  OPTIM <- optim(PARA,OPTIFUN, control = list(maxit = 10000))														#RUN OPTIM to find the best parameters given the taus and Pis#
	  print("Did optim 1 converge?")#
	  print(OPTIM$convergence)#
	  #Assign the estimates from optim to the parameters#
	  K0 <- OPTIM$par[1]#
	  T0 <- OPTIM$par[2]#
	  T1 <- OPTIM$par[3]#
	  LINF <- OPTIM$par[4]#
	  M01 <- OPTIM$par[5]#
	  M02<-OPTIM$par[6]#
	  #Calculate the means for each group based on these new estimates#
	  MU2A_AUX <- c()#
	  MUA_AUX <- c()#
	  MUJ_AUX <- c()#
	  for (mm in 1:MON)#
	  {#
	  	#Compute the means for each month #
	    MU2A_AUX[mm] <- MU2A(mm,K0,T0,T1,LINF,M01,M02)#
	    MUA_AUX[mm] <- MUA(mm,K0,T0,T1,LINF,M01,M02)#
	    MUJ_AUX[mm] <- MUJ(mm,K0,T0,T1,LINF,M01,M02)#
	  }#
	  #OPTIMISE THE VARIANCES GIVEN THE NEW MEANS#
	  #DEFINE THE LIKELIHOOD FUNCTION OUTSIDE THE LOOP TO UPDATE THE VARIANCES #
	  PARA2 <- VV#
	  VAROPTIFUN <- function(PARA2)#
	  {#
	  LOGLIKE <- 0#
	  		for (mm in 1:MON)#
	  			{#
	  			#mm=1#
				LL2<-LL[which(MM==MMLIST[mm])]#
				LikGrp1<- PI1[mm]*dnorm(LL2,MU2A_AUX[mm],sqrt(VAR2A(mm,PARA2,K0,T0,T1,LINF,M01,M02)))#
				LikGrp2<- PI2[mm]*dnorm(LL2,MUA_AUX[mm],sqrt(VARA(mm,PARA2,K0,T0,T1,LINF,M01,M02)))#
				LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ_AUX[mm],sqrt(VARJ(mm,PARA2,K0,T0,T1,LINF,M01,M02)))#
				LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  			}#
		-LOGLIKE#
	  }#
	  OPTIM2 <- optim(PARA2,VAROPTIFUN,control = list(maxit = 10000))													#RUN OPTIM to find the best variances given the taus and Pis#
	  VV <- OPTIM2$par#
	  print("Did optim 2 converge?")#
	  print(OPTIM2$convergence)  #
	  #COMPUTE THE LIKELIHOOD GIVEN ALL THESE NICE NEW UPDATES#
	  LOGLIKE <- 0#
	  for (mm in 1:MON)#
	  {#
		LL2<-LL[which(MM==MMLIST[mm])]#
		LikGrp1<-PI1[mm]*dnorm(LL2,MU2A_AUX[mm],sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp2<-PI2[mm]*dnorm(LL2,MUA_AUX[mm],sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  }#
	  #PRINT OUT OUR NEW UPDATES FOR THE PARAMETERS AND THE LIKELIHOOD#
	  print(c(LOGLIKE,LOGLIKE-LOGOLD))#
	  print(c(PARA,PARA2))#
	  #DRAW SOME NICE REAL TIME PLOTS SO WE CAN MONITOR CONVERGENCE#
	  par(mfrow = c(3,5))#
	  XX <- 0:200#
	  xlabNam<-c("Feb., 1985","Mar., 1985","Apr., 1985","May, 1985","Jun., 1985","Jul, 1985","Aug., 1985","Feb., 1986","Mar., 1986","Apr., 1986","May, 1986")#
	  for (mm in 1:MON)#
	  {#
	    hist(LL[which(MM==MMLIST[mm])],breaks=30,prob=T,xlim=c(20,210),ylim=c(0,0.055),xlab=xlabNam[mm],ylab="",main='')#
	    lines(XX,PI1[mm]*dnorm(XX,MU2A(mm,K0,T0,T1,LINF,M01,M02),sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02))),col='red',lwd=2.5)#
	    lines(XX,PI2[mm]*dnorm(XX,MUA(mm,K0,T0,T1,LINF,M01,M02),sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02))),col='green',lwd=2.5)#
	    lines(XX,(1-(PI1[mm]+PI2[mm]))*dnorm(XX,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02))),col='blue',lwd=2.5)#
	  }#
	  XX2 <- seq(0,1,length.out=100)#
	  YY <- K0 + T0*cos(2*pi*XX2) + T1*sin(2*pi*XX2)#
	  plot(XX2,((YY+abs(YY))/2),type='l',xlab="Fraction of a year since Jan 1",ylab="k (per year)",lwd=2.5)#
	  BLAH <- 50:160#
	  plot(BLAH,exp(VV[1])+VV[2]*BLAH+VV[3]*BLAH^2,type='l',xlab="Mean length (mm)", ylab="Variance",lwd=2.5,ylim=c(0,300))#
	  plot(density(rnorm(1000000,PARA[4],sqrt(PARA2[2]*PARA[4]+ PARA2[3]*PARA[4]^2))),xlab="Length (mm)",main="",lwd=2.5)#
	}
###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	#Set the necessary working directories#
	#setwd("/Users/uqllloyd/Dropbox/AAUni/APhD/Blueswimmer/CrabStuff2withMMAlg/RcodesData")#
	setwd("~/Dropbox/AAUni/APhD/Blueswimmer/RcodeData_03:10:2014/")#
	#Remove any old objects#
	rm(list = ls())#
	#DATA PRELIMINARIES#
	#Read in the data set on the asymptotic males that was gathered through pots#
	LFD_bigMalesFemales<-read.table("LFD_bigMalesFem",header=T)#
	#Pull out the lengths and the dates from these data files#
	Dates1<-as.Date(LFD_bigMalesFemales$Date,"%d/%m/%y")               #
	Lengths1<-LFD_bigMalesFemales$Carapacewidth#
	#Read in the trawl data on males that contains juvenile recruitment and adults#
	LFD<-read.table("LFD")#
	#which(LFD$Sex==1)#
	#Pull out the lengths and the dates from these data files#
	Dates2<-as.Date(LFD$Date,"%d/%m/%Y")#
	Lengths2<-LFD$Carapace.width#
	#Concatenate the necessary elements from each file into a common dates and lengths array#
	Dates <- c(Dates2,Dates1)#
	Lengths <- c(Lengths2,Lengths1)#
	#Pull out the year and month information from these dates#
	YEAR <- format(Dates,'%Y')#
	MONTHS <- format(Dates,'%m')#
	#Pull out the years and months that we a re interested in i.e., those that don't contain 	recruitment#
	WHICH85JO <- which((YEAR == '1985') & (as.numeric(MONTHS) %in% (2:8)))#
	WHICH86FM <- which((YEAR == '1986') & (as.numeric(MONTHS) %in% (2:5)))#
	#INITIALISE#
	MON <- 11													#Assign how many months we would like to model#
	LL <- Lengths[c(WHICH85JO,WHICH86FM)]						#Assign the number of individuals#
	MM1985 <- as.numeric(MONTHS[WHICH85JO])-1					#Assign January to be the 0th months#
	MM1986 <- as.numeric(MONTHS[WHICH86FM])+11					#Thus January of next year will be the 12 month. Plus we do this so that we don't have to estimate yr#
	MM<-c(MM1985,MM1986)										#Concatenate these months values together#
	MMLIST <- as.numeric(names(table(MM)))						#Make a list of the months from January first i.e., January 1986 is gets assigned a 12#
	#Parameter Initialise#
	NN <- length(MM)											#Initialise the number of individuals we have#
	PI1 <- rep(1/3,MON)											#Initialise the PIs#
	PI2 <- rep(1/3,MON)											#Initialise the PIs#
	K0 <- 1														#Initialise K0 average K#
	LINF <- 200													#Initialise asym length#
	M01<-40														#Initialise first month's average length#
	M02<-40														#Initialise second month's average length#
	T0 <- 0.1														#Initialise first seasonality parameter#
	T1 <- 0.1														#Initialise second seasonality parameter#
	VV <- c(-10,10,0.1)										   #Initialise the starting values for the variance quadratic update#
	#Setting values for drawing plots #
	#K0=0.84062808;  LINF=159.65387413; M01=58.86155838; M02=81.29860313; T0=-0.07925965; T1=0.57794716; VV=c( -4.77584147,   6.19436755  ,-0.03489903)#
	#0.84062808  -0.07925965   0.57794716 159.65387413  58.86155838  81.29860313  -4.77584147   6.19436755  -0.03489903#
	#FUNCTIONS#
	#ASYMPTOTIC MEAN FUNCTION#
	MU2A <- function(mm,K0,T0,T1,LINF,M01,M02)#
	{#
	  #mm=1#
	  mmval <- MMLIST[mm]%%12#
	  yrsold<-2#
	  strmnth<-min(MM1985)#
	  strmid<-strmnth/12+1/24+yrsold#
	  endmid<-strmid+1#
	  mm2=(mmval/12)+1/24+yrsold#
	  t<-seq(0,1,0.01)#
	  g<-K0+T0*cos(2*pi*t)+T1*sin(2*pi*t)#
	  #plot(t,g)#
	  Isneg<-min(g)#
	  Isneg2<-max(g)#
	  if (Isneg<0&Isneg2>0)#
	  {#
	    a=T0^2+T1^2#
		b=2*K0*T0#
		c=-(T1^2)+K0^2#
		u1=(-b+sqrt(b^2-4*a*c))/(2*a)#
		u2=(-b-sqrt(b^2-4*a*c))/(2*a)#
		r11=1-acos(u1)/(2*pi)+yrsold#
		r12=acos(u1)/(2*pi)+yrsold#
		r21=1-acos(u2)/(2*pi)+yrsold#
		r22=acos(u2)/(2*pi)+yrsold#
		roots<-c(r11, r12, r21, r22)#
		groot<-K0+T0*cos(2*pi* roots)+T1*sin(2*pi* roots)#
		gmin<-round(groot)#
		r1<-min(roots[which(gmin==0)])#
		r2<-max(roots[which(gmin==0)])#
	    #Regime#
		zMid1=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    zEnd1=K0*(endmid-r2) + (T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*r2)) - (T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*r2))#
	    KKyr<-yrsold*(zEnd1+zMid1)#
	    #Those less than r1#
	    if (mm2<r1) {KK = KKyr + K0*(mm2-strmid) +   (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}#
	    #Those between r1 and r2#
	    if (mm2>r1&mm2<r2) {KK= KKyr + K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))}#
	    #Those after r2#
	    if (mm2>r2)#
	    {#
	    zMid=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    zEnd=K0*(mm2-r2)     + (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*r2))     - (T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*r2))#
	    KK<-zEnd+zMid+KKyr#
	    }#
	  } else {KK=K0*(mm2-strmid)+(T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid)) + yrsold*(K0*(endmid-strmid)+(T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*strmid)) )}#
	  if (MMLIST[mm]>max(MM1985)) {M02 + (LINF-M02)*(1-exp(-KK))} else (M01 + (LINF-M01)*(1-exp(-KK)))#
	}#
	#1 YEAR OLD ADULT's MEAN FUNCTION#
	MUA <- function(mm,K0,T0,T1,LINF,M01,M02)#
	{#
	  mmval <- MMLIST[mm]%%12#
	  yrsold<-1#
	  strmnth<-min(MM1985)#
	  strmid<-strmnth/12+1/24+yrsold#
	  endmid<-strmid+1#
	  mm2=(mmval/12)+1/24+yrsold#
	  t<-seq(0,1,0.01)#
	  g<-K0+T0*cos(2*pi*t)+T1*sin(2*pi*t)#
	  Isneg<-min(g)#
	  Isneg2<-max(g)#
	  if (Isneg<0&Isneg2>0)#
	  {#
	    a=T0^2+T1^2#
		b=2*K0*T0#
		c=-(T1^2)+K0^2#
		u1=(-b+sqrt(b^2-4*a*c))/(2*a)#
		u2=(-b-sqrt(b^2-4*a*c))/(2*a)#
		r11=1-acos(u1)/(2*pi)+yrsold#
		r12=acos(u1)/(2*pi)+yrsold#
		r21=1-acos(u2)/(2*pi)+yrsold#
		r22=acos(u2)/(2*pi)+yrsold#
		roots<-c(r11, r12, r21, r22)#
		groot<-K0+T0*cos(2*pi* roots)+T1*sin(2*pi* roots)#
		gmin<-round(groot)#
		r1<-min(roots[which(gmin==0)])#
		r2<-max(roots[which(gmin==0)])#
	    #Regime#
		zMid1=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    zEnd1=K0*(endmid-r2) + (T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*r2)) - (T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*r2))#
	    KKyr<-yrsold*(zEnd1+zMid1)#
	    	#Those less than r1#
	    	if (mm2<r1) {KK = KKyr + K0*(mm2-strmid) +   (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}#
	    	#Those between r1 and r2#
	    	if (mm2>r1&mm2<r2) {KK= KKyr + K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))}#
	    	#Those after r2#
	    	if (mm2>r2)#
	    		{#
	    		zMid=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    		zEnd=K0*(mm2-r2)     + (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*r2))     - (T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*r2))#
	    		KK<-zEnd+zMid+KKyr#
	    		}#
	  } else {KK=K0*(mm2-strmid)+(T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid)) + yrsold*(K0*(endmid-strmid)+(T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*strmid)) )}#
	  if (MMLIST[mm]>max(MM1985)) {M02 + (LINF-M02)*(1-exp(-KK))} else (M01 + (LINF-M01)*(1-exp(-KK)))#
	}#
	#THE JUVENUILES MEAN FUNCTION#
	MUJ <- function(mm,K0,T0,T1,LINF,M01,M02)#
	{#
		#mm=2#
		mmval <- MMLIST[mm]%%12#
	  	yrsold<-0#
	  	strmnth<-min(MM1985)#
	  	strmid<-strmnth/12+1/24+yrsold#
	  	endmid<-strmid+1#
	  	mm2=(mmval/12)+1/24+yrsold#
	  	t<-seq(0,1,0.01)#
		g<-K0+T0*cos(2*pi*t)+T1*sin(2*pi*t)#
		Isneg<-min(g)#
		Isneg2<-max(g)#
	 	if (Isneg<0&Isneg2>0)#
	  		{#
	    	a=T0^2+T1^2#
			b=2*K0*T0#
			c=-(T1^2)+K0^2#
			u1=(-b+sqrt(b^2-4*a*c))/(2*a)#
			u2=(-b-sqrt(b^2-4*a*c))/(2*a)#
			r11=1-acos(u1)/(2*pi)#
			r12=acos(u1)/(2*pi)#
			r21=1-acos(u2)/(2*pi)#
			r22=acos(u2)/(2*pi)#
			roots<-c(r11, r12, r21, r22)#
			groot<-K0+T0*cos(2*pi* roots)+T1*sin(2*pi* roots)#
			gmin<-round(groot)#
			r1<-min(roots[which(gmin==0)])#
			r2<-max(roots[which(gmin==0)])#
	    	#Regime#
	    	#Those less than r1#
	    		if (mm2<r1) {KK = K0*(mm2-strmid) +   (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}#
	    		#Those between r1 and r2#
	    		if (mm2>r1&mm2<r2) {KK=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))}#
	    		#Those after r2#
	    		if (mm2>r2)#
	    			{#
	    			zMid=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    			zEnd=K0*(mm2-r2)     + (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*r2))     - (T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*r2))#
	    			KK<-zEnd+zMid#
	    			}#
	  	} else {KK=K0*(mm2-strmid)+(T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}	#
	  if (MMLIST[mm]==min(MM1985))  {M01} else if (MMLIST[mm]==min(MM1986)) {M02} else if (MMLIST[mm]>min(MM1985)&MMLIST[mm]<min(MM1986)) {M01 + (LINF-M01)*(1-exp(-KK))} else {M02 + (LINF-M02)*(1-exp(-KK))}#
	}#
	#INITIALISE THE TAU's which are the inclusion probablities to all be a third#
	TAU <- list()#
	for (mm in 1:(MON))#
		{#
	  		TAU[[mm]] <- matrix(1/3,NN,3)#
		}#
	#INITIALISE THE AUXILLARY STORAGE ARRAYS FOR INSIDE LOOP ASSIGNMENT#
	MU2A_AUX <- c()#
	MUA_AUX <- c()#
	MUJ_AUX <- c()#
	for (mm in 1:MON)#
		{#
	 	MU2A_AUX[mm] <- MU2A(mm,K0,T0,T1,LINF,M01,M02)#
	  	MUA_AUX[mm] <- MUA(mm,K0,T0,T1,LINF,M01,M02)#
	 	MUJ_AUX[mm] <- MUJ(mm,K0,T0,T1,LINF,M01,M02)#
		}#
	#INITIALISE THE VARIANCE FUNCTIONS. THEY ARE ALL QUADRATIC FUNCTIONS OF THE MEAN FOR EACH COHORT#
	VARJ <- function(mm,VV,K0,T0,T1,LINF,M01,M02)#
		{#
			max(exp(VV[1])+VV[2]*MUJ(mm,K0,T0,T1,LINF,M01,M02)+VV[3]*MUJ(mm,K0,T0,T1,LINF,M01,M02)^2,1)#
		}#
	VARA <- function(mm,VV,K0,T0,T1,LINF,M01,M02)#
		{#
			max(exp(VV[1])+VV[2]*MUA(mm,K0,T0,T1,LINF,M01,M02)+VV[3]*MUA(mm,K0,T0,T1,LINF,M01,M02)^2,1)#
		}#
	VAR2A <- function(mm,VV,K0,T0,T1,LINF,M01,M02)#
		{#
			max(exp(VV[1])+VV[2]*MU2A(mm,K0,T0,T1,LINF,M01,M02)+VV[3]*MU2A(mm,K0,T0,T1,LINF,M01,M02)^2,1)#
		}#
	#INITIALISE THE LIKELIHOOD FUNCTION#
	LOGLIKE <- 0#
	for (mm in 1:MON)#
	  {#
		LL2<-LL[which(MM==MMLIST[mm])]#
		LikGrp1<-PI1[mm]*dnorm(LL2,MU2A_AUX[mm],sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp2<-PI2[mm]*dnorm(LL2,MUA_AUX[mm],sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  }#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	#THIS LOOP DOES ALL THE WORK AND INCLUDES TWO NELDER MEAD STEPS TO OPTIMISE THE NONLINEAR MEANS AND VARIANCES#
	TOL <- 10^-6#
	LOGOLD <- -Inf#
	while (LOGLIKE - LOGOLD > TOL)#
	{#
	  LOGOLD <- LOGLIKE                     #Assign the current likelihood value to the an old value so we can evaluate the update#
		#UPDATE THE TAU SCORES AND THEN CALCULATE THE PIs GIVEN THESE TAU SCORES#
		for (mm in 1:MON)#
	  	{#
	    	Top1<-PI1[mm]*dnorm(LL,MU2A_AUX[mm],sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02)))							#Calculate the inclusion probablities for group 1#
	    	Top2<-PI2[mm]*dnorm(LL,MUA_AUX[mm],sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02)))								#Calculate the inclusion probablities for group 2#
	    	Bot<- Top1 + Top2 +(1-(PI1[mm]+PI2[mm]))*dnorm(LL,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02)))  #Calculate the sum of each of the classes#
	    	TAU[[mm]][,1] <- Top1/Bot																				#Calculate the first group's tau scores#
	    	TAU[[mm]][,2] <- Top2/Bot																				#Calculate the second group's tau scores#
	   		TAU[[mm]][,3] <- 1-(TAU[[mm]][,1]+TAU[[mm]][,2])													  	#Calculate the third group's tau scores#
	    	PI1[mm] <- sum((MM==MMLIST[mm])*TAU[[mm]][,1])/sum(MM==MMLIST[mm])										#Work out the PIs for group 1#
	    	PI2[mm] <- sum((MM==MMLIST[mm])*TAU[[mm]][,2])/sum(MM==MMLIST[mm])										#Work out the PIs for group 2#
	  	}#
	  #DEFINE THE LIKELIHOOD FUNCTION OUTSIDE THE LOOP TO UPDATE THE MEANS#
	  PARA <- c(K0,T0,T1,LINF,M01,M02)#
	  OPTIFUN <- function(PARA)#
	  {#
	  	LOGLIKE <- 0#
	  		for (mm in 1:MON)#
	  			{#
				LL2<-LL[which(MM==MMLIST[mm])]#
				LikGrp1<-PI1[mm]*dnorm(LL2,MU2A(mm,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]),sqrt(VAR2A(mm,VV,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6])))#
				LikGrp2<-PI2[mm]*dnorm(LL2,MUA(mm,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]),sqrt(VARA(mm,VV,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]))) #
				LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ(mm,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]),sqrt(VARJ(mm,VV,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6])))#
				LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  			}#
		-LOGLIKE#
	  }#
	  OPTIM <- optim(PARA,OPTIFUN, control = list(maxit = 10000))														#RUN OPTIM to find the best parameters given the taus and Pis#
	  print("Did optim 1 converge?")#
	  print(OPTIM$convergence)#
	  #Assign the estimates from optim to the parameters#
	  K0 <- OPTIM$par[1]#
	  T0 <- OPTIM$par[2]#
	  T1 <- OPTIM$par[3]#
	  LINF <- OPTIM$par[4]#
	  M01 <- OPTIM$par[5]#
	  M02<-OPTIM$par[6]#
	  #Calculate the means for each group based on these new estimates#
	  MU2A_AUX <- c()#
	  MUA_AUX <- c()#
	  MUJ_AUX <- c()#
	  for (mm in 1:MON)#
	  {#
	  	#Compute the means for each month #
	    MU2A_AUX[mm] <- MU2A(mm,K0,T0,T1,LINF,M01,M02)#
	    MUA_AUX[mm] <- MUA(mm,K0,T0,T1,LINF,M01,M02)#
	    MUJ_AUX[mm] <- MUJ(mm,K0,T0,T1,LINF,M01,M02)#
	  }#
	  #OPTIMISE THE VARIANCES GIVEN THE NEW MEANS#
	  #DEFINE THE LIKELIHOOD FUNCTION OUTSIDE THE LOOP TO UPDATE THE VARIANCES #
	  PARA2 <- VV#
	  VAROPTIFUN <- function(PARA2)#
	  {#
	  LOGLIKE <- 0#
	  		for (mm in 1:MON)#
	  			{#
	  			#mm=1#
				LL2<-LL[which(MM==MMLIST[mm])]#
				LikGrp1<- PI1[mm]*dnorm(LL2,MU2A_AUX[mm],sqrt(VAR2A(mm,PARA2,K0,T0,T1,LINF,M01,M02)))#
				LikGrp2<- PI2[mm]*dnorm(LL2,MUA_AUX[mm],sqrt(VARA(mm,PARA2,K0,T0,T1,LINF,M01,M02)))#
				LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ_AUX[mm],sqrt(VARJ(mm,PARA2,K0,T0,T1,LINF,M01,M02)))#
				LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  			}#
		-LOGLIKE#
	  }#
	  OPTIM2 <- optim(PARA2,VAROPTIFUN,control = list(maxit = 10000))													#RUN OPTIM to find the best variances given the taus and Pis#
	  VV <- OPTIM2$par#
	  print("Did optim 2 converge?")#
	  print(OPTIM2$convergence)  #
	  #COMPUTE THE LIKELIHOOD GIVEN ALL THESE NICE NEW UPDATES#
	  LOGLIKE <- 0#
	  for (mm in 1:MON)#
	  {#
		LL2<-LL[which(MM==MMLIST[mm])]#
		LikGrp1<-PI1[mm]*dnorm(LL2,MU2A_AUX[mm],sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp2<-PI2[mm]*dnorm(LL2,MUA_AUX[mm],sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  }#
	  #PRINT OUT OUR NEW UPDATES FOR THE PARAMETERS AND THE LIKELIHOOD#
	  print(c(LOGLIKE,LOGLIKE-LOGOLD))#
	  print(c(PARA,PARA2))#
	  #DRAW SOME NICE REAL TIME PLOTS SO WE CAN MONITOR CONVERGENCE#
	  par(mfrow = c(3,5))#
	  XX <- 0:200#
	  xlabNam<-c("Feb., 1985","Mar., 1985","Apr., 1985","May, 1985","Jun., 1985","Jul, 1985","Aug., 1985","Feb., 1986","Mar., 1986","Apr., 1986","May, 1986")#
	  for (mm in 1:MON)#
	  {#
	    hist(LL[which(MM==MMLIST[mm])],breaks=30,prob=T,xlim=c(20,210),ylim=c(0,0.055),xlab=xlabNam[mm],ylab="",main='')#
	    lines(XX,PI1[mm]*dnorm(XX,MU2A(mm,K0,T0,T1,LINF,M01,M02),sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02))),col='red',lwd=2.5)#
	    lines(XX,PI2[mm]*dnorm(XX,MUA(mm,K0,T0,T1,LINF,M01,M02),sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02))),col='green',lwd=2.5)#
	    lines(XX,(1-(PI1[mm]+PI2[mm]))*dnorm(XX,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02))),col='blue',lwd=2.5)#
	  }#
	  XX2 <- seq(0,1,length.out=100)#
	  YY <- K0 + T0*cos(2*pi*XX2) + T1*sin(2*pi*XX2)#
	  plot(XX2,((YY+abs(YY))/2),type='l',xlab="Fraction of a year since Jan 1",ylab="k (per year)",lwd=2.5)#
	  BLAH <- 50:160#
	  plot(BLAH,exp(VV[1])+VV[2]*BLAH+VV[3]*BLAH^2,type='l',xlab="Mean length (mm)", ylab="Variance",lwd=2.5,ylim=c(0,300))#
	  plot(density(rnorm(1000000,PARA[4],sqrt(PARA2[2]*PARA[4]+ PARA2[3]*PARA[4]^2))),xlab="Length (mm)",main="",lwd=2.5)#
	}
###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	#Set the necessary working directories#
	#setwd("/Users/uqllloyd/Dropbox/AAUni/APhD/Blueswimmer/CrabStuff2withMMAlg/RcodesData")#
	setwd("~/Dropbox/AAUni/APhD/Blueswimmer/RcodeData_03:10:2014/")#
	#Remove any old objects#
	rm(list = ls())#
	#DATA PRELIMINARIES#
	#Read in the data set on the asymptotic males that was gathered through pots#
	LFD_bigMalesFemales<-read.table("LFD_bigMalesFem",header=T)#
	#Pull out the lengths and the dates from these data files#
	Dates1<-as.Date(LFD_bigMalesFemales$Date,"%d/%m/%y")               #
	Lengths1<-LFD_bigMalesFemales$Carapacewidth#
	#Read in the trawl data on males that contains juvenile recruitment and adults#
	LFD<-read.table("LFD")#
	#which(LFD$Sex==1)#
	#Pull out the lengths and the dates from these data files#
	Dates2<-as.Date(LFD$Date,"%d/%m/%Y")#
	Lengths2<-LFD$Carapace.width#
	#Concatenate the necessary elements from each file into a common dates and lengths array#
	Dates <- c(Dates2,Dates1)#
	Lengths <- c(Lengths2,Lengths1)#
	#Pull out the year and month information from these dates#
	YEAR <- format(Dates,'%Y')#
	MONTHS <- format(Dates,'%m')#
	#Pull out the years and months that we a re interested in i.e., those that don't contain 	recruitment#
	WHICH85JO <- which((YEAR == '1985') & (as.numeric(MONTHS) %in% (2:8)))#
	WHICH86FM <- which((YEAR == '1986') & (as.numeric(MONTHS) %in% (2:5)))#
	#INITIALISE#
	MON <- 11													#Assign how many months we would like to model#
	LL <- Lengths[c(WHICH85JO,WHICH86FM)]						#Assign the number of individuals#
	MM1985 <- as.numeric(MONTHS[WHICH85JO])-1					#Assign January to be the 0th months#
	MM1986 <- as.numeric(MONTHS[WHICH86FM])+11					#Thus January of next year will be the 12 month. Plus we do this so that we don't have to estimate yr#
	MM<-c(MM1985,MM1986)										#Concatenate these months values together#
	MMLIST <- as.numeric(names(table(MM)))						#Make a list of the months from January first i.e., January 1986 is gets assigned a 12#
	#Parameter Initialise#
	NN <- length(MM)											#Initialise the number of individuals we have#
	PI1 <- rep(1/3,MON)											#Initialise the PIs#
	PI2 <- rep(1/3,MON)											#Initialise the PIs#
	K0 <- 1														#Initialise K0 average K#
	LINF <- 200													#Initialise asym length#
	M01<-40														#Initialise first month's average length#
	M02<-40														#Initialise second month's average length#
	T0 <- 0.1														#Initialise first seasonality parameter#
	T1 <- 0.1														#Initialise second seasonality parameter#
	VV <- c(-10,10,0.1)										   #Initialise the starting values for the variance quadratic update#
	#Setting values for drawing plots #
	#K0=0.84062808;  LINF=159.65387413; M01=58.86155838; M02=81.29860313; T0=-0.07925965; T1=0.57794716; VV=c( -4.77584147,   6.19436755  ,-0.03489903)#
	#0.84062808  -0.07925965   0.57794716 159.65387413  58.86155838  81.29860313  -4.77584147   6.19436755  -0.03489903#
	#FUNCTIONS#
	#ASYMPTOTIC MEAN FUNCTION#
	MU2A <- function(mm,K0,T0,T1,LINF,M01,M02)#
	{#
	  #mm=1#
	  mmval <- MMLIST[mm]%%12#
	  yrsold<-2#
	  strmnth<-min(MM1985)#
	  strmid<-strmnth/12+1/24+yrsold#
	  endmid<-strmid+1#
	  mm2=(mmval/12)+1/24+yrsold#
	  t<-seq(0,1,0.01)#
	  g<-K0+T0*cos(2*pi*t)+T1*sin(2*pi*t)#
	  #plot(t,g)#
	  Isneg<-min(g)#
	  Isneg2<-max(g)#
	  if (Isneg<0&Isneg2>0)#
	  {#
	    a=T0^2+T1^2#
		b=2*K0*T0#
		c=-(T1^2)+K0^2#
		u1=(-b+sqrt(b^2-4*a*c))/(2*a)#
		u2=(-b-sqrt(b^2-4*a*c))/(2*a)#
		r11=1-acos(u1)/(2*pi)+yrsold#
		r12=acos(u1)/(2*pi)+yrsold#
		r21=1-acos(u2)/(2*pi)+yrsold#
		r22=acos(u2)/(2*pi)+yrsold#
		roots<-c(r11, r12, r21, r22)#
		groot<-K0+T0*cos(2*pi* roots)+T1*sin(2*pi* roots)#
		gmin<-round(groot)#
		r1<-min(roots[which(gmin==0)])#
		r2<-max(roots[which(gmin==0)])#
	    #Regime#
		zMid1=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    zEnd1=K0*(endmid-r2) + (T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*r2)) - (T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*r2))#
	    KKyr<-yrsold*(zEnd1+zMid1)#
	    #Those less than r1#
	    if (mm2<r1) {KK = KKyr + K0*(mm2-strmid) +   (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}#
	    #Those between r1 and r2#
	    if (mm2>r1&mm2<r2) {KK= KKyr + K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))}#
	    #Those after r2#
	    if (mm2>r2)#
	    {#
	    zMid=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    zEnd=K0*(mm2-r2)     + (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*r2))     - (T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*r2))#
	    KK<-zEnd+zMid+KKyr#
	    }#
	  } else {KK=K0*(mm2-strmid)+(T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid)) + yrsold*(K0*(endmid-strmid)+(T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*strmid)) )}#
	  if (MMLIST[mm]>max(MM1985)) {M02 + (LINF-M02)*(1-exp(-KK))} else (M01 + (LINF-M01)*(1-exp(-KK)))#
	}#
	#1 YEAR OLD ADULT's MEAN FUNCTION#
	MUA <- function(mm,K0,T0,T1,LINF,M01,M02)#
	{#
	  mmval <- MMLIST[mm]%%12#
	  yrsold<-1#
	  strmnth<-min(MM1985)#
	  strmid<-strmnth/12+1/24+yrsold#
	  endmid<-strmid+1#
	  mm2=(mmval/12)+1/24+yrsold#
	  t<-seq(0,1,0.01)#
	  g<-K0+T0*cos(2*pi*t)+T1*sin(2*pi*t)#
	  Isneg<-min(g)#
	  Isneg2<-max(g)#
	  if (Isneg<0&Isneg2>0)#
	  {#
	    a=T0^2+T1^2#
		b=2*K0*T0#
		c=-(T1^2)+K0^2#
		u1=(-b+sqrt(b^2-4*a*c))/(2*a)#
		u2=(-b-sqrt(b^2-4*a*c))/(2*a)#
		r11=1-acos(u1)/(2*pi)+yrsold#
		r12=acos(u1)/(2*pi)+yrsold#
		r21=1-acos(u2)/(2*pi)+yrsold#
		r22=acos(u2)/(2*pi)+yrsold#
		roots<-c(r11, r12, r21, r22)#
		groot<-K0+T0*cos(2*pi* roots)+T1*sin(2*pi* roots)#
		gmin<-round(groot)#
		r1<-min(roots[which(gmin==0)])#
		r2<-max(roots[which(gmin==0)])#
	    #Regime#
		zMid1=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    zEnd1=K0*(endmid-r2) + (T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*r2)) - (T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*r2))#
	    KKyr<-yrsold*(zEnd1+zMid1)#
	    	#Those less than r1#
	    	if (mm2<r1) {KK = KKyr + K0*(mm2-strmid) +   (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}#
	    	#Those between r1 and r2#
	    	if (mm2>r1&mm2<r2) {KK= KKyr + K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))}#
	    	#Those after r2#
	    	if (mm2>r2)#
	    		{#
	    		zMid=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    		zEnd=K0*(mm2-r2)     + (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*r2))     - (T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*r2))#
	    		KK<-zEnd+zMid+KKyr#
	    		}#
	  } else {KK=K0*(mm2-strmid)+(T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid)) + yrsold*(K0*(endmid-strmid)+(T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*strmid)) )}#
	  if (MMLIST[mm]>max(MM1985)) {M02 + (LINF-M02)*(1-exp(-KK))} else (M01 + (LINF-M01)*(1-exp(-KK)))#
	}#
	#THE JUVENUILES MEAN FUNCTION#
	MUJ <- function(mm,K0,T0,T1,LINF,M01,M02)#
	{#
		#mm=2#
		mmval <- MMLIST[mm]%%12#
	  	yrsold<-0#
	  	strmnth<-min(MM1985)#
	  	strmid<-strmnth/12+1/24+yrsold#
	  	endmid<-strmid+1#
	  	mm2=(mmval/12)+1/24+yrsold#
	  	t<-seq(0,1,0.01)#
		g<-K0+T0*cos(2*pi*t)+T1*sin(2*pi*t)#
		Isneg<-min(g)#
		Isneg2<-max(g)#
	 	if (Isneg<0&Isneg2>0)#
	  		{#
	    	a=T0^2+T1^2#
			b=2*K0*T0#
			c=-(T1^2)+K0^2#
			u1=(-b+sqrt(b^2-4*a*c))/(2*a)#
			u2=(-b-sqrt(b^2-4*a*c))/(2*a)#
			r11=1-acos(u1)/(2*pi)#
			r12=acos(u1)/(2*pi)#
			r21=1-acos(u2)/(2*pi)#
			r22=acos(u2)/(2*pi)#
			roots<-c(r11, r12, r21, r22)#
			groot<-K0+T0*cos(2*pi* roots)+T1*sin(2*pi* roots)#
			gmin<-round(groot)#
			r1<-min(roots[which(gmin==0)])#
			r2<-max(roots[which(gmin==0)])#
	    	#Regime#
	    	#Those less than r1#
	    		if (mm2<r1) {KK = K0*(mm2-strmid) +   (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}#
	    		#Those between r1 and r2#
	    		if (mm2>r1&mm2<r2) {KK=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))}#
	    		#Those after r2#
	    		if (mm2>r2)#
	    			{#
	    			zMid=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    			zEnd=K0*(mm2-r2)     + (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*r2))     - (T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*r2))#
	    			KK<-zEnd+zMid#
	    			}#
	  	} else {KK=K0*(mm2-strmid)+(T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}	#
	  if (MMLIST[mm]==min(MM1985))  {M01} else if (MMLIST[mm]==min(MM1986)) {M02} else if (MMLIST[mm]>min(MM1985)&MMLIST[mm]<min(MM1986)) {M01 + (LINF-M01)*(1-exp(-KK))} else {M02 + (LINF-M02)*(1-exp(-KK))}#
	}#
	#INITIALISE THE TAU's which are the inclusion probablities to all be a third#
	TAU <- list()#
	for (mm in 1:(MON))#
		{#
	  		TAU[[mm]] <- matrix(1/3,NN,3)#
		}#
	#INITIALISE THE AUXILLARY STORAGE ARRAYS FOR INSIDE LOOP ASSIGNMENT#
	MU2A_AUX <- c()#
	MUA_AUX <- c()#
	MUJ_AUX <- c()#
	for (mm in 1:MON)#
		{#
	 	MU2A_AUX[mm] <- MU2A(mm,K0,T0,T1,LINF,M01,M02)#
	  	MUA_AUX[mm] <- MUA(mm,K0,T0,T1,LINF,M01,M02)#
	 	MUJ_AUX[mm] <- MUJ(mm,K0,T0,T1,LINF,M01,M02)#
		}#
	#INITIALISE THE VARIANCE FUNCTIONS. THEY ARE ALL QUADRATIC FUNCTIONS OF THE MEAN FOR EACH COHORT#
	VARJ <- function(mm,VV,K0,T0,T1,LINF,M01,M02)#
		{#
			max(exp(VV[1])+VV[2]*MUJ(mm,K0,T0,T1,LINF,M01,M02)+VV[3]*MUJ(mm,K0,T0,T1,LINF,M01,M02)^2,1)#
		}#
	VARA <- function(mm,VV,K0,T0,T1,LINF,M01,M02)#
		{#
			max(exp(VV[1])+VV[2]*MUA(mm,K0,T0,T1,LINF,M01,M02)+VV[3]*MUA(mm,K0,T0,T1,LINF,M01,M02)^2,1)#
		}#
	VAR2A <- function(mm,VV,K0,T0,T1,LINF,M01,M02)#
		{#
			max(exp(VV[1])+VV[2]*MU2A(mm,K0,T0,T1,LINF,M01,M02)+VV[3]*MU2A(mm,K0,T0,T1,LINF,M01,M02)^2,1)#
		}#
	#INITIALISE THE LIKELIHOOD FUNCTION#
	LOGLIKE <- 0#
	for (mm in 1:MON)#
	  {#
		LL2<-LL[which(MM==MMLIST[mm])]#
		LikGrp1<-PI1[mm]*dnorm(LL2,MU2A_AUX[mm],sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp2<-PI2[mm]*dnorm(LL2,MUA_AUX[mm],sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  }#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	#THIS LOOP DOES ALL THE WORK AND INCLUDES TWO NELDER MEAD STEPS TO OPTIMISE THE NONLINEAR MEANS AND VARIANCES#
	TOL <- 10^-6#
	LOGOLD <- -Inf#
	while (LOGLIKE - LOGOLD > TOL)#
	{#
	  LOGOLD <- LOGLIKE                     #Assign the current likelihood value to the an old value so we can evaluate the update#
		#UPDATE THE TAU SCORES AND THEN CALCULATE THE PIs GIVEN THESE TAU SCORES#
		for (mm in 1:MON)#
	  	{#
	    	Top1<-PI1[mm]*dnorm(LL,MU2A_AUX[mm],sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02)))							#Calculate the inclusion probablities for group 1#
	    	Top2<-PI2[mm]*dnorm(LL,MUA_AUX[mm],sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02)))								#Calculate the inclusion probablities for group 2#
	    	Bot<- Top1 + Top2 +(1-(PI1[mm]+PI2[mm]))*dnorm(LL,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02)))  #Calculate the sum of each of the classes#
	    	TAU[[mm]][,1] <- Top1/Bot																				#Calculate the first group's tau scores#
	    	TAU[[mm]][,2] <- Top2/Bot																				#Calculate the second group's tau scores#
	   		TAU[[mm]][,3] <- 1-(TAU[[mm]][,1]+TAU[[mm]][,2])													  	#Calculate the third group's tau scores#
	    	PI1[mm] <- sum((MM==MMLIST[mm])*TAU[[mm]][,1])/sum(MM==MMLIST[mm])										#Work out the PIs for group 1#
	    	PI2[mm] <- sum((MM==MMLIST[mm])*TAU[[mm]][,2])/sum(MM==MMLIST[mm])										#Work out the PIs for group 2#
	  	}#
	  #DEFINE THE LIKELIHOOD FUNCTION OUTSIDE THE LOOP TO UPDATE THE MEANS#
	  PARA <- c(K0,T0,T1,LINF,M01,M02)#
	  OPTIFUN <- function(PARA)#
	  {#
	  	LOGLIKE <- 0#
	  		for (mm in 1:MON)#
	  			{#
				LL2<-LL[which(MM==MMLIST[mm])]#
				LikGrp1<-PI1[mm]*dnorm(LL2,MU2A(mm,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]),sqrt(VAR2A(mm,VV,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6])))#
				LikGrp2<-PI2[mm]*dnorm(LL2,MUA(mm,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]),sqrt(VARA(mm,VV,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]))) #
				LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ(mm,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]),sqrt(VARJ(mm,VV,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6])))#
				LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  			}#
		-LOGLIKE#
	  }#
	  OPTIM <- optim(PARA,OPTIFUN, control = list(maxit = 10000))														#RUN OPTIM to find the best parameters given the taus and Pis#
	  print("Did optim 1 converge?")#
	  print(OPTIM$convergence)#
	  #Assign the estimates from optim to the parameters#
	  K0 <- OPTIM$par[1]#
	  T0 <- OPTIM$par[2]#
	  T1 <- OPTIM$par[3]#
	  LINF <- OPTIM$par[4]#
	  M01 <- OPTIM$par[5]#
	  M02<-OPTIM$par[6]#
	  #Calculate the means for each group based on these new estimates#
	  MU2A_AUX <- c()#
	  MUA_AUX <- c()#
	  MUJ_AUX <- c()#
	  for (mm in 1:MON)#
	  {#
	  	#Compute the means for each month #
	    MU2A_AUX[mm] <- MU2A(mm,K0,T0,T1,LINF,M01,M02)#
	    MUA_AUX[mm] <- MUA(mm,K0,T0,T1,LINF,M01,M02)#
	    MUJ_AUX[mm] <- MUJ(mm,K0,T0,T1,LINF,M01,M02)#
	  }#
	  #OPTIMISE THE VARIANCES GIVEN THE NEW MEANS#
	  #DEFINE THE LIKELIHOOD FUNCTION OUTSIDE THE LOOP TO UPDATE THE VARIANCES #
	  PARA2 <- VV#
	  VAROPTIFUN <- function(PARA2)#
	  {#
	  LOGLIKE <- 0#
	  		for (mm in 1:MON)#
	  			{#
	  			#mm=1#
				LL2<-LL[which(MM==MMLIST[mm])]#
				LikGrp1<- PI1[mm]*dnorm(LL2,MU2A_AUX[mm],sqrt(VAR2A(mm,PARA2,K0,T0,T1,LINF,M01,M02)))#
				LikGrp2<- PI2[mm]*dnorm(LL2,MUA_AUX[mm],sqrt(VARA(mm,PARA2,K0,T0,T1,LINF,M01,M02)))#
				LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ_AUX[mm],sqrt(VARJ(mm,PARA2,K0,T0,T1,LINF,M01,M02)))#
				LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  			}#
		-LOGLIKE#
	  }#
	  OPTIM2 <- optim(PARA2,VAROPTIFUN,control = list(maxit = 10000))													#RUN OPTIM to find the best variances given the taus and Pis#
	  VV <- OPTIM2$par#
	  print("Did optim 2 converge?")#
	  print(OPTIM2$convergence)  #
	  #COMPUTE THE LIKELIHOOD GIVEN ALL THESE NICE NEW UPDATES#
	  LOGLIKE <- 0#
	  for (mm in 1:MON)#
	  {#
		LL2<-LL[which(MM==MMLIST[mm])]#
		LikGrp1<-PI1[mm]*dnorm(LL2,MU2A_AUX[mm],sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp2<-PI2[mm]*dnorm(LL2,MUA_AUX[mm],sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  }#
	  #PRINT OUT OUR NEW UPDATES FOR THE PARAMETERS AND THE LIKELIHOOD#
	  print(c(LOGLIKE,LOGLIKE-LOGOLD))#
	  print(c(PARA,PARA2))#
	  #DRAW SOME NICE REAL TIME PLOTS SO WE CAN MONITOR CONVERGENCE#
	  par(mfrow = c(3,5))#
	  XX <- 0:200#
	  xlabNam<-c("Feb., 1985","Mar., 1985","Apr., 1985","May, 1985","Jun., 1985","Jul, 1985","Aug., 1985","Feb., 1986","Mar., 1986","Apr., 1986","May, 1986")#
	  for (mm in 1:MON)#
	  {#
	    hist(LL[which(MM==MMLIST[mm])],breaks=30,prob=T,xlim=c(20,210),ylim=c(0,0.055),xlab=xlabNam[mm],ylab="",main='')#
	    lines(XX,PI1[mm]*dnorm(XX,MU2A(mm,K0,T0,T1,LINF,M01,M02),sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02))),col='red',lwd=2.5)#
	    lines(XX,PI2[mm]*dnorm(XX,MUA(mm,K0,T0,T1,LINF,M01,M02),sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02))),col='green',lwd=2.5)#
	    lines(XX,(1-(PI1[mm]+PI2[mm]))*dnorm(XX,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02))),col='blue',lwd=2.5)#
	  }#
	  XX2 <- seq(0,1,length.out=100)#
	  YY <- K0 + T0*cos(2*pi*XX2) + T1*sin(2*pi*XX2)#
	  plot(XX2,((YY+abs(YY))/2),type='l',xlab="Fraction of a year since Jan 1",ylab="k (per year)",lwd=2.5)#
	  BLAH <- 50:160#
	  #plot(BLAH,exp(VV[1])+VV[2]*BLAH+VV[3]*BLAH^2,type='l',xlab="Mean length (mm)", ylab="Variance",lwd=2.5,ylim=c(0,300))#
	  #plot(density(rnorm(1000000,PARA[4],sqrt(PARA2[2]*PARA[4]+ PARA2[3]*PARA[4]^2))),xlab="Length (mm)",main="",lwd=2.5)#
	}
PARA2[2]*PARA[4]+ PARA2[3]*PARA[4]^2
VV[1]
exp(VV[1])+VV[2]*BLAH+VV[3]*BLAH^2
BLAH <- 50:170
exp(VV[1])+VV[2]*BLAH+VV[3]*BLAH^2
VV[2]
VV[3]
rm(list = ls())#
	#DATA PRELIMINARIES#
	#Read in the data set on the asymptotic males that was gathered through pots#
	LFD_bigMalesFemales<-read.table("LFD_bigMalesFem",header=T)#
	#Pull out the lengths and the dates from these data files#
	Dates1<-as.Date(LFD_bigMalesFemales$Date,"%d/%m/%y")               #
	Lengths1<-LFD_bigMalesFemales$Carapacewidth#
	#Read in the trawl data on males that contains juvenile recruitment and adults#
	LFD<-read.table("LFD")#
	#which(LFD$Sex==1)#
	#Pull out the lengths and the dates from these data files#
	Dates2<-as.Date(LFD$Date,"%d/%m/%Y")#
	Lengths2<-LFD$Carapace.width#
	#Concatenate the necessary elements from each file into a common dates and lengths array#
	Dates <- c(Dates2,Dates1)#
	Lengths <- c(Lengths2,Lengths1)#
	#Pull out the year and month information from these dates#
	YEAR <- format(Dates,'%Y')#
	MONTHS <- format(Dates,'%m')#
	#Pull out the years and months that we a re interested in i.e., those that don't contain 	recruitment#
	WHICH85JO <- which((YEAR == '1985') & (as.numeric(MONTHS) %in% (1:12)))#
	WHICH86FM <- which((YEAR == '1986') & (as.numeric(MONTHS) %in% (2:5)))#
	#INITIALISE#
	MON <- 16													#Assign how many months we would like to model#
	LL <- Lengths[c(WHICH85JO,WHICH86FM)]						#Assign the number of individuals#
	MM1985 <- as.numeric(MONTHS[WHICH85JO])-1					#Assign January to be the 0th months#
	MM1986 <- as.numeric(MONTHS[WHICH86FM])+11					#Thus January of next year will be the 12 month. Plus we do this so that we don't have to estimate yr#
	MM<-c(MM1985,MM1986)										#Concatenate these months values together#
	MMLIST <- as.numeric(names(table(MM)))						#Make a list of the months from January first i.e., January 1986 is gets assigned a 12#
	#Parameter Initialise#
	NN <- length(MM)											#Initialise the number of individuals we have#
	PI1 <- rep(1/3,MON)											#Initialise the PIs#
	PI2 <- rep(1/3,MON)											#Initialise the PIs#
	K0 <- 1														#Initialise K0 average K#
	LINF <- 200													#Initialise asym length#
	M01<-40														#Initialise first month's average length#
	M02<-40														#Initialise second month's average length#
	T0 <- 0.1														#Initialise first seasonality parameter#
	T1 <- 0.1														#Initialise second seasonality parameter#
	VV <- c(-10,10,0.1)										   #Initialise the starting values for the variance quadratic update
#ASYMPTOTIC MEAN FUNCTION#
	MU2A <- function(mm,K0,T0,T1,LINF,M01,M02)#
	{#
	  #mm=1#
	  mmval <- MMLIST[mm]%%12#
	  yrsold<-2#
	  strmnth<-min(MM1985)#
	  strmid<-strmnth/12+1/24+yrsold#
	  endmid<-strmid+1#
	  mm2=(mmval/12)+1/24+yrsold#
	  t<-seq(0,1,0.01)#
	  g<-K0+T0*cos(2*pi*t)+T1*sin(2*pi*t)#
	  #plot(t,g)#
	  Isneg<-min(g)#
	  Isneg2<-max(g)#
	  if (Isneg<0&Isneg2>0)#
	  {#
	    a=T0^2+T1^2#
		b=2*K0*T0#
		c=-(T1^2)+K0^2#
		u1=(-b+sqrt(b^2-4*a*c))/(2*a)#
		u2=(-b-sqrt(b^2-4*a*c))/(2*a)#
		r11=1-acos(u1)/(2*pi)+yrsold#
		r12=acos(u1)/(2*pi)+yrsold#
		r21=1-acos(u2)/(2*pi)+yrsold#
		r22=acos(u2)/(2*pi)+yrsold#
		roots<-c(r11, r12, r21, r22)#
		groot<-K0+T0*cos(2*pi* roots)+T1*sin(2*pi* roots)#
		gmin<-round(groot)#
		r1<-min(roots[which(gmin==0)])#
		r2<-max(roots[which(gmin==0)])#
	    #Regime#
		zMid1=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    zEnd1=K0*(endmid-r2) + (T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*r2)) - (T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*r2))#
	    KKyr<-yrsold*(zEnd1+zMid1)#
	    #Those less than r1#
	    if (mm2<r1) {KK = KKyr + K0*(mm2-strmid) +   (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}#
	    #Those between r1 and r2#
	    if (mm2>r1&mm2<r2) {KK= KKyr + K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))}#
	    #Those after r2#
	    if (mm2>r2)#
	    {#
	    zMid=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    zEnd=K0*(mm2-r2)     + (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*r2))     - (T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*r2))#
	    KK<-zEnd+zMid+KKyr#
	    }#
	  } else {KK=K0*(mm2-strmid)+(T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid)) + yrsold*(K0*(endmid-strmid)+(T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*strmid)) )}#
	  if (MMLIST[mm]>max(MM1985)) {M02 + (LINF-M02)*(1-exp(-KK))} else (M01 + (LINF-M01)*(1-exp(-KK)))#
	}#
	#1 YEAR OLD ADULT's MEAN FUNCTION#
	MUA <- function(mm,K0,T0,T1,LINF,M01,M02)#
	{#
	  mmval <- MMLIST[mm]%%12#
	  yrsold<-1#
	  strmnth<-min(MM1985)#
	  strmid<-strmnth/12+1/24+yrsold#
	  endmid<-strmid+1#
	  mm2=(mmval/12)+1/24+yrsold#
	  t<-seq(0,1,0.01)#
	  g<-K0+T0*cos(2*pi*t)+T1*sin(2*pi*t)#
	  Isneg<-min(g)#
	  Isneg2<-max(g)#
	  if (Isneg<0&Isneg2>0)#
	  {#
	    a=T0^2+T1^2#
		b=2*K0*T0#
		c=-(T1^2)+K0^2#
		u1=(-b+sqrt(b^2-4*a*c))/(2*a)#
		u2=(-b-sqrt(b^2-4*a*c))/(2*a)#
		r11=1-acos(u1)/(2*pi)+yrsold#
		r12=acos(u1)/(2*pi)+yrsold#
		r21=1-acos(u2)/(2*pi)+yrsold#
		r22=acos(u2)/(2*pi)+yrsold#
		roots<-c(r11, r12, r21, r22)#
		groot<-K0+T0*cos(2*pi* roots)+T1*sin(2*pi* roots)#
		gmin<-round(groot)#
		r1<-min(roots[which(gmin==0)])#
		r2<-max(roots[which(gmin==0)])#
	    #Regime#
		zMid1=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    zEnd1=K0*(endmid-r2) + (T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*r2)) - (T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*r2))#
	    KKyr<-yrsold*(zEnd1+zMid1)#
	    	#Those less than r1#
	    	if (mm2<r1) {KK = KKyr + K0*(mm2-strmid) +   (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}#
	    	#Those between r1 and r2#
	    	if (mm2>r1&mm2<r2) {KK= KKyr + K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))}#
	    	#Those after r2#
	    	if (mm2>r2)#
	    		{#
	    		zMid=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    		zEnd=K0*(mm2-r2)     + (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*r2))     - (T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*r2))#
	    		KK<-zEnd+zMid+KKyr#
	    		}#
	  } else {KK=K0*(mm2-strmid)+(T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid)) + yrsold*(K0*(endmid-strmid)+(T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*strmid)) )}#
	  if (MMLIST[mm]>max(MM1985)) {M02 + (LINF-M02)*(1-exp(-KK))} else (M01 + (LINF-M01)*(1-exp(-KK)))#
	}#
	#THE JUVENUILES MEAN FUNCTION#
	MUJ <- function(mm,K0,T0,T1,LINF,M01,M02)#
	{#
		#mm=2#
		mmval <- MMLIST[mm]%%12#
	  	yrsold<-0#
	  	strmnth<-min(MM1985)#
	  	strmid<-strmnth/12+1/24+yrsold#
	  	endmid<-strmid+1#
	  	mm2=(mmval/12)+1/24+yrsold#
	  	t<-seq(0,1,0.01)#
		g<-K0+T0*cos(2*pi*t)+T1*sin(2*pi*t)#
		Isneg<-min(g)#
		Isneg2<-max(g)#
	 	if (Isneg<0&Isneg2>0)#
	  		{#
	    	a=T0^2+T1^2#
			b=2*K0*T0#
			c=-(T1^2)+K0^2#
			u1=(-b+sqrt(b^2-4*a*c))/(2*a)#
			u2=(-b-sqrt(b^2-4*a*c))/(2*a)#
			r11=1-acos(u1)/(2*pi)#
			r12=acos(u1)/(2*pi)#
			r21=1-acos(u2)/(2*pi)#
			r22=acos(u2)/(2*pi)#
			roots<-c(r11, r12, r21, r22)#
			groot<-K0+T0*cos(2*pi* roots)+T1*sin(2*pi* roots)#
			gmin<-round(groot)#
			r1<-min(roots[which(gmin==0)])#
			r2<-max(roots[which(gmin==0)])#
	    	#Regime#
	    	#Those less than r1#
	    		if (mm2<r1) {KK = K0*(mm2-strmid) +   (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}#
	    		#Those between r1 and r2#
	    		if (mm2>r1&mm2<r2) {KK=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))}#
	    		#Those after r2#
	    		if (mm2>r2)#
	    			{#
	    			zMid=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    			zEnd=K0*(mm2-r2)     + (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*r2))     - (T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*r2))#
	    			KK<-zEnd+zMid#
	    			}#
	  	} else {KK=K0*(mm2-strmid)+(T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}	#
	  if (MMLIST[mm]==min(MM1985))  {M01} else if (MMLIST[mm]==min(MM1986)) {M02} else if (MMLIST[mm]>min(MM1985)&MMLIST[mm]<min(MM1986)) {M01 + (LINF-M01)*(1-exp(-KK))} else {M02 + (LINF-M02)*(1-exp(-KK))}#
	}#
	#INITIALISE THE TAU's which are the inclusion probablities to all be a third#
	TAU <- list()#
	for (mm in 1:(MON))#
		{#
	  		TAU[[mm]] <- matrix(1/3,NN,3)#
		}#
	#INITIALISE THE AUXILLARY STORAGE ARRAYS FOR INSIDE LOOP ASSIGNMENT#
	MU2A_AUX <- c()#
	MUA_AUX <- c()#
	MUJ_AUX <- c()#
	for (mm in 1:MON)#
		{#
	 	MU2A_AUX[mm] <- MU2A(mm,K0,T0,T1,LINF,M01,M02)#
	  	MUA_AUX[mm] <- MUA(mm,K0,T0,T1,LINF,M01,M02)#
	 	MUJ_AUX[mm] <- MUJ(mm,K0,T0,T1,LINF,M01,M02)#
		}#
	#INITIALISE THE VARIANCE FUNCTIONS. THEY ARE ALL QUADRATIC FUNCTIONS OF THE MEAN FOR EACH COHORT#
	VARJ <- function(mm,VV,K0,T0,T1,LINF,M01,M02)#
		{#
			max(exp(VV[1])+VV[2]*MUJ(mm,K0,T0,T1,LINF,M01,M02)+VV[3]*MUJ(mm,K0,T0,T1,LINF,M01,M02)^2,1)#
		}#
	VARA <- function(mm,VV,K0,T0,T1,LINF,M01,M02)#
		{#
			max(exp(VV[1])+VV[2]*MUA(mm,K0,T0,T1,LINF,M01,M02)+VV[3]*MUA(mm,K0,T0,T1,LINF,M01,M02)^2,1)#
		}#
	VAR2A <- function(mm,VV,K0,T0,T1,LINF,M01,M02)#
		{#
			max(exp(VV[1])+VV[2]*MU2A(mm,K0,T0,T1,LINF,M01,M02)+VV[3]*MU2A(mm,K0,T0,T1,LINF,M01,M02)^2,1)#
		}#
	#INITIALISE THE LIKELIHOOD FUNCTION#
	LOGLIKE <- 0#
	for (mm in 1:MON)#
	  {#
		LL2<-LL[which(MM==MMLIST[mm])]#
		LikGrp1<-PI1[mm]*dnorm(LL2,MU2A_AUX[mm],sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp2<-PI2[mm]*dnorm(LL2,MUA_AUX[mm],sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  }#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	#THIS LOOP DOES ALL THE WORK AND INCLUDES TWO NELDER MEAD STEPS TO OPTIMISE THE NONLINEAR MEANS AND VARIANCES#
	TOL <- 10^-6#
	LOGOLD <- -Inf#
	while (LOGLIKE - LOGOLD > TOL)#
	{#
	  LOGOLD <- LOGLIKE                     #Assign the current likelihood value to the an old value so we can evaluate the update#
		#UPDATE THE TAU SCORES AND THEN CALCULATE THE PIs GIVEN THESE TAU SCORES#
		for (mm in 1:MON)#
	  	{#
	    	Top1<-PI1[mm]*dnorm(LL,MU2A_AUX[mm],sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02)))							#Calculate the inclusion probablities for group 1#
	    	Top2<-PI2[mm]*dnorm(LL,MUA_AUX[mm],sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02)))								#Calculate the inclusion probablities for group 2#
	    	Bot<- Top1 + Top2 +(1-(PI1[mm]+PI2[mm]))*dnorm(LL,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02)))  #Calculate the sum of each of the classes#
	    	TAU[[mm]][,1] <- Top1/Bot																				#Calculate the first group's tau scores#
	    	TAU[[mm]][,2] <- Top2/Bot																				#Calculate the second group's tau scores#
	   		TAU[[mm]][,3] <- 1-(TAU[[mm]][,1]+TAU[[mm]][,2])													  	#Calculate the third group's tau scores#
	    	PI1[mm] <- sum((MM==MMLIST[mm])*TAU[[mm]][,1])/sum(MM==MMLIST[mm])										#Work out the PIs for group 1#
	    	PI2[mm] <- sum((MM==MMLIST[mm])*TAU[[mm]][,2])/sum(MM==MMLIST[mm])										#Work out the PIs for group 2#
	  	}#
	  #DEFINE THE LIKELIHOOD FUNCTION OUTSIDE THE LOOP TO UPDATE THE MEANS#
	  PARA <- c(K0,T0,T1,LINF,M01,M02)#
	  OPTIFUN <- function(PARA)#
	  {#
	  	LOGLIKE <- 0#
	  		for (mm in 1:MON)#
	  			{#
				LL2<-LL[which(MM==MMLIST[mm])]#
				LikGrp1<-PI1[mm]*dnorm(LL2,MU2A(mm,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]),sqrt(VAR2A(mm,VV,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6])))#
				LikGrp2<-PI2[mm]*dnorm(LL2,MUA(mm,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]),sqrt(VARA(mm,VV,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]))) #
				LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ(mm,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]),sqrt(VARJ(mm,VV,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6])))#
				LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  			}#
		-LOGLIKE#
	  }#
	  OPTIM <- optim(PARA,OPTIFUN, control = list(maxit = 10000))														#RUN OPTIM to find the best parameters given the taus and Pis#
	  print("Did optim 1 converge?")#
	  print(OPTIM$convergence)#
	  #Assign the estimates from optim to the parameters#
	  K0 <- OPTIM$par[1]#
	  T0 <- OPTIM$par[2]#
	  T1 <- OPTIM$par[3]#
	  LINF <- OPTIM$par[4]#
	  M01 <- OPTIM$par[5]#
	  M02<-OPTIM$par[6]#
	  #Calculate the means for each group based on these new estimates#
	  MU2A_AUX <- c()#
	  MUA_AUX <- c()#
	  MUJ_AUX <- c()#
	  for (mm in 1:MON)#
	  {#
	  	#Compute the means for each month #
	    MU2A_AUX[mm] <- MU2A(mm,K0,T0,T1,LINF,M01,M02)#
	    MUA_AUX[mm] <- MUA(mm,K0,T0,T1,LINF,M01,M02)#
	    MUJ_AUX[mm] <- MUJ(mm,K0,T0,T1,LINF,M01,M02)#
	  }#
	  #OPTIMISE THE VARIANCES GIVEN THE NEW MEANS#
	  #DEFINE THE LIKELIHOOD FUNCTION OUTSIDE THE LOOP TO UPDATE THE VARIANCES #
	  PARA2 <- VV#
	  VAROPTIFUN <- function(PARA2)#
	  {#
	  LOGLIKE <- 0#
	  		for (mm in 1:MON)#
	  			{#
	  			#mm=1#
				LL2<-LL[which(MM==MMLIST[mm])]#
				LikGrp1<- PI1[mm]*dnorm(LL2,MU2A_AUX[mm],sqrt(VAR2A(mm,PARA2,K0,T0,T1,LINF,M01,M02)))#
				LikGrp2<- PI2[mm]*dnorm(LL2,MUA_AUX[mm],sqrt(VARA(mm,PARA2,K0,T0,T1,LINF,M01,M02)))#
				LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ_AUX[mm],sqrt(VARJ(mm,PARA2,K0,T0,T1,LINF,M01,M02)))#
				LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  			}#
		-LOGLIKE#
	  }#
	  OPTIM2 <- optim(PARA2,VAROPTIFUN,control = list(maxit = 10000))													#RUN OPTIM to find the best variances given the taus and Pis#
	  VV <- OPTIM2$par#
	  print("Did optim 2 converge?")#
	  print(OPTIM2$convergence)  #
	  #COMPUTE THE LIKELIHOOD GIVEN ALL THESE NICE NEW UPDATES#
	  LOGLIKE <- 0#
	  for (mm in 1:MON)#
	  {#
		LL2<-LL[which(MM==MMLIST[mm])]#
		LikGrp1<-PI1[mm]*dnorm(LL2,MU2A_AUX[mm],sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp2<-PI2[mm]*dnorm(LL2,MUA_AUX[mm],sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  }#
	  #PRINT OUT OUR NEW UPDATES FOR THE PARAMETERS AND THE LIKELIHOOD#
	  print(c(LOGLIKE,LOGLIKE-LOGOLD))#
	  print(c(PARA,PARA2))#
	  #DRAW SOME NICE REAL TIME PLOTS SO WE CAN MONITOR CONVERGENCE#
	  par(mfrow = c(3,5))#
	  XX <- 0:200#
	  xlabNam<-c("Feb., 1985","Mar., 1985","Apr., 1985","May, 1985","Jun., 1985","Jul, 1985","Aug., 1985","Feb., 1986","Mar., 1986","Apr., 1986","May, 1986")#
	  for (mm in 1:MON)#
	  {#
	    hist(LL[which(MM==MMLIST[mm])],breaks=30,prob=T,xlim=c(20,210),ylim=c(0,0.055),xlab=xlabNam[mm],ylab="",main='')#
	    lines(XX,PI1[mm]*dnorm(XX,MU2A(mm,K0,T0,T1,LINF,M01,M02),sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02))),col='red',lwd=2.5)#
	    lines(XX,PI2[mm]*dnorm(XX,MUA(mm,K0,T0,T1,LINF,M01,M02),sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02))),col='green',lwd=2.5)#
	    lines(XX,(1-(PI1[mm]+PI2[mm]))*dnorm(XX,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02))),col='blue',lwd=2.5)#
	  }#
	  XX2 <- seq(0,1,length.out=100)#
	  YY <- K0 + T0*cos(2*pi*XX2) + T1*sin(2*pi*XX2)#
	  plot(XX2,((YY+abs(YY))/2),type='l',xlab="Fraction of a year since Jan 1",ylab="k (per year)",lwd=2.5)#
	  BLAH <- 50:170#
	  #plot(BLAH,exp(VV[1])+VV[2]*BLAH+VV[3]*BLAH^2,type='l',xlab="Mean length (mm)", ylab="Variance",lwd=2.5,ylim=c(0,300))#
	  #plot(density(rnorm(1000000,PARA[4],sqrt(PARA2[2]*PARA[4]+ PARA2[3]*PARA[4]^2))),xlab="Length (mm)",main="",lwd=2.5)#
	}
###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	#Set the necessary working directories#
	#setwd("/Users/uqllloyd/Dropbox/AAUni/APhD/Blueswimmer/CrabStuff2withMMAlg/RcodesData")#
	setwd("~/Dropbox/AAUni/APhD/Blueswimmer/RcodeData_03:10:2014/")#
	#Remove any old objects#
	rm(list = ls())#
	#DATA PRELIMINARIES#
	#Read in the data set on the asymptotic males that was gathered through pots#
	LFD_bigMalesFemales<-read.table("LFD_bigMalesFem",header=T)#
	#Pull out the lengths and the dates from these data files#
	Dates1<-as.Date(LFD_bigMalesFemales$Date,"%d/%m/%y")               #
	Lengths1<-LFD_bigMalesFemales$Carapacewidth#
	#Read in the trawl data on males that contains juvenile recruitment and adults#
	LFD<-read.table("LFD")#
	#which(LFD$Sex==1)#
	#Pull out the lengths and the dates from these data files#
	Dates2<-as.Date(LFD$Date,"%d/%m/%Y")#
	Lengths2<-LFD$Carapace.width#
	#Concatenate the necessary elements from each file into a common dates and lengths array#
	Dates <- c(Dates2,Dates1)#
	Lengths <- c(Lengths2,Lengths1)#
	#Pull out the year and month information from these dates#
	YEAR <- format(Dates,'%Y')#
	MONTHS <- format(Dates,'%m')#
	#Pull out the years and months that we a re interested in i.e., those that don't contain 	recruitment#
	WHICH85JO <- which((YEAR == '1985') & (as.numeric(MONTHS) %in% (1:12)))#
	WHICH86FM <- which((YEAR == '1986') & (as.numeric(MONTHS) %in% (2:5)))#
	#INITIALISE#
	MON <- 16													#Assign how many months we would like to model#
	LL <- Lengths[c(WHICH85JO,WHICH86FM)]						#Assign the number of individuals#
	MM1985 <- as.numeric(MONTHS[WHICH85JO])-1					#Assign January to be the 0th months#
	MM1986 <- as.numeric(MONTHS[WHICH86FM])+11					#Thus January of next year will be the 12 month. Plus we do this so that we don't have to estimate yr#
	MM<-c(MM1985,MM1986)										#Concatenate these months values together#
	MMLIST <- as.numeric(names(table(MM)))						#Make a list of the months from January first i.e., January 1986 is gets assigned a 12#
	#Parameter Initialise#
	NN <- length(MM)											#Initialise the number of individuals we have#
	PI1 <- rep(1/3,MON)											#Initialise the PIs#
	PI2 <- rep(1/3,MON)											#Initialise the PIs#
	K0 <- 1														#Initialise K0 average K#
	LINF <- 200													#Initialise asym length#
	M01<-40														#Initialise first month's average length#
	M02<-40														#Initialise second month's average length#
	T0 <- 0.1														#Initialise first seasonality parameter#
	T1 <- 0.1														#Initialise second seasonality parameter#
	VV <- c(-10,10,0.1)										   #Initialise the starting values for the variance quadratic update#
	#Setting values for drawing plots #
	#K0=0.84062808;  LINF=159.65387413; M01=58.86155838; M02=81.29860313; T0=-0.07925965; T1=0.57794716; VV=c( -4.77584147,   6.19436755  ,-0.03489903)#
	#0.84062808  -0.07925965   0.57794716 159.65387413  58.86155838  81.29860313  -4.77584147   6.19436755  -0.03489903#
	#FUNCTIONS#
	#ASYMPTOTIC MEAN FUNCTION#
	MU2A <- function(mm,K0,T0,T1,LINF,M01,M02)#
	{#
	  #mm=1#
	  mmval <- MMLIST[mm]%%12#
	  yrsold<-2#
	  strmnth<-min(MM1985)#
	  strmid<-strmnth/12+1/24+yrsold#
	  endmid<-strmid+1#
	  mm2=(mmval/12)+1/24+yrsold#
	  t<-seq(0,1,0.01)#
	  g<-K0+T0*cos(2*pi*t)+T1*sin(2*pi*t)#
	  #plot(t,g)#
	  Isneg<-min(g)#
	  Isneg2<-max(g)#
	  if (Isneg<0&Isneg2>0)#
	  {#
	    a=T0^2+T1^2#
		b=2*K0*T0#
		c=-(T1^2)+K0^2#
		u1=(-b+sqrt(b^2-4*a*c))/(2*a)#
		u2=(-b-sqrt(b^2-4*a*c))/(2*a)#
		r11=1-acos(u1)/(2*pi)+yrsold#
		r12=acos(u1)/(2*pi)+yrsold#
		r21=1-acos(u2)/(2*pi)+yrsold#
		r22=acos(u2)/(2*pi)+yrsold#
		roots<-c(r11, r12, r21, r22)#
		groot<-K0+T0*cos(2*pi* roots)+T1*sin(2*pi* roots)#
		gmin<-round(groot)#
		r1<-min(roots[which(gmin==0)])#
		r2<-max(roots[which(gmin==0)])#
	    #Regime#
		zMid1=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    zEnd1=K0*(endmid-r2) + (T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*r2)) - (T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*r2))#
	    KKyr<-yrsold*(zEnd1+zMid1)#
	    #Those less than r1#
	    if (mm2<r1) {KK = KKyr + K0*(mm2-strmid) +   (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}#
	    #Those between r1 and r2#
	    if (mm2>r1&mm2<r2) {KK= KKyr + K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))}#
	    #Those after r2#
	    if (mm2>r2)#
	    {#
	    zMid=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    zEnd=K0*(mm2-r2)     + (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*r2))     - (T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*r2))#
	    KK<-zEnd+zMid+KKyr#
	    }#
	  } else {KK=K0*(mm2-strmid)+(T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid)) + yrsold*(K0*(endmid-strmid)+(T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*strmid)) )}#
	  if (MMLIST[mm]>max(MM1985)) {M02 + (LINF-M02)*(1-exp(-KK))} else (M01 + (LINF-M01)*(1-exp(-KK)))#
	}#
	#1 YEAR OLD ADULT's MEAN FUNCTION#
	MUA <- function(mm,K0,T0,T1,LINF,M01,M02)#
	{#
	  mmval <- MMLIST[mm]%%12#
	  yrsold<-1#
	  strmnth<-min(MM1985)#
	  strmid<-strmnth/12+1/24+yrsold#
	  endmid<-strmid+1#
	  mm2=(mmval/12)+1/24+yrsold#
	  t<-seq(0,1,0.01)#
	  g<-K0+T0*cos(2*pi*t)+T1*sin(2*pi*t)#
	  Isneg<-min(g)#
	  Isneg2<-max(g)#
	  if (Isneg<0&Isneg2>0)#
	  {#
	    a=T0^2+T1^2#
		b=2*K0*T0#
		c=-(T1^2)+K0^2#
		u1=(-b+sqrt(b^2-4*a*c))/(2*a)#
		u2=(-b-sqrt(b^2-4*a*c))/(2*a)#
		r11=1-acos(u1)/(2*pi)+yrsold#
		r12=acos(u1)/(2*pi)+yrsold#
		r21=1-acos(u2)/(2*pi)+yrsold#
		r22=acos(u2)/(2*pi)+yrsold#
		roots<-c(r11, r12, r21, r22)#
		groot<-K0+T0*cos(2*pi* roots)+T1*sin(2*pi* roots)#
		gmin<-round(groot)#
		r1<-min(roots[which(gmin==0)])#
		r2<-max(roots[which(gmin==0)])#
	    #Regime#
		zMid1=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    zEnd1=K0*(endmid-r2) + (T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*r2)) - (T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*r2))#
	    KKyr<-yrsold*(zEnd1+zMid1)#
	    	#Those less than r1#
	    	if (mm2<r1) {KK = KKyr + K0*(mm2-strmid) +   (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}#
	    	#Those between r1 and r2#
	    	if (mm2>r1&mm2<r2) {KK= KKyr + K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))}#
	    	#Those after r2#
	    	if (mm2>r2)#
	    		{#
	    		zMid=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    		zEnd=K0*(mm2-r2)     + (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*r2))     - (T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*r2))#
	    		KK<-zEnd+zMid+KKyr#
	    		}#
	  } else {KK=K0*(mm2-strmid)+(T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid)) + yrsold*(K0*(endmid-strmid)+(T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*strmid)) )}#
	  if (MMLIST[mm]>max(MM1985)) {M02 + (LINF-M02)*(1-exp(-KK))} else (M01 + (LINF-M01)*(1-exp(-KK)))#
	}#
	#THE JUVENUILES MEAN FUNCTION#
	MUJ <- function(mm,K0,T0,T1,LINF,M01,M02)#
	{#
		#mm=2#
		mmval <- MMLIST[mm]%%12#
	  	yrsold<-0#
	  	strmnth<-min(MM1985)#
	  	strmid<-strmnth/12+1/24+yrsold#
	  	endmid<-strmid+1#
	  	mm2=(mmval/12)+1/24+yrsold#
	  	t<-seq(0,1,0.01)#
		g<-K0+T0*cos(2*pi*t)+T1*sin(2*pi*t)#
		Isneg<-min(g)#
		Isneg2<-max(g)#
	 	if (Isneg<0&Isneg2>0)#
	  		{#
	    	a=T0^2+T1^2#
			b=2*K0*T0#
			c=-(T1^2)+K0^2#
			u1=(-b+sqrt(b^2-4*a*c))/(2*a)#
			u2=(-b-sqrt(b^2-4*a*c))/(2*a)#
			r11=1-acos(u1)/(2*pi)#
			r12=acos(u1)/(2*pi)#
			r21=1-acos(u2)/(2*pi)#
			r22=acos(u2)/(2*pi)#
			roots<-c(r11, r12, r21, r22)#
			groot<-K0+T0*cos(2*pi* roots)+T1*sin(2*pi* roots)#
			gmin<-round(groot)#
			r1<-min(roots[which(gmin==0)])#
			r2<-max(roots[which(gmin==0)])#
	    	#Regime#
	    	#Those less than r1#
	    		if (mm2<r1) {KK = K0*(mm2-strmid) +   (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}#
	    		#Those between r1 and r2#
	    		if (mm2>r1&mm2<r2) {KK=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))}#
	    		#Those after r2#
	    		if (mm2>r2)#
	    			{#
	    			zMid=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    			zEnd=K0*(mm2-r2)     + (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*r2))     - (T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*r2))#
	    			KK<-zEnd+zMid#
	    			}#
	  	} else {KK=K0*(mm2-strmid)+(T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}	#
	  if (MMLIST[mm]==min(MM1985))  {M01} else if (MMLIST[mm]==min(MM1986)) {M02} else if (MMLIST[mm]>min(MM1985)&MMLIST[mm]<min(MM1986)) {M01 + (LINF-M01)*(1-exp(-KK))} else {M02 + (LINF-M02)*(1-exp(-KK))}#
	}#
	#INITIALISE THE TAU's which are the inclusion probablities to all be a third#
	TAU <- list()#
	for (mm in 1:(MON))#
		{#
	  		TAU[[mm]] <- matrix(1/3,NN,3)#
		}#
	#INITIALISE THE AUXILLARY STORAGE ARRAYS FOR INSIDE LOOP ASSIGNMENT#
	MU2A_AUX <- c()#
	MUA_AUX <- c()#
	MUJ_AUX <- c()#
	for (mm in 1:MON)#
		{#
	 	MU2A_AUX[mm] <- MU2A(mm,K0,T0,T1,LINF,M01,M02)#
	  	MUA_AUX[mm] <- MUA(mm,K0,T0,T1,LINF,M01,M02)#
	 	MUJ_AUX[mm] <- MUJ(mm,K0,T0,T1,LINF,M01,M02)#
		}#
	#INITIALISE THE VARIANCE FUNCTIONS. THEY ARE ALL QUADRATIC FUNCTIONS OF THE MEAN FOR EACH COHORT#
	VARJ <- function(mm,VV,K0,T0,T1,LINF,M01,M02)#
		{#
			max(exp(VV[1])+VV[2]*MUJ(mm,K0,T0,T1,LINF,M01,M02)+VV[3]*MUJ(mm,K0,T0,T1,LINF,M01,M02)^2,1)#
		}#
	VARA <- function(mm,VV,K0,T0,T1,LINF,M01,M02)#
		{#
			max(exp(VV[1])+VV[2]*MUA(mm,K0,T0,T1,LINF,M01,M02)+VV[3]*MUA(mm,K0,T0,T1,LINF,M01,M02)^2,1)#
		}#
	VAR2A <- function(mm,VV,K0,T0,T1,LINF,M01,M02)#
		{#
			max(exp(VV[1])+VV[2]*MU2A(mm,K0,T0,T1,LINF,M01,M02)+VV[3]*MU2A(mm,K0,T0,T1,LINF,M01,M02)^2,1)#
		}#
	#INITIALISE THE LIKELIHOOD FUNCTION#
	LOGLIKE <- 0#
	for (mm in 1:MON)#
	  {#
		LL2<-LL[which(MM==MMLIST[mm])]#
		LikGrp1<-PI1[mm]*dnorm(LL2,MU2A_AUX[mm],sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp2<-PI2[mm]*dnorm(LL2,MUA_AUX[mm],sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  }#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	#THIS LOOP DOES ALL THE WORK AND INCLUDES TWO NELDER MEAD STEPS TO OPTIMISE THE NONLINEAR MEANS AND VARIANCES#
	TOL <- 10^-6#
	LOGOLD <- -Inf#
	while (LOGLIKE - LOGOLD > TOL)#
	{#
	  LOGOLD <- LOGLIKE                     #Assign the current likelihood value to the an old value so we can evaluate the update#
		#UPDATE THE TAU SCORES AND THEN CALCULATE THE PIs GIVEN THESE TAU SCORES#
		for (mm in 1:MON)#
	  	{#
	    	Top1<-PI1[mm]*dnorm(LL,MU2A_AUX[mm],sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02)))							#Calculate the inclusion probablities for group 1#
	    	Top2<-PI2[mm]*dnorm(LL,MUA_AUX[mm],sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02)))								#Calculate the inclusion probablities for group 2#
	    	Bot<- Top1 + Top2 +(1-(PI1[mm]+PI2[mm]))*dnorm(LL,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02)))  #Calculate the sum of each of the classes#
	    	TAU[[mm]][,1] <- Top1/Bot																				#Calculate the first group's tau scores#
	    	TAU[[mm]][,2] <- Top2/Bot																				#Calculate the second group's tau scores#
	   		TAU[[mm]][,3] <- 1-(TAU[[mm]][,1]+TAU[[mm]][,2])													  	#Calculate the third group's tau scores#
	    	PI1[mm] <- sum((MM==MMLIST[mm])*TAU[[mm]][,1])/sum(MM==MMLIST[mm])										#Work out the PIs for group 1#
	    	PI2[mm] <- sum((MM==MMLIST[mm])*TAU[[mm]][,2])/sum(MM==MMLIST[mm])										#Work out the PIs for group 2#
	  	}#
	  #DEFINE THE LIKELIHOOD FUNCTION OUTSIDE THE LOOP TO UPDATE THE MEANS#
	  PARA <- c(K0,T0,T1,LINF,M01,M02)#
	  OPTIFUN <- function(PARA)#
	  {#
	  	LOGLIKE <- 0#
	  		for (mm in 1:MON)#
	  			{#
				LL2<-LL[which(MM==MMLIST[mm])]#
				LikGrp1<-PI1[mm]*dnorm(LL2,MU2A(mm,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]),sqrt(VAR2A(mm,VV,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6])))#
				LikGrp2<-PI2[mm]*dnorm(LL2,MUA(mm,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]),sqrt(VARA(mm,VV,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]))) #
				LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ(mm,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]),sqrt(VARJ(mm,VV,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6])))#
				LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  			}#
		-LOGLIKE#
	  }#
	  OPTIM <- optim(PARA,OPTIFUN, control = list(maxit = 10000))														#RUN OPTIM to find the best parameters given the taus and Pis#
	  print("Did optim 1 converge?")#
	  print(OPTIM$convergence)#
	  #Assign the estimates from optim to the parameters#
	  K0 <- OPTIM$par[1]#
	  T0 <- OPTIM$par[2]#
	  T1 <- OPTIM$par[3]#
	  LINF <- OPTIM$par[4]#
	  M01 <- OPTIM$par[5]#
	  M02<-OPTIM$par[6]#
	  #Calculate the means for each group based on these new estimates#
	  MU2A_AUX <- c()#
	  MUA_AUX <- c()#
	  MUJ_AUX <- c()#
	  for (mm in 1:MON)#
	  {#
	  	#Compute the means for each month #
	    MU2A_AUX[mm] <- MU2A(mm,K0,T0,T1,LINF,M01,M02)#
	    MUA_AUX[mm] <- MUA(mm,K0,T0,T1,LINF,M01,M02)#
	    MUJ_AUX[mm] <- MUJ(mm,K0,T0,T1,LINF,M01,M02)#
	  }#
	  #OPTIMISE THE VARIANCES GIVEN THE NEW MEANS#
	  #DEFINE THE LIKELIHOOD FUNCTION OUTSIDE THE LOOP TO UPDATE THE VARIANCES #
	  PARA2 <- VV#
	  VAROPTIFUN <- function(PARA2)#
	  {#
	  LOGLIKE <- 0#
	  		for (mm in 1:MON)#
	  			{#
	  			#mm=1#
				LL2<-LL[which(MM==MMLIST[mm])]#
				LikGrp1<- PI1[mm]*dnorm(LL2,MU2A_AUX[mm],sqrt(VAR2A(mm,PARA2,K0,T0,T1,LINF,M01,M02)))#
				LikGrp2<- PI2[mm]*dnorm(LL2,MUA_AUX[mm],sqrt(VARA(mm,PARA2,K0,T0,T1,LINF,M01,M02)))#
				LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ_AUX[mm],sqrt(VARJ(mm,PARA2,K0,T0,T1,LINF,M01,M02)))#
				LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  			}#
		-LOGLIKE#
	  }#
	  OPTIM2 <- optim(PARA2,VAROPTIFUN,control = list(maxit = 10000))													#RUN OPTIM to find the best variances given the taus and Pis#
	  VV <- OPTIM2$par#
	  print("Did optim 2 converge?")#
	  print(OPTIM2$convergence)  #
	  #COMPUTE THE LIKELIHOOD GIVEN ALL THESE NICE NEW UPDATES#
	  LOGLIKE <- 0#
	  for (mm in 1:MON)#
	  {#
		LL2<-LL[which(MM==MMLIST[mm])]#
		LikGrp1<-PI1[mm]*dnorm(LL2,MU2A_AUX[mm],sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp2<-PI2[mm]*dnorm(LL2,MUA_AUX[mm],sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  }#
	  #PRINT OUT OUR NEW UPDATES FOR THE PARAMETERS AND THE LIKELIHOOD#
	  print(c(LOGLIKE,LOGLIKE-LOGOLD))#
	  print(c(PARA,PARA2))#
	  #DRAW SOME NICE REAL TIME PLOTS SO WE CAN MONITOR CONVERGENCE#
	  par(mfrow = c(4,5))#
	  XX <- 0:200#
	  xlabNam<-c("Feb., 1985","Mar., 1985","Apr., 1985","May, 1985","Jun., 1985","Jul, 1985","Aug., 1985","Feb., 1986","Mar., 1986","Apr., 1986","May, 1986")#
	  for (mm in 1:MON)#
	  {#
	    hist(LL[which(MM==MMLIST[mm])],breaks=30,prob=T,xlim=c(20,210),ylim=c(0,0.055),xlab=xlabNam[mm],ylab="",main='')#
	    lines(XX,PI1[mm]*dnorm(XX,MU2A(mm,K0,T0,T1,LINF,M01,M02),sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02))),col='red',lwd=2.5)#
	    lines(XX,PI2[mm]*dnorm(XX,MUA(mm,K0,T0,T1,LINF,M01,M02),sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02))),col='green',lwd=2.5)#
	    lines(XX,(1-(PI1[mm]+PI2[mm]))*dnorm(XX,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02))),col='blue',lwd=2.5)#
	  }#
	  XX2 <- seq(0,1,length.out=100)#
	  YY <- K0 + T0*cos(2*pi*XX2) + T1*sin(2*pi*XX2)#
	  plot(XX2,((YY+abs(YY))/2),type='l',xlab="Fraction of a year since Jan 1",ylab="k (per year)",lwd=2.5)#
	  BLAH <- 50:170#
	  #plot(BLAH,exp(VV[1])+VV[2]*BLAH+VV[3]*BLAH^2,type='l',xlab="Mean length (mm)", ylab="Variance",lwd=2.5,ylim=c(0,300))#
	  #plot(density(rnorm(1000000,PARA[4],sqrt(PARA2[2]*PARA[4]+ PARA2[3]*PARA[4]^2))),xlab="Length (mm)",main="",lwd=2.5)#
	}
###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	###################CODE TO ESTIMATE GROWTH PARAMETERS FOR FEMALE BLUE SWIMMER CRAB FROM LENGTH FREQUENCY DATA############################
	#Set the necessary working directories#
	#setwd("/Users/uqllloyd/Dropbox/AAUni/APhD/Blueswimmer/CrabStuff2withMMAlg/RcodesData")#
	setwd("~/Dropbox/AAUni/APhD/Blueswimmer/RcodeData_03:10:2014/")#
	#Remove any old objects#
	rm(list = ls())#
	#DATA PRELIMINARIES#
	#Read in the data set on the asymptotic males that was gathered through pots#
	LFD_bigMalesFemales<-read.table("LFD_bigMalesFem",header=T)#
	#Pull out the lengths and the dates from these data files#
	Dates1<-as.Date(LFD_bigMalesFemales$Date,"%d/%m/%y")               #
	Lengths1<-LFD_bigMalesFemales$Carapacewidth#
	#Read in the trawl data on males that contains juvenile recruitment and adults#
	LFD<-read.table("LFD")#
	#which(LFD$Sex==1)#
	#Pull out the lengths and the dates from these data files#
	Dates2<-as.Date(LFD$Date,"%d/%m/%Y")#
	Lengths2<-LFD$Carapace.width#
	#Concatenate the necessary elements from each file into a common dates and lengths array#
	Dates <- c(Dates2,Dates1)#
	Lengths <- c(Lengths2,Lengths1)#
	#Pull out the year and month information from these dates#
	YEAR <- format(Dates,'%Y')#
	MONTHS <- format(Dates,'%m')#
	#Pull out the years and months that we a re interested in i.e., those that don't contain 	recruitment#
	WHICH85JO <- which((YEAR == '1985') & (as.numeric(MONTHS) %in% (2:8)))#
	WHICH86FM <- which((YEAR == '1986') & (as.numeric(MONTHS) %in% (2:5)))#
	#INITIALISE#
	MON <- 11													#Assign how many months we would like to model#
	LL <- Lengths[c(WHICH85JO,WHICH86FM)]						#Assign the number of individuals#
	MM1985 <- as.numeric(MONTHS[WHICH85JO])-1					#Assign January to be the 0th months#
	MM1986 <- as.numeric(MONTHS[WHICH86FM])+11					#Thus January of next year will be the 12 month. Plus we do this so that we don't have to estimate yr#
	MM<-c(MM1985,MM1986)										#Concatenate these months values together#
	MMLIST <- as.numeric(names(table(MM)))						#Make a list of the months from January first i.e., January 1986 is gets assigned a 12#
	#Parameter Initialise#
	NN <- length(MM)											#Initialise the number of individuals we have#
	PI1 <- rep(1/3,MON)											#Initialise the PIs#
	PI2 <- rep(1/3,MON)											#Initialise the PIs#
	K0 <- 1														#Initialise K0 average K#
	LINF <- 200													#Initialise asym length#
	M01<-40														#Initialise first month's average length#
	M02<-40														#Initialise second month's average length#
	T0 <- 0.1														#Initialise first seasonality parameter#
	T1 <- 0.1														#Initialise second seasonality parameter#
	VV <- c(-10,10,0.1)										   #Initialise the starting values for the variance quadratic update#
	#Setting values for drawing plots #
	#K0=0.84062808;  LINF=159.65387413; M01=58.86155838; M02=81.29860313; T0=-0.07925965; T1=0.57794716; VV=c( -4.77584147,   6.19436755  ,-0.03489903)#
	#0.84062808  -0.07925965   0.57794716 159.65387413  58.86155838  81.29860313  -4.77584147   6.19436755  -0.03489903#
	#FUNCTIONS#
	#ASYMPTOTIC MEAN FUNCTION#
	MU2A <- function(mm,K0,T0,T1,LINF,M01,M02)#
	{#
	  #mm=1#
	  mmval <- MMLIST[mm]%%12#
	  yrsold<-2#
	  strmnth<-min(MM1985)#
	  strmid<-strmnth/12+1/24+yrsold#
	  endmid<-strmid+1#
	  mm2=(mmval/12)+1/24+yrsold#
	  t<-seq(0,1,0.01)#
	  g<-K0+T0*cos(2*pi*t)+T1*sin(2*pi*t)#
	  #plot(t,g)#
	  Isneg<-min(g)#
	  Isneg2<-max(g)#
	  if (Isneg<0&Isneg2>0)#
	  {#
	    a=T0^2+T1^2#
		b=2*K0*T0#
		c=-(T1^2)+K0^2#
		u1=(-b+sqrt(b^2-4*a*c))/(2*a)#
		u2=(-b-sqrt(b^2-4*a*c))/(2*a)#
		r11=1-acos(u1)/(2*pi)+yrsold#
		r12=acos(u1)/(2*pi)+yrsold#
		r21=1-acos(u2)/(2*pi)+yrsold#
		r22=acos(u2)/(2*pi)+yrsold#
		roots<-c(r11, r12, r21, r22)#
		groot<-K0+T0*cos(2*pi* roots)+T1*sin(2*pi* roots)#
		gmin<-round(groot)#
		r1<-min(roots[which(gmin==0)])#
		r2<-max(roots[which(gmin==0)])#
	    #Regime#
		zMid1=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    zEnd1=K0*(endmid-r2) + (T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*r2)) - (T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*r2))#
	    KKyr<-yrsold*(zEnd1+zMid1)#
	    #Those less than r1#
	    if (mm2<r1) {KK = KKyr + K0*(mm2-strmid) +   (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}#
	    #Those between r1 and r2#
	    if (mm2>r1&mm2<r2) {KK= KKyr + K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))}#
	    #Those after r2#
	    if (mm2>r2)#
	    {#
	    zMid=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    zEnd=K0*(mm2-r2)     + (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*r2))     - (T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*r2))#
	    KK<-zEnd+zMid+KKyr#
	    }#
	  } else {KK=K0*(mm2-strmid)+(T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid)) + yrsold*(K0*(endmid-strmid)+(T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*strmid)) )}#
	  if (MMLIST[mm]>max(MM1985)) {M02 + (LINF-M02)*(1-exp(-KK))} else (M01 + (LINF-M01)*(1-exp(-KK)))#
	}#
	#1 YEAR OLD ADULT's MEAN FUNCTION#
	MUA <- function(mm,K0,T0,T1,LINF,M01,M02)#
	{#
	  mmval <- MMLIST[mm]%%12#
	  yrsold<-1#
	  strmnth<-min(MM1985)#
	  strmid<-strmnth/12+1/24+yrsold#
	  endmid<-strmid+1#
	  mm2=(mmval/12)+1/24+yrsold#
	  t<-seq(0,1,0.01)#
	  g<-K0+T0*cos(2*pi*t)+T1*sin(2*pi*t)#
	  Isneg<-min(g)#
	  Isneg2<-max(g)#
	  if (Isneg<0&Isneg2>0)#
	  {#
	    a=T0^2+T1^2#
		b=2*K0*T0#
		c=-(T1^2)+K0^2#
		u1=(-b+sqrt(b^2-4*a*c))/(2*a)#
		u2=(-b-sqrt(b^2-4*a*c))/(2*a)#
		r11=1-acos(u1)/(2*pi)+yrsold#
		r12=acos(u1)/(2*pi)+yrsold#
		r21=1-acos(u2)/(2*pi)+yrsold#
		r22=acos(u2)/(2*pi)+yrsold#
		roots<-c(r11, r12, r21, r22)#
		groot<-K0+T0*cos(2*pi* roots)+T1*sin(2*pi* roots)#
		gmin<-round(groot)#
		r1<-min(roots[which(gmin==0)])#
		r2<-max(roots[which(gmin==0)])#
	    #Regime#
		zMid1=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    zEnd1=K0*(endmid-r2) + (T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*r2)) - (T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*r2))#
	    KKyr<-yrsold*(zEnd1+zMid1)#
	    	#Those less than r1#
	    	if (mm2<r1) {KK = KKyr + K0*(mm2-strmid) +   (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}#
	    	#Those between r1 and r2#
	    	if (mm2>r1&mm2<r2) {KK= KKyr + K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))}#
	    	#Those after r2#
	    	if (mm2>r2)#
	    		{#
	    		zMid=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    		zEnd=K0*(mm2-r2)     + (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*r2))     - (T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*r2))#
	    		KK<-zEnd+zMid+KKyr#
	    		}#
	  } else {KK=K0*(mm2-strmid)+(T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid)) + yrsold*(K0*(endmid-strmid)+(T0/(2*pi))*(sin(2*pi*endmid)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*endmid)-cos(2*pi*strmid)) )}#
	  if (MMLIST[mm]>max(MM1985)) {M02 + (LINF-M02)*(1-exp(-KK))} else (M01 + (LINF-M01)*(1-exp(-KK)))#
	}#
	#THE JUVENUILES MEAN FUNCTION#
	MUJ <- function(mm,K0,T0,T1,LINF,M01,M02)#
	{#
		#mm=2#
		mmval <- MMLIST[mm]%%12#
	  	yrsold<-0#
	  	strmnth<-min(MM1985)#
	  	strmid<-strmnth/12+1/24+yrsold#
	  	endmid<-strmid+1#
	  	mm2=(mmval/12)+1/24+yrsold#
	  	t<-seq(0,1,0.01)#
		g<-K0+T0*cos(2*pi*t)+T1*sin(2*pi*t)#
		Isneg<-min(g)#
		Isneg2<-max(g)#
	 	if (Isneg<0&Isneg2>0)#
	  		{#
	    	a=T0^2+T1^2#
			b=2*K0*T0#
			c=-(T1^2)+K0^2#
			u1=(-b+sqrt(b^2-4*a*c))/(2*a)#
			u2=(-b-sqrt(b^2-4*a*c))/(2*a)#
			r11=1-acos(u1)/(2*pi)#
			r12=acos(u1)/(2*pi)#
			r21=1-acos(u2)/(2*pi)#
			r22=acos(u2)/(2*pi)#
			roots<-c(r11, r12, r21, r22)#
			groot<-K0+T0*cos(2*pi* roots)+T1*sin(2*pi* roots)#
			gmin<-round(groot)#
			r1<-min(roots[which(gmin==0)])#
			r2<-max(roots[which(gmin==0)])#
	    	#Regime#
	    	#Those less than r1#
	    		if (mm2<r1) {KK = K0*(mm2-strmid) +   (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}#
	    		#Those between r1 and r2#
	    		if (mm2>r1&mm2<r2) {KK=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))}#
	    		#Those after r2#
	    		if (mm2>r2)#
	    			{#
	    			zMid=K0*(r1-strmid) + (T0/(2*pi))*(sin(2*pi*r1)-sin(2*pi*strmid)) - (T1/(2*pi))*(cos(2*pi*r1)-cos(2*pi*strmid))#
	    			zEnd=K0*(mm2-r2)     + (T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*r2))     - (T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*r2))#
	    			KK<-zEnd+zMid#
	    			}#
	  	} else {KK=K0*(mm2-strmid)+(T0/(2*pi))*(sin(2*pi*mm2)-sin(2*pi*strmid))-(T1/(2*pi))*(cos(2*pi*mm2)-cos(2*pi*strmid))}	#
	  if (MMLIST[mm]==min(MM1985))  {M01} else if (MMLIST[mm]==min(MM1986)) {M02} else if (MMLIST[mm]>min(MM1985)&MMLIST[mm]<min(MM1986)) {M01 + (LINF-M01)*(1-exp(-KK))} else {M02 + (LINF-M02)*(1-exp(-KK))}#
	}#
	#INITIALISE THE TAU's which are the inclusion probablities to all be a third#
	TAU <- list()#
	for (mm in 1:(MON))#
		{#
	  		TAU[[mm]] <- matrix(1/3,NN,3)#
		}#
	#INITIALISE THE AUXILLARY STORAGE ARRAYS FOR INSIDE LOOP ASSIGNMENT#
	MU2A_AUX <- c()#
	MUA_AUX <- c()#
	MUJ_AUX <- c()#
	for (mm in 1:MON)#
		{#
	 	MU2A_AUX[mm] <- MU2A(mm,K0,T0,T1,LINF,M01,M02)#
	  	MUA_AUX[mm] <- MUA(mm,K0,T0,T1,LINF,M01,M02)#
	 	MUJ_AUX[mm] <- MUJ(mm,K0,T0,T1,LINF,M01,M02)#
		}#
	#INITIALISE THE VARIANCE FUNCTIONS. THEY ARE ALL QUADRATIC FUNCTIONS OF THE MEAN FOR EACH COHORT#
	VARJ <- function(mm,VV,K0,T0,T1,LINF,M01,M02)#
		{#
			max(exp(VV[1])+VV[2]*MUJ(mm,K0,T0,T1,LINF,M01,M02)+VV[3]*MUJ(mm,K0,T0,T1,LINF,M01,M02)^2,1)#
		}#
	VARA <- function(mm,VV,K0,T0,T1,LINF,M01,M02)#
		{#
			max(exp(VV[1])+VV[2]*MUA(mm,K0,T0,T1,LINF,M01,M02)+VV[3]*MUA(mm,K0,T0,T1,LINF,M01,M02)^2,1)#
		}#
	VAR2A <- function(mm,VV,K0,T0,T1,LINF,M01,M02)#
		{#
			max(exp(VV[1])+VV[2]*MU2A(mm,K0,T0,T1,LINF,M01,M02)+VV[3]*MU2A(mm,K0,T0,T1,LINF,M01,M02)^2,1)#
		}#
	#INITIALISE THE LIKELIHOOD FUNCTION#
	LOGLIKE <- 0#
	for (mm in 1:MON)#
	  {#
		LL2<-LL[which(MM==MMLIST[mm])]#
		LikGrp1<-PI1[mm]*dnorm(LL2,MU2A_AUX[mm],sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp2<-PI2[mm]*dnorm(LL2,MUA_AUX[mm],sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  }#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	######WHILE LOOP BEGINS######WHILE LOOP BEGINS######WHILE LOOP BEGINS#
	#THIS LOOP DOES ALL THE WORK AND INCLUDES TWO NELDER MEAD STEPS TO OPTIMISE THE NONLINEAR MEANS AND VARIANCES#
	TOL <- 10^-6#
	LOGOLD <- -Inf#
	while (LOGLIKE - LOGOLD > TOL)#
	{#
	  LOGOLD <- LOGLIKE                     #Assign the current likelihood value to the an old value so we can evaluate the update#
		#UPDATE THE TAU SCORES AND THEN CALCULATE THE PIs GIVEN THESE TAU SCORES#
		for (mm in 1:MON)#
	  	{#
	    	Top1<-PI1[mm]*dnorm(LL,MU2A_AUX[mm],sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02)))							#Calculate the inclusion probablities for group 1#
	    	Top2<-PI2[mm]*dnorm(LL,MUA_AUX[mm],sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02)))								#Calculate the inclusion probablities for group 2#
	    	Bot<- Top1 + Top2 +(1-(PI1[mm]+PI2[mm]))*dnorm(LL,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02)))  #Calculate the sum of each of the classes#
	    	TAU[[mm]][,1] <- Top1/Bot																				#Calculate the first group's tau scores#
	    	TAU[[mm]][,2] <- Top2/Bot																				#Calculate the second group's tau scores#
	   		TAU[[mm]][,3] <- 1-(TAU[[mm]][,1]+TAU[[mm]][,2])													  	#Calculate the third group's tau scores#
	    	PI1[mm] <- sum((MM==MMLIST[mm])*TAU[[mm]][,1])/sum(MM==MMLIST[mm])										#Work out the PIs for group 1#
	    	PI2[mm] <- sum((MM==MMLIST[mm])*TAU[[mm]][,2])/sum(MM==MMLIST[mm])										#Work out the PIs for group 2#
	  	}#
	  #DEFINE THE LIKELIHOOD FUNCTION OUTSIDE THE LOOP TO UPDATE THE MEANS#
	  PARA <- c(K0,T0,T1,LINF,M01,M02)#
	  OPTIFUN <- function(PARA)#
	  {#
	  	LOGLIKE <- 0#
	  		for (mm in 1:MON)#
	  			{#
				LL2<-LL[which(MM==MMLIST[mm])]#
				LikGrp1<-PI1[mm]*dnorm(LL2,MU2A(mm,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]),sqrt(VAR2A(mm,VV,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6])))#
				LikGrp2<-PI2[mm]*dnorm(LL2,MUA(mm,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]),sqrt(VARA(mm,VV,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]))) #
				LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ(mm,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6]),sqrt(VARJ(mm,VV,PARA[1],PARA[2],PARA[3],PARA[4],PARA[5],PARA[6])))#
				LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  			}#
		-LOGLIKE#
	  }#
	  OPTIM <- optim(PARA,OPTIFUN, control = list(maxit = 10000))														#RUN OPTIM to find the best parameters given the taus and Pis#
	  print("Did optim 1 converge?")#
	  print(OPTIM$convergence)#
	  #Assign the estimates from optim to the parameters#
	  K0 <- OPTIM$par[1]#
	  T0 <- OPTIM$par[2]#
	  T1 <- OPTIM$par[3]#
	  LINF <- OPTIM$par[4]#
	  M01 <- OPTIM$par[5]#
	  M02<-OPTIM$par[6]#
	  #Calculate the means for each group based on these new estimates#
	  MU2A_AUX <- c()#
	  MUA_AUX <- c()#
	  MUJ_AUX <- c()#
	  for (mm in 1:MON)#
	  {#
	  	#Compute the means for each month #
	    MU2A_AUX[mm] <- MU2A(mm,K0,T0,T1,LINF,M01,M02)#
	    MUA_AUX[mm] <- MUA(mm,K0,T0,T1,LINF,M01,M02)#
	    MUJ_AUX[mm] <- MUJ(mm,K0,T0,T1,LINF,M01,M02)#
	  }#
	  #OPTIMISE THE VARIANCES GIVEN THE NEW MEANS#
	  #DEFINE THE LIKELIHOOD FUNCTION OUTSIDE THE LOOP TO UPDATE THE VARIANCES #
	  PARA2 <- VV#
	  VAROPTIFUN <- function(PARA2)#
	  {#
	  LOGLIKE <- 0#
	  		for (mm in 1:MON)#
	  			{#
	  			#mm=1#
				LL2<-LL[which(MM==MMLIST[mm])]#
				LikGrp1<- PI1[mm]*dnorm(LL2,MU2A_AUX[mm],sqrt(VAR2A(mm,PARA2,K0,T0,T1,LINF,M01,M02)))#
				LikGrp2<- PI2[mm]*dnorm(LL2,MUA_AUX[mm],sqrt(VARA(mm,PARA2,K0,T0,T1,LINF,M01,M02)))#
				LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ_AUX[mm],sqrt(VARJ(mm,PARA2,K0,T0,T1,LINF,M01,M02)))#
				LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  			}#
		-LOGLIKE#
	  }#
	  OPTIM2 <- optim(PARA2,VAROPTIFUN,control = list(maxit = 10000))													#RUN OPTIM to find the best variances given the taus and Pis#
	  VV <- OPTIM2$par#
	  print("Did optim 2 converge?")#
	  print(OPTIM2$convergence)  #
	  #COMPUTE THE LIKELIHOOD GIVEN ALL THESE NICE NEW UPDATES#
	  LOGLIKE <- 0#
	  for (mm in 1:MON)#
	  {#
		LL2<-LL[which(MM==MMLIST[mm])]#
		LikGrp1<-PI1[mm]*dnorm(LL2,MU2A_AUX[mm],sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp2<-PI2[mm]*dnorm(LL2,MUA_AUX[mm],sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LikGrp3<-(1-(PI1[mm]+PI2[mm]))*dnorm(LL2,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02)))#
		LOGLIKE <- LOGLIKE + sum(log(LikGrp1 + LikGrp2 + LikGrp3))#
	  }#
	  #PRINT OUT OUR NEW UPDATES FOR THE PARAMETERS AND THE LIKELIHOOD#
	  print(c(LOGLIKE,LOGLIKE-LOGOLD))#
	  print(c(PARA,PARA2))#
	  #DRAW SOME NICE REAL TIME PLOTS SO WE CAN MONITOR CONVERGENCE#
	  par(mfrow = c(4,5))#
	  XX <- 0:200#
	  xlabNam<-c("Feb., 1985","Mar., 1985","Apr., 1985","May, 1985","Jun., 1985","Jul, 1985","Aug., 1985","Feb., 1986","Mar., 1986","Apr., 1986","May, 1986")#
	  for (mm in 1:MON)#
	  {#
	    hist(LL[which(MM==MMLIST[mm])],breaks=30,prob=T,xlim=c(20,210),ylim=c(0,0.055),xlab=xlabNam[mm],ylab="",main='')#
	    lines(XX,PI1[mm]*dnorm(XX,MU2A(mm,K0,T0,T1,LINF,M01,M02),sqrt(VAR2A(mm,VV,K0,T0,T1,LINF,M01,M02))),col='red',lwd=2.5)#
	    lines(XX,PI2[mm]*dnorm(XX,MUA(mm,K0,T0,T1,LINF,M01,M02),sqrt(VARA(mm,VV,K0,T0,T1,LINF,M01,M02))),col='green',lwd=2.5)#
	    lines(XX,(1-(PI1[mm]+PI2[mm]))*dnorm(XX,MUJ_AUX[mm],sqrt(VARJ(mm,VV,K0,T0,T1,LINF,M01,M02))),col='blue',lwd=2.5)#
	  }#
	  XX2 <- seq(0,1,length.out=100)#
	  YY <- K0 + T0*cos(2*pi*XX2) + T1*sin(2*pi*XX2)#
	  plot(XX2,((YY+abs(YY))/2),type='l',xlab="Fraction of a year since Jan 1",ylab="k (per year)",lwd=2.5)#
	  BLAH <- 50:170#
	  #plot(BLAH,exp(VV[1])+VV[2]*BLAH+VV[3]*BLAH^2,type='l',xlab="Mean length (mm)", ylab="Variance",lwd=2.5,ylim=c(0,300))#
	  #plot(density(rnorm(1000000,PARA[4],sqrt(PARA2[2]*PARA[4]+ PARA2[3]*PARA[4]^2))),xlab="Length (mm)",main="",lwd=2.5)#
	}
